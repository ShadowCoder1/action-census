<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PD Finger Tapping Webcam Analysis</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background-color: #0a0e27;
            color: #ffffff;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .video-container {
            background: #1a1f3a;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
            position: relative;
        }

        .video-wrapper {
            position: relative;
            width: 100%;
            padding-bottom: 75%;
            background: #000;
            border-radius: 10px;
            overflow: hidden;
        }

        video, canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 10px;
        }

        .controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background: #4a5568;
            cursor: not-allowed;
            box-shadow: none;
        }

        .metrics-panel {
            background: #1a1f3a;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
        }

        .metric-card {
            background: linear-gradient(135deg, #1e2139 0%, #2a2d4a 100%);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            border: 1px solid rgba(255,255,255,0.1);
            transition: all 0.3s ease;
        }

        .metric-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .metric-label {
            font-size: 0.9em;
            opacity: 0.8;
            margin-bottom: 5px;
        }

        .metric-value {
            font-size: 2em;
            font-weight: bold;
            color: #667eea;
        }

        .metric-unit {
            font-size: 0.8em;
            opacity: 0.6;
            margin-left: 5px;
        }

        .chart-container {
            grid-column: span 2;
            background: #1a1f3a;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
        }

        .chart-wrapper {
            position: relative;
            height: 300px;
            margin-bottom: 20px;
        }

        .status-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: bold;
            animation: pulse 2s infinite;
        }

        .status-ready {
            background: #48bb78;
            color: white;
        }

        .status-recording {
            background: #ed8936;
            color: white;
        }

        .status-analyzing {
            background: #667eea;
            color: white;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        .instructions {
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .instructions h3 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .instructions ol {
            margin-left: 20px;
            line-height: 1.8;
        }

        .results-summary {
            background: linear-gradient(135deg, #1e2139 0%, #2a2d4a 100%);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            border: 2px solid #667eea;
        }

        .results-summary h3 {
            color: #667eea;
            margin-bottom: 15px;
        }

        .result-item {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .result-item:last-child {
            border-bottom: none;
        }

        .severity-indicator {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 0.9em;
            font-weight: bold;
        }

        .severity-normal { background: #48bb78; }
        .severity-slight { background: #90cdf4; }
        .severity-mild { background: #f6e05e; }
        .severity-moderate { background: #ed8936; }
        .severity-severe { background: #e53e3e; }

        .countdown {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 120px;
            font-weight: bold;
            color: #667eea;
            text-shadow: 0 0 20px rgba(102, 126, 234, 0.8);
            z-index: 10;
            animation: countdownPulse 1s ease-in-out;
        }

        @keyframes countdownPulse {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 0.8; }
        }

        .hand-indicator {
            display: inline-block;
            padding: 6px 12px;
            border-radius: 8px;
            margin-left: 10px;
            font-size: 0.9em;
            font-weight: bold;
        }

        .hand-left { background: #4299e1; }
        .hand-right { background: #48bb78; }

        .export-section {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }

        .parameter-info {
            font-size: 0.85em;
            opacity: 0.7;
            margin-top: 5px;
            line-height: 1.4;
        }

        .algorithm-status {
            background: rgba(102, 126, 234, 0.2);
            border: 1px solid #667eea;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 15px;
            font-size: 0.9em;
        }

        @media (max-width: 1024px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
            
            .chart-container {
                grid-column: span 1;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Parkinson's Disease Finger Tapping Webcam Analysis </h1>
            <p>Demo V1</p>
        </div>

        <div class="instructions">
            <h3>Instructions</h3>
            <ol>
                <li>Position your hand clearly in view of the camera with palm facing down</li>
                <li>When ready, click "Start Recording"</li>
                <li>Tap your index finger to your thumb as quickly and as widely as possible</li>
                <li>Continue for 10 seconds (system will automatically stop)</li>
                <li>Keep your hand as steady as possible during the test</li>
            </ol>
        </div>

        <div class="main-grid">
            <div class="video-container">
                <div class="status-indicator status-ready" id="status">Ready</div>
                <div class="video-wrapper">
                    <video id="inputVideo" autoplay playsinline></video>
                    <canvas id="outputCanvas"></canvas>
                    <div id="countdown" class="countdown" style="display: none;"></div>
                </div>
                <div class="controls">
                    <button id="startBtn" onclick="startRecording()">Start Recording</button>
                    <button id="stopBtn" onclick="stopRecording()" disabled>Stop Recording</button>
                    <button id="resetBtn" onclick="resetAnalysis()">Reset</button>
                    <select id="handSelect" style="padding: 10px; border-radius: 8px; background: #2a2d4a; color: white; border: 1px solid #667eea;">
                        <option value="right">Right Hand</option>
                        <option value="left">Left Hand</option>
                    </select>
                </div>
                <div class="algorithm-status" id="algorithmStatus">
                    Algorithm: Advanced peak detection with signal processing
                </div>
            </div>

            <div class="metrics-panel">
                <h2 style="margin-bottom: 20px; color: #667eea;">Real-time Metrics</h2>
                
                <div class="metric-card">
                    <div class="metric-label">Tap Count</div>
                    <div class="metric-value" id="tapCount">0</div>
                </div>

                <div class="metric-card">
                    <div class="metric-label">Average Frequency</div>
                    <div class="metric-value" id="avgFrequency">0.00<span class="metric-unit">Hz</span></div>
                    <div class="parameter-info">Normal: 2-3 Hz</div>
                </div>

                <div class="metric-card">
                    <div class="metric-label">Average Amplitude</div>
                    <div class="metric-value" id="avgAmplitude">0.00<span class="metric-unit">mm</span></div>
                    <div class="parameter-info">Normalized hand-relative distance</div>
                </div>

                <div class="metric-card">
                    <div class="metric-label">Amplitude Decrement</div>
                    <div class="metric-value" id="ampDecrement">0.00<span class="metric-unit">%</span></div>
                    <div class="parameter-info">Progressive reduction in amplitude</div>
                </div>

                <div class="metric-card">
                    <div class="metric-label">Rhythm Variability (CV)</div>
                    <div class="metric-value" id="rhythmCV">0.00<span class="metric-unit">%</span></div>
                    <div class="parameter-info">Inter-tap interval coefficient of variation</div>
                </div>

                <div class="metric-card">
                    <div class="metric-label">Hesitations/Freezing</div>
                    <div class="metric-value" id="hesitations">0</div>
                    <div class="parameter-info">Interruptions > 500ms</div>
                </div>
            </div>
        </div>

        <div class="chart-container">
            <h2 style="margin-bottom: 20px; color: #667eea;">Movement Analysis</h2>
            
            <div class="chart-wrapper">
                <canvas id="distanceChart"></canvas>
            </div>

            <div class="chart-wrapper">
                <canvas id="velocityChart"></canvas>
            </div>

            <div id="resultsDiv" class="results-summary" style="display: none;">
                <h3>Clinical Assessment Summary</h3>
                <div id="assessmentResults"></div>
                <div class="export-section">
                    <button onclick="exportResults()">Export Results (JSON)</button>
                    <button onclick="exportCSV()">Export Data (CSV)</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let camera, hands, canvasCtx, recording = false;
        let startTime, handDetected = false;
        let distanceChart, velocityChart;
        let recordingDuration = 10000; // 10 seconds
        let countdownInterval;
        let frameCount = 0;

        // Signal processing variables
        let distanceSignal = [];
        let timeSignal = [];
        let smoothedSignal = [];
        let velocitySignal = [];
        let peakIndices = [];
        let tapEvents = [];
        let lastPeakTime = 0;
        
        // Parameters for signal processing
        const SAMPLE_RATE = 30; // Assumed 30 FPS
        const SMOOTHING_WINDOW = 3; // Moving average window
        const MIN_PEAK_PROMINENCE = 0.3; // Minimum prominence for peak detection
        const MIN_PEAK_DISTANCE = 100; // Minimum ms between peaks
        // ▼ ADD THESE TWO LINES
        const CLOSED_THRESHOLD_PCT      = 30;  // below this = fingers counted “closed”
        const OPEN_THRESHOLD_PCT        = 35;  // must reopen past this before next tap
        // ▲ ADDED
        const VELOCITY_THRESHOLD_PERCENTILE = 70; // Percentile for adaptive threshold

        // Hand landmarks indices
        const WRIST = 0;
        const THUMB_TIP = 4;
        const INDEX_TIP = 8;
        const MIDDLE_MCP = 9;
        
        // Initialize MediaPipe Hands
        function initializeHands() {
            hands = new Hands({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                }
            });

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.7
            });

            hands.onResults(onHandsResults);
        }

        // Initialize camera
        function initializeCamera() {
            const videoElement = document.getElementById('inputVideo');
            const canvasElement = document.getElementById('outputCanvas');
            canvasCtx = canvasElement.getContext('2d');

            camera = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 640,
                height: 480
            });
            camera.start();
        }

        // Moving average filter
        function movingAverage(data, windowSize) {
            const result = [];
            for (let i = 0; i < data.length; i++) {
                let start = Math.max(0, i - Math.floor(windowSize / 2));
                let end = Math.min(data.length, i + Math.floor(windowSize / 2) + 1);
                let sum = 0;
                for (let j = start; j < end; j++) {
                    sum += data[j];
                }
                result.push(sum / (end - start));
            }
            return result;
        }

        // Calculate numerical derivative
        function calculateDerivative(data, timeData) {
            const derivative = [];
            for (let i = 1; i < data.length; i++) {
                const dt = (timeData[i] - timeData[i-1]) / 1000; // Convert to seconds
                const dy = data[i] - data[i-1];
                derivative.push(dy / dt);
            }
            return derivative;
        }

        // Find peaks in signal using adaptive thresholding
        function findPeaks(signal, prominence = MIN_PEAK_PROMINENCE) {
            const peaks = [];
            
            // Calculate signal statistics for adaptive thresholding
            const mean = signal.reduce((a, b) => a + b, 0) / signal.length;
            const variance = signal.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / signal.length;
            const std = Math.sqrt(variance);
            
            // Adaptive threshold based on signal statistics
            const threshold = mean + prominence * std;
            
            // Find local maxima above threshold
            for (let i = 1; i < signal.length - 1; i++) {
                if (signal[i] > signal[i-1] && signal[i] > signal[i+1] && signal[i] > threshold) {
                    // Check minimum distance from last peak
                    if (peaks.length === 0 || (timeSignal[i] - timeSignal[peaks[peaks.length - 1]]) > MIN_PEAK_DISTANCE) {
                        peaks.push(i);
                    }
                }
            }
            
            return peaks;
        }

        function detectTapsFromVelocity(velocitySignal, distanceSignal) {
            const taps = [];
            let state = 'open'; // can be 'open', 'closed', or 'must_open'
            let lastTapTime = -Infinity;

            for (let i = 1; i < velocitySignal.length - 1; i++) {
                const t = timeSignal[i];
                const dist = distanceSignal[i];
                const velPrev = velocitySignal[i - 1];
                const velCurr = velocitySignal[i];

                switch (state) {
                    case 'open':
                        if (dist < 30 && velPrev < 0 && velCurr >= 0) {
                            // Fingers just closed — register a tap
                            if ((t - lastTapTime) > MIN_PEAK_DISTANCE) {
                                taps.push({
                                    index: i,
                                    time: t,
                                    amplitude: dist
                                });
                                lastTapTime = t;
                                state = 'must_open';
                            }
                        }
                        break;

                    case 'must_open':
                        if (dist > 35) {
                            state = 'open';
                        }
                        break;

                    default:
                        // fallback in case of unexpected state
                        state = 'open';
                }
            }

            return taps;
        }



        // Process hand detection results
        function onHandsResults(results) {
            const canvasElement = document.getElementById('outputCanvas');
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            
            // Draw the image
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                handDetected = true;
                const landmarks = results.multiHandLandmarks[0];
                
                // Draw hand skeleton
                drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
                drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 1, radius: 3});

                // Process finger tap data if recording
                if (recording) {
                    processFingerTapAdvanced(landmarks, results.image.width, results.image.height);
                }

                // Highlight thumb and index fingertips
                const thumbTip = landmarks[THUMB_TIP];
                const indexTip = landmarks[INDEX_TIP];
                
                // Draw larger circles for thumb and index
                canvasCtx.fillStyle = '#667eea';
                canvasCtx.beginPath();
                canvasCtx.arc(thumbTip.x * canvasElement.width, thumbTip.y * canvasElement.height, 8, 0, 2 * Math.PI);
                canvasCtx.fill();
                
                canvasCtx.beginPath();
                canvasCtx.arc(indexTip.x * canvasElement.width, indexTip.y * canvasElement.height, 8, 0, 2 * Math.PI);
                canvasCtx.fill();

                // Draw line between thumb and index
                canvasCtx.strokeStyle = '#667eea';
                canvasCtx.lineWidth = 3;
                canvasCtx.beginPath();
                canvasCtx.moveTo(thumbTip.x * canvasElement.width, thumbTip.y * canvasElement.height);
                canvasCtx.lineTo(indexTip.x * canvasElement.width, indexTip.y * canvasElement.height);
                canvasCtx.stroke();

                // Draw detected peaks
                if (peakIndices.length > 0 && distanceSignal.length > 0) {
                    canvasCtx.fillStyle = '#e53e3e';
                    peakIndices.forEach(peakIdx => {
                        if (peakIdx < distanceSignal.length) {
                            // Visual indicator for detected taps
                            canvasCtx.beginPath();
                            canvasCtx.arc(
                                (thumbTip.x + indexTip.x) / 2 * canvasElement.width,
                                (thumbTip.y + indexTip.y) / 2 * canvasElement.height,
                                15, 0, 2 * Math.PI
                            );
                            canvasCtx.fill();
                        }
                    });
                }
            } else {
                handDetected = false;
            }

            canvasCtx.restore();
        }

        // MediaPipe hand connections
        const HAND_CONNECTIONS = [
            [0, 1], [1, 2], [2, 3], [3, 4],
            [0, 5], [5, 6], [6, 7], [7, 8],
            [5, 9], [9, 10], [10, 11], [11, 12],
            [9, 13], [13, 14], [14, 15], [15, 16],
            [13, 17], [17, 18], [18, 19], [19, 20],
            [0, 17]
        ];

        // Helper functions for drawing
        function drawConnectors(ctx, landmarks, connections, style) {
            ctx.strokeStyle = style.color;
            ctx.lineWidth = style.lineWidth;
            
            connections.forEach(([start, end]) => {
                const startLandmark = landmarks[start];
                const endLandmark = landmarks[end];
                
                ctx.beginPath();
                ctx.moveTo(startLandmark.x * ctx.canvas.width, startLandmark.y * ctx.canvas.height);
                ctx.lineTo(endLandmark.x * ctx.canvas.width, endLandmark.y * ctx.canvas.height);
                ctx.stroke();
            });
        }

        function drawLandmarks(ctx, landmarks, style) {
            ctx.fillStyle = style.color;
            
            landmarks.forEach(landmark => {
                ctx.beginPath();
                ctx.arc(landmark.x * ctx.canvas.width, landmark.y * ctx.canvas.height, 
                       style.radius, 0, 2 * Math.PI);
                ctx.fill();
            });
        }

        // Advanced finger tap processing with signal analysis
        function processFingerTapAdvanced(landmarks, imageWidth, imageHeight) {
            const currentTime = Date.now() - startTime;
            frameCount++;
            
            // Calculate 3D distance between thumb and index tips
            const thumbTip = landmarks[THUMB_TIP];
            const indexTip = landmarks[INDEX_TIP];
            const wrist = landmarks[WRIST];
            const middleMcp = landmarks[MIDDLE_MCP];
            
            // Calculate hand size for normalization
            const handSize = Math.sqrt(
                Math.pow((wrist.x - middleMcp.x) * imageWidth, 2) +
                Math.pow((wrist.y - middleMcp.y) * imageHeight, 2)
            );
            
            // Calculate normalized distance
            const distance = Math.sqrt(
                Math.pow((thumbTip.x - indexTip.x) * imageWidth, 2) +
                Math.pow((thumbTip.y - indexTip.y) * imageHeight, 2) +
                Math.pow((thumbTip.z - indexTip.z) * imageWidth * 0.5, 2) // Z depth with reduced weight
            );
            
            const normalizedDistance = (distance / handSize) * 100;
            
            // Add to signal arrays
            distanceSignal.push(normalizedDistance);
            timeSignal.push(currentTime);
            
            // Apply signal processing every few frames
            if (frameCount % 2 === 0 && distanceSignal.length > SMOOTHING_WINDOW) {
                // Smooth the signal
                smoothedSignal = movingAverage(distanceSignal, SMOOTHING_WINDOW);
                
                // Calculate velocity
                if (smoothedSignal.length > 1) {
                    velocitySignal = calculateDerivative(smoothedSignal, timeSignal);
                    
                    // Detect taps using multiple methods
                    detectTapsMultiMethod();
                }
                
                // Update real-time metrics
                updateRealtimeMetrics();
                
                // Update charts
                updateCharts();
            }
        }

        // Multi-method tap detection for robustness
// Multi-method tap detection for robustness — debounced so it never
// registers more than one tap while the fingers stay closed.
        function detectTapsMultiMethod() {
            const rawEvents = [];            // collect all raw detections here
            const added     = new Set();     // prevent duplicate indices

            /* --------- 1. Velocity zero-crossings (most reliable) --------- */
            detectTapsFromVelocity(velocitySignal, smoothedSignal).forEach(ev => {
                if (!added.has(ev.index)) { rawEvents.push(ev); added.add(ev.index); }
            });

            /* --------- 2. Distance-based peaks at full closure --------- */
            const inverted = smoothedSignal.map(d => 100 - d);
            findPeaks(inverted, 0.5).forEach(idx => {
                if (smoothedSignal[idx] < CLOSED_THRESHOLD_PCT && !added.has(idx)) {
                    rawEvents.push({ index: idx, time: timeSignal[idx], amplitude: smoothedSignal[idx] });
                    added.add(idx);
                }
            });

            /* --------- ➊ sort by time, ➋ enforce reopen gate --------- */
            rawEvents.sort((a, b) => a.time - b.time);
            tapEvents = [];

            for (const ev of rawEvents) {
                if (tapEvents.length === 0) {          // always accept the first tap
                    tapEvents.push(ev);
                    continue;
                }

                const last = tapEvents[tapEvents.length - 1];

                // (a) honour MIN_PEAK_DISTANCE
                if (ev.time - last.time < MIN_PEAK_DISTANCE) continue;

                // (b) NEW — require signal to reopen past OPEN_THRESHOLD_PCT
                let reopened = false;
                for (let i = last.index + 1; i < ev.index; i++) {
                    if (smoothedSignal[i] > OPEN_THRESHOLD_PCT) { reopened = true; break; }
                }
                if (!reopened) continue;              // still the same closed dwell

                tapEvents.push(ev);
            }
        }

        // Find local minima in signal
        function findMinima(signal) {
            const minima = [];
            for (let i = 1; i < signal.length - 1; i++) {
                if (signal[i] < signal[i-1] && signal[i] < signal[i+1]) {
                    minima.push(i);
                }
            }
            return minima;
        }

        // Update real-time metrics display
        function updateRealtimeMetrics() {
            if (tapEvents.length === 0) return;
            
            // Tap count
            document.getElementById('tapCount').textContent = tapEvents.length;
            
            // Calculate inter-tap intervals and metrics
            if (tapEvents.length > 1) {
                const intervals = [];
                const amplitudes = [];
                
                for (let i = 1; i < tapEvents.length; i++) {
                    intervals.push(tapEvents[i].time - tapEvents[i-1].time);
                }
                
                // Get peak amplitudes (maximum distance between taps)
                for (let i = 0; i < tapEvents.length - 1; i++) {
                    const startIdx = tapEvents[i].index;
                    const endIdx = tapEvents[i+1].index;
                    let maxAmp = 0;
                    for (let j = startIdx; j < endIdx && j < smoothedSignal.length; j++) {
                        maxAmp = Math.max(maxAmp, smoothedSignal[j]);
                    }
                    amplitudes.push(maxAmp);
                }
                
                // Average frequency
                const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
                const frequency = 1000 / avgInterval;
                document.getElementById('avgFrequency').innerHTML = frequency.toFixed(2) + '<span class="metric-unit">Hz</span>';
                
                // Average amplitude
                if (amplitudes.length > 0) {
                    const avgAmplitude = amplitudes.reduce((a, b) => a + b, 0) / amplitudes.length;
                    document.getElementById('avgAmplitude').innerHTML = avgAmplitude.toFixed(1) + '<span class="metric-unit">%</span>';
                    
                    // Amplitude decrement
                    if (amplitudes.length >= 3) {
                        const firstThird = amplitudes.slice(0, Math.floor(amplitudes.length / 3));
                        const lastThird = amplitudes.slice(-Math.floor(amplitudes.length / 3));
                        const firstAvg = firstThird.reduce((a, b) => a + b, 0) / firstThird.length;
                        const lastAvg = lastThird.reduce((a, b) => a + b, 0) / lastThird.length;
                        const decrement = ((firstAvg - lastAvg) / firstAvg) * 100;
                        document.getElementById('ampDecrement').innerHTML = decrement.toFixed(1) + '<span class="metric-unit">%</span>';
                    }
                }
                
                // Rhythm variability
                const mean = intervals.reduce((a, b) => a + b, 0) / intervals.length;
                const variance = intervals.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / intervals.length;
                const std = Math.sqrt(variance);
                const cv = (std / mean) * 100;
                document.getElementById('rhythmCV').innerHTML = cv.toFixed(1) + '<span class="metric-unit">%</span>';
                
                // Hesitations
                const hesitations = intervals.filter(i => i > 500).length;
                document.getElementById('hesitations').textContent = hesitations;
            }
        }

        // Initialize charts
        function initializeCharts() {
            const chartOptions = {
                responsive: true,
                maintainAspectRatio: false,
                animation: {
                    duration: 0
                },
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Time (seconds)',
                            color: '#ffffff'
                        },
                        ticks: { color: '#ffffff' },
                        grid: { color: 'rgba(255, 255, 255, 0.1)' }
                    },
                    y: {
                        ticks: { color: '#ffffff' },
                        grid: { color: 'rgba(255, 255, 255, 0.1)' }
                    }
                },
                plugins: {
                    legend: {
                        labels: { color: '#ffffff' }
                    }
                }
            };

            // Distance chart
            const distCtx = document.getElementById('distanceChart').getContext('2d');
            distanceChart = new Chart(distCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Finger Distance',
                        data: [],
                        borderColor: '#667eea',
                        backgroundColor: 'rgba(102, 126, 234, 0.1)',
                        tension: 0.1,
                        pointRadius: 0
                    }, {
                        label: 'Smoothed',
                        data: [],
                        borderColor: '#48bb78',
                        backgroundColor: 'rgba(72, 187, 120, 0.1)',
                        tension: 0.1,
                        pointRadius: 0
                    }, {
                        label: 'Detected Taps',
                        data: [],
                        borderColor: '#e53e3e',
                        backgroundColor: '#e53e3e',
                        showLine: false,
                        pointRadius: 8,
                        pointStyle: 'triangle'
                    }]
                },
                options: {
                    ...chartOptions,
                    scales: {
                        ...chartOptions.scales,
                        y: {
                            ...chartOptions.scales.y,
                            title: {
                                display: true,
                                text: 'Distance (% hand size)',
                                color: '#ffffff'
                            }
                        }
                    }
                }
            });

            // Velocity chart
            const velCtx = document.getElementById('velocityChart').getContext('2d');
            velocityChart = new Chart(velCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Velocity',
                        data: [],
                        borderColor: '#ed8936',
                        backgroundColor: 'rgba(237, 137, 54, 0.1)',
                        tension: 0.1,
                        pointRadius: 0
                    }, {
                        label: 'Zero Line',
                        data: [],
                        borderColor: 'rgba(255, 255, 255, 0.3)',
                        borderDash: [5, 5],
                        pointRadius: 0
                    }]
                },
                options: {
                    ...chartOptions,
                    scales: {
                        ...chartOptions.scales,
                        y: {
                            ...chartOptions.scales.y,
                            title: {
                                display: true,
                                text: 'Velocity (% hand size/s)',
                                color: '#ffffff'
                            }
                        }
                    }
                }
            });
        }

        // Update charts with new data
        function updateCharts() {
            if (distanceSignal.length < 2) return;

            // Prepare time labels
            const timeLabels = timeSignal.map(t => (t / 1000).toFixed(2));
            
            // Update distance chart
            distanceChart.data.labels = timeLabels;
            distanceChart.data.datasets[0].data = distanceSignal;
            distanceChart.data.datasets[1].data = smoothedSignal;
            
            // Add tap markers
            const tapData = new Array(distanceSignal.length).fill(null);
            tapEvents.forEach(tap => {
                if (tap.index < tapData.length) {
                    tapData[tap.index] = smoothedSignal[tap.index];
                }
            });
            distanceChart.data.datasets[2].data = tapData;
            
            distanceChart.update('none');

            // Update velocity chart
            if (velocitySignal.length > 0) {
                const velTimeLabels = timeSignal.slice(1).map(t => (t / 1000).toFixed(2));
                velocityChart.data.labels = velTimeLabels;
                velocityChart.data.datasets[0].data = velocitySignal;
                velocityChart.data.datasets[1].data = new Array(velocitySignal.length).fill(0);
                velocityChart.update('none');
            }
        }

        // Start recording with countdown
        function startRecording() {
            if (!handDetected) {
                alert('Please position your hand in view of the camera before starting.');
                return;
            }

            // Reset all data
            distanceSignal = [];
            timeSignal = [];
            smoothedSignal = [];
            velocitySignal = [];
            tapEvents = [];
            frameCount = 0;

            let countdown = 3;
            const countdownEl = document.getElementById('countdown');
            countdownEl.style.display = 'block';
            countdownEl.textContent = countdown;

            document.getElementById('startBtn').disabled = true;

            countdownInterval = setInterval(() => {
                countdown--;
                if (countdown > 0) {
                    countdownEl.textContent = countdown;
                    countdownEl.style.animation = 'none';
                    setTimeout(() => {
                        countdownEl.style.animation = 'countdownPulse 1s ease-in-out';
                    }, 10);
                } else {
                    clearInterval(countdownInterval);
                    countdownEl.style.display = 'none';
                    startActualRecording();
                }
            }, 1000);
        }

        // Start actual recording
        function startActualRecording() {
            recording = true;
            startTime = Date.now();
            distanceSignal = [];
            timeSignal = [];
            smoothedSignal = [];
            velocitySignal = [];
            tapEvents = [];
            frameCount = 0;

            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            document.getElementById('status').textContent = 'Recording';
            document.getElementById('status').className = 'status-indicator status-recording';
            document.getElementById('algorithmStatus').textContent = 'Algorithm: Recording signal data...';

            // Auto-stop after 10 seconds
            setTimeout(() => {
                if (recording) {
                    stopRecording();
                }
            }, recordingDuration);
        }

        // Stop recording
        function stopRecording() {
            recording = false;
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('status').textContent = 'Analyzing';
            document.getElementById('status').className = 'status-indicator status-analyzing';
            document.getElementById('algorithmStatus').textContent = 'Algorithm: Processing signal and detecting peaks...';

            // Perform final analysis
            setTimeout(() => {
                analyzeResults();
                document.getElementById('status').textContent = 'Complete';
                document.getElementById('status').className = 'status-indicator status-ready';
                document.getElementById('algorithmStatus').textContent = 'Algorithm: Analysis complete';
            }, 500);
        }

        // Analyze results and provide clinical assessment
        function analyzeResults() {
            if (tapEvents.length < 2) {
                alert('Insufficient taps detected. Please try again with larger, more distinct tapping movements.');
                return;
            }

            const assessment = calculateClinicalAssessment();
            displayResults(assessment);
        }

        // Calculate clinical assessment based on MDS-UPDRS criteria
        function calculateClinicalAssessment() {
            const tapCount = tapEvents.length;
            const intervals = [];
            const amplitudes = [];
            
            // Calculate intervals and amplitudes
            for (let i = 1; i < tapEvents.length; i++) {
                intervals.push(tapEvents[i].time - tapEvents[i-1].time);
            }
            
            // Get peak amplitudes between taps
            for (let i = 0; i < tapEvents.length - 1; i++) {
                const startIdx = tapEvents[i].index;
                const endIdx = tapEvents[i+1].index;
                let maxAmp = 0;
                for (let j = startIdx; j < endIdx && j < smoothedSignal.length; j++) {
                    maxAmp = Math.max(maxAmp, smoothedSignal[j]);
                }
                amplitudes.push(maxAmp);
            }
            
            // Calculate metrics
            const avgFrequency = intervals.length > 0 ? 1000 / (intervals.reduce((a, b) => a + b, 0) / intervals.length) : 0;
            const avgAmplitude = amplitudes.length > 0 ? amplitudes.reduce((a, b) => a + b, 0) / amplitudes.length : 0;
            
            // Amplitude decrement
            let amplitudeDecrement = 0;
            if (amplitudes.length >= 3) {
                const firstThird = amplitudes.slice(0, Math.floor(amplitudes.length / 3));
                const lastThird = amplitudes.slice(-Math.floor(amplitudes.length / 3));
                const firstAvg = firstThird.reduce((a, b) => a + b, 0) / firstThird.length;
                const lastAvg = lastThird.reduce((a, b) => a + b, 0) / lastThird.length;
                amplitudeDecrement = ((firstAvg - lastAvg) / firstAvg) * 100;
            }
            
            // Rhythm variability
            let rhythmCV = 0;
            if (intervals.length > 0) {
                const mean = intervals.reduce((a, b) => a + b, 0) / intervals.length;
                const variance = intervals.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / intervals.length;
                rhythmCV = (Math.sqrt(variance) / mean) * 100;
            }
            
            // Hesitations and freezing
            const hesitations = intervals.filter(i => i > 500 && i < 1000).length;
            const freezing = intervals.filter(i => i >= 1000).length;
            
            // Clinical scoring based on MDS-UPDRS criteria
            let score = 0;
            let details = [];
            
            // Speed assessment
            if (avgFrequency < 1.5) {
                score = Math.max(score, 3);
                details.push("Moderate to severe slowing");
            } else if (avgFrequency < 2.0) {
                score = Math.max(score, 2);
                details.push("Mild slowing");
            } else if (avgFrequency < 2.5) {
                score = Math.max(score, 1);
                details.push("Slight slowing");
            }
            
            // Amplitude assessment
            if (avgAmplitude < 20) {
                score = Math.max(score, 2);
                details.push("Small amplitude movements");
            }
            
            // Amplitude decrement assessment
            if (amplitudeDecrement > 50) {
                score = Math.max(score, 3);
                details.push("Severe amplitude decrement");
            } else if (amplitudeDecrement > 30) {
                score = Math.max(score, 2);
                details.push("Amplitude decrements midway");
            } else if (amplitudeDecrement > 15) {
                score = Math.max(score, 1);
                details.push("Amplitude decrements near the end");
            }
            
            // Hesitations/interruptions
            if (freezing > 0) {
                score = Math.max(score, 3);
                details.push(`${freezing} freezing episode(s)`);
            } else if (hesitations >= 5) {
                score = Math.max(score, 3);
                details.push("More than 5 interruptions");
            } else if (hesitations >= 3) {
                score = Math.max(score, 2);
                details.push("3-5 interruptions");
            } else if (hesitations >= 1) {
                score = Math.max(score, 1);
                details.push("1-2 interruptions");
            }
            
            // Rhythm irregularity
            if (rhythmCV > 40) {
                score = Math.max(score, 2);
                details.push("Significant rhythm irregularity");
            } else if (rhythmCV > 25) {
                score = Math.max(score, 1);
                details.push("Mild rhythm irregularity");
            }
            
            return {
                score: score,
                details: details,
                metrics: {
                    tapCount: tapCount,
                    avgFrequency: avgFrequency,
                    avgAmplitude: avgAmplitude,
                    amplitudeDecrement: amplitudeDecrement,
                    rhythmCV: rhythmCV,
                    hesitations: hesitations,
                    freezing: freezing,
                    testDuration: (timeSignal[timeSignal.length - 1] || 0) / 1000,
                    signalQuality: {
                        framesProcessed: frameCount,
                        samplingRate: frameCount / ((timeSignal[timeSignal.length - 1] || 1) / 1000),
                        detectionsConfidence: tapEvents.length / (frameCount / 30) // Taps per second vs expected
                    }
                }
            };
        }

        // Display results
        function displayResults(assessment) {
            const resultsDiv = document.getElementById('resultsDiv');
            const assessmentResults = document.getElementById('assessmentResults');
            
            resultsDiv.style.display = 'block';
            
            // Score interpretation
            const scoreLabels = ['Normal', 'Slight', 'Mild', 'Moderate', 'Severe'];
            const scoreClasses = ['severity-normal', 'severity-slight', 'severity-mild', 'severity-moderate', 'severity-severe'];
            
            let html = `
                <div class="result-item">
                    <span>MDS-UPDRS Equivalent Score:</span>
                    <span class="severity-indicator ${scoreClasses[assessment.score]}">${assessment.score} - ${scoreLabels[assessment.score]}</span>
                </div>
                <div class="result-item">
                    <span>Clinical Observations:</span>
                    <span>${assessment.details.length > 0 ? assessment.details.join(', ') : 'No significant abnormalities'}</span>
                </div>
                <div class="result-item">
                    <span>Test Duration:</span>
                    <span>${assessment.metrics.testDuration.toFixed(1)} seconds</span>
                </div>
                <div class="result-item">
                    <span>Total Taps Detected:</span>
                    <span>${assessment.metrics.tapCount}</span>
                </div>
                <div class="result-item">
                    <span>Signal Quality:</span>
                    <span>
                        ${assessment.metrics.signalQuality.samplingRate.toFixed(0)} FPS, 
                        ${assessment.metrics.signalQuality.framesProcessed} frames
                    </span>
                </div>
                <div class="result-item">
                    <span>Hand Tested:</span>
                    <span class="hand-indicator hand-${document.getElementById('handSelect').value}">
                        ${document.getElementById('handSelect').value.charAt(0).toUpperCase() + document.getElementById('handSelect').value.slice(1)} Hand
                    </span>
                </div>
            `;
            
            assessmentResults.innerHTML = html;
        }

        // Export results as JSON
        function exportResults() {
            if (tapEvents.length === 0) {
                alert('No data to export. Please complete a recording first.');
                return;
            }

            const assessment = calculateClinicalAssessment();
            const exportData = {
                testDate: new Date().toISOString(),
                hand: document.getElementById('handSelect').value,
                assessment: assessment,
                signalData: {
                    raw: distanceSignal,
                    smoothed: smoothedSignal,
                    velocity: velocitySignal,
                    time: timeSignal
                },
                tapEvents: tapEvents,
                processingParameters: {
                    smoothingWindow: SMOOTHING_WINDOW,
                    minPeakProminence: MIN_PEAK_PROMINENCE,
                    minPeakDistance: MIN_PEAK_DISTANCE
                }
            };

            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `pd_finger_tap_advanced_${new Date().toISOString().slice(0, 10)}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // Export data as CSV
        function exportCSV() {
            if (distanceSignal.length === 0) {
                alert('No data to export. Please complete a recording first.');
                return;
            }

            let csv = 'Time (s),Raw Distance,Smoothed Distance,Velocity,Tap Event\n';
            
            for (let i = 0; i < distanceSignal.length; i++) {
                const time = (timeSignal[i] / 1000).toFixed(3);
                const raw = distanceSignal[i].toFixed(2);
                const smooth = i < smoothedSignal.length ? smoothedSignal[i].toFixed(2) : '';
                const vel = i > 0 && i <= velocitySignal.length ? velocitySignal[i-1].toFixed(2) : '';
                const isTap = tapEvents.some(tap => tap.index === i) ? '1' : '0';
                
                csv += `${time},${raw},${smooth},${vel},${isTap}\n`;
            }

            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `pd_finger_tap_signal_${new Date().toISOString().slice(0, 10)}.csv`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // Reset analysis
        function resetAnalysis() {
            recording = false;
            distanceSignal = [];
            timeSignal = [];
            smoothedSignal = [];
            velocitySignal = [];
            tapEvents = [];
            frameCount = 0;
            
            // Clear countdown
            clearInterval(countdownInterval);
            document.getElementById('countdown').style.display = 'none';
            
            // Reset UI
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('status').textContent = 'Ready';
            document.getElementById('status').className = 'status-indicator status-ready';
            document.getElementById('resultsDiv').style.display = 'none';
            document.getElementById('algorithmStatus').textContent = 'Algorithm: Advanced peak detection with signal processing';
            
            // Reset metrics
            document.getElementById('tapCount').textContent = '0';
            document.getElementById('avgFrequency').innerHTML = '0.00<span class="metric-unit">Hz</span>';
            document.getElementById('avgAmplitude').innerHTML = '0.00<span class="metric-unit">%</span>';
            document.getElementById('ampDecrement').innerHTML = '0.00<span class="metric-unit">%</span>';
            document.getElementById('rhythmCV').innerHTML = '0.00<span class="metric-unit">%</span>';
            document.getElementById('hesitations').textContent = '0';
            
            // Clear charts
            distanceChart.data.labels = [];
            distanceChart.data.datasets.forEach(dataset => {
                dataset.data = [];
            });
            distanceChart.update();
            
            velocityChart.data.labels = [];
            velocityChart.data.datasets.forEach(dataset => {
                dataset.data = [];
            });
            velocityChart.update();
        }

        // Initialize everything when page loads
        window.onload = function() {
            initializeHands();
            initializeCamera();
            initializeCharts();
        };
    </script>
</body>
</html>