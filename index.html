<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PD Finger Tapping Webcam Analysis</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background-color: #0a0e27;
            color: #ffffff;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .main-timer {
            position: fixed;
            top: 20px;
            left: 20px;
            font-size: 28px;
            font-weight: bold;
            color: #ffffff;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            border-radius: 10px;
            z-index: 99;
            display: none;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .video-container {
            background: #1a1f3a;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
            position: relative;
        }

        .video-wrapper {
            position: relative;
            width: 100%;
            padding-bottom: 75%;
            background: #000;
            border-radius: 10px;
            overflow: hidden;
        }

        video, canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 10px;
        }
        video#inputVideo {
            transform: scaleX(-1);
        }

        canvas#outputCanvas {
            transform: scaleX(-1);
        }


        .controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background: #4a5568;
            cursor: not-allowed;
            box-shadow: none;
        }

        .metrics-panel {
            background: #1a1f3a;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
        }

        .metric-card {
            background: linear-gradient(135deg, #1e2139 0%, #2a2d4a 100%);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            border: 1px solid rgba(255,255,255,0.1);
            transition: all 0.3s ease;
        }

        .metric-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .metric-label {
            font-size: 0.9em;
            opacity: 0.8;
            margin-bottom: 5px;
        }

        .metric-value {
            font-size: 2em;
            font-weight: bold;
            color: #667eea;
        }

        .metric-unit {
            font-size: 0.8em;
            opacity: 0.6;
            margin-left: 5px;
        }

        .chart-container {
            grid-column: span 2;
            background: #1a1f3a;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
        }

        .chart-wrapper {
            position: relative;
            height: 300px;
            margin-bottom: 20px;
        }

        .status-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: bold;
            animation: pulse 2s infinite;
        }

        .status-ready {
            background: #48bb78;
            color: white;
        }

        .status-recording {
            background: #ed8936;
            color: white;
        }

        .status-analyzing {
            background: #667eea;
            color: white;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        .instructions {
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .instructions h3 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .instructions ol {
            margin-left: 20px;
            line-height: 1.8;
        }

        .results-summary {
            background: linear-gradient(135deg, #1e2139 0%, #2a2d4a 100%);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            border: 2px solid #667eea;
        }

        .results-summary h3 {
            color: #667eea;
            margin-bottom: 15px;
        }

        .result-item {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .result-item:last-child {
            border-bottom: none;
        }

        .severity-indicator {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 0.9em;
            font-weight: bold;
        }

        .severity-normal { background: #48bb78; }
        .severity-slight { background: #90cdf4; }
        .severity-mild { background: #f6e05e; }
        .severity-moderate { background: #ed8936; }
        .severity-severe { background: #e53e3e; }

        .countdown {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 120px;
            font-weight: bold;
            color: #667eea;
            text-shadow: 0 0 20px rgba(102, 126, 234, 0.8);
            z-index: 10;
            animation: countdownPulse 1s ease-in-out;
        }

        @keyframes countdownPulse {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 0.8; }
        }

        .hand-indicator {
            display: inline-block;
            padding: 6px 12px;
            border-radius: 8px;
            margin-left: 10px;
            font-size: 0.9em;
            font-weight: bold;
        }

        .hand-left { background: #4299e1; }
        .hand-right { background: #48bb78; }

        .export-section {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }

        .parameter-info {
            font-size: 0.85em;
            opacity: 0.7;
            margin-top: 5px;
            line-height: 1.4;
        }

        .algorithm-status {
            background: rgba(102, 126, 234, 0.2);
            border: 1px solid #667eea;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 15px;
            font-size: 0.9em;
        }

        .final-results {
            max-width: 1200px;
            margin: 0 auto;
            padding: 40px 20px;
        }

        .metric-explanation {
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .metric-explanation h4 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        .metric-explanation p {
            line-height: 1.6;
            margin-bottom: 10px;
        }

        .percentile-indicator {
            display: inline-block;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: bold;
            margin-left: 10px;
        }

        @media (max-width: 1024px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
            
            .chart-container {
                grid-column: span 1;
            }
        }
    </style>


    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore-compat.js"></script>

    <script>
    const firebaseConfig = {
        apiKey: "AIzaSyCIijYBeCcyl8Mt414nueAgIId8PfWaW5M",
        authDomain: "pdstudy-99397.firebaseapp.com",
        projectId: "pdstudy-99397",
        storageBucket: "pdstudy-99397.firebasestorage.app",
        messagingSenderId: "235927780090",
        appId: "1:235927780090:web:348a8c85c130371686a743",
        measurementId: "G-Y116J49LYT"
    };

    firebase.initializeApp(firebaseConfig);
    const db = firebase.firestore();
    </script>

</head>
<body>
    <div id="mainTimer" class="main-timer"></div>
    <div class="container">
        
        <div class="header">
            <h1>Fast Fingers</h1>
            <p>Measuring Motor Function</p>
        </div>

        <div class="instructions">
            <h3>Instructions</h3>
            <ol>
                <li>Position your hand clearly in view of the camera with palm facing down</li>
                <li>When ready, click "Start Recording"</li>
                <li>Follow the pace instructions for each trial</li>
                <li>Continue for 30 seconds (system will automatically stop)</li>
                <li>Keep your hand as steady as possible during the test</li>
            </ol>
        </div>

        <div class="main-grid">
            <div class="video-container">
                <div class="status-indicator status-ready" id="status">Ready</div>
                <div id="conditionInfo" style="margin-top: 15px; font-weight: bold; font-size: 1.1em; color: #f6e05e;">
                    Trial Info: —
                  </div>
                  <div id="conditionDescription" style="margin-bottom: 10px; font-size: 1em; color: #90cdf4;">
                    <!-- Pace instruction -->
                  </div>
                  
              
                <div class="video-wrapper">
                    <video id="inputVideo" autoplay playsinline></video>
                    <canvas id="outputCanvas"></canvas>
                    <div id="countdown" class="countdown" style="display: none;"></div>
                </div>
                <div class="controls">
                    <button id="startBtn" onclick="startRecording()">Start Recording</button>
                    <button id="stopBtn" onclick="stopRecording()" disabled>Stop Recording</button>
                    <button id="resetBtn" onclick="resetAnalysis()">Reset</button>
                    <select id="handSelect" style="padding: 10px; border-radius: 8px; background: #2a2d4a; color: white; border: 1px solid #667eea;">
                        <option value="right">Right Hand</option>
                        <option value="left">Left Hand</option>
                    </select>
                </div>
                <div class="algorithm-status" id="algorithmStatus">
                    Algorithm: Advanced peak detection with signal processing
                </div>
            </div>

            <div class="metrics-panel">
                <h2 style="margin-bottom: 20px; color: #667eea;">Real-time Metrics</h2>
                
                <div class="metric-card">
                    <div class="metric-label">Tap Count</div>
                    <div class="metric-value" id="tapCount">0</div>
                </div>

                <div class="metric-card">
                    <div class="metric-label">Current Frequency</div>
                    <div class="metric-value" id="avgFrequency">0.00<span class="metric-unit">Hz</span></div>
                </div>

                <div class="metric-card">
                    <div class="metric-label">Average Amplitude</div>
                    <div class="metric-value" id="avgAmplitude">0.00<span class="metric-unit">%</span></div>
                </div>

                <div class="metric-card">
                    <div class="metric-label">Amplitude Change</div>
                    <div class="metric-value" id="ampDecrement">0.00<span class="metric-unit">%</span></div>
                </div>

                <div class="metric-card">
                    <div class="metric-label">Rhythm Consistency</div>
                    <div class="metric-value" id="rhythmCV">0.00<span class="metric-unit">%</span></div>
                </div>

                <div class="metric-card">
                    <div class="metric-label">Pauses Detected</div>
                    <div class="metric-value" id="hesitations">0</div>
                </div>
            </div>
        </div>

        <div class="chart-container">
            <h2 style="margin-bottom: 20px; color: #667eea;">Movement Analysis</h2>
            
            <div class="chart-wrapper">
                <canvas id="distanceChart"></canvas>
            </div>

            <div class="chart-wrapper">
                <canvas id="velocityChart"></canvas>
            </div>

            <div id="resultsDiv" class="results-summary" style="display: none;">
                <h3>Trial Complete</h3>
                <div id="assessmentResults"></div>
            </div>
        </div>
    </div>

    <div id="finalResults" class="final-results" style="display: none;">
        <!-- Final comprehensive results will be inserted here -->
    </div>

    <script>
        // Global variables
        let camera, hands, canvasCtx, recording = false;
        let startTime, handDetected = false;
        let distanceChart, velocityChart;
        let recordingDuration = 30000; // 30 seconds
        let countdownInterval;
        let frameCount = 0;
        let mainTimerInterval;

        // Signal processing variables
        let distanceSignal = [];
        let timeSignal = [];
        let smoothedSignal = [];
        let velocitySignal = [];
        let peakIndices = [];
        let landmarkSeries = []; // stores full landmark history per frame
        let frameData = [];


        let tapEvents = [];
        let lastPeakTime = 0;
        
        // Parameters for signal processing
        const SAMPLE_RATE = 30; // Assumed 30 FPS
        

        // Trial management variables
        const trialConditions = [
            { hand: 'right', pace: 'comfortable' },
            { hand: 'right', pace: 'fast' },
            { hand: 'left',  pace: 'comfortable' },
            { hand: 'left',  pace: 'fast' },
        ];
        let trialIndex = 0;
        let repeatPerCondition = 2; // 2 repeats per condition = 8 trials total
        let currentRepetition = 0;
        let totalTrials = trialConditions.length * repeatPerCondition;
        let allTrialResults = []


        const SMOOTHING_WINDOW = 3; // Moving average window
        const MIN_PEAK_PROMINENCE = 0.3; // Minimum prominence for peak detection
        const MIN_PEAK_DISTANCE = 100; // Minimum ms between peaks
        const CLOSED_THRESHOLD_PCT      = 30;  // below this = fingers counted "closed"
        const OPEN_THRESHOLD_PCT        = 35;  // must reopen past this before next tap
        const VELOCITY_THRESHOLD_PERCENTILE = 70; // Percentile for adaptive threshold

        // Hand landmarks indices
        const WRIST = 0;
        const THUMB_TIP = 4;
        const INDEX_TIP = 8;
        const MIDDLE_MCP = 9;

        // Population norms (from literature approximations)
        const POPULATION_NORMS = {
            frequency: {
                healthy: { mean: 2.5, std: 0.5, ranges: [
                    { min: 3.0, max: 10, percentile: 95 },
                    { min: 2.5, max: 3.0, percentile: 75 },
                    { min: 2.0, max: 2.5, percentile: 50 },
                    { min: 1.5, max: 2.0, percentile: 25 },
                    { min: 0, max: 1.5, percentile: 5 }
                ]},
                pd: { mean: 1.8, std: 0.6 }
            },
            amplitude: {
                healthy: { mean: 45, std: 10, ranges: [
                    { min: 55, max: 100, percentile: 95 },
                    { min: 45, max: 55, percentile: 75 },
                    { min: 35, max: 45, percentile: 50 },
                    { min: 25, max: 35, percentile: 25 },
                    { min: 0, max: 25, percentile: 5 }
                ]}
            },
            rhythmCV: {
                healthy: { mean: 15, std: 5, ranges: [
                    { min: 0, max: 10, percentile: 95 },
                    { min: 10, max: 15, percentile: 75 },
                    { min: 15, max: 20, percentile: 50 },
                    { min: 20, max: 30, percentile: 25 },
                    { min: 30, max: 100, percentile: 5 }
                ]}
            },
            amplitudeDecrement: {
                healthy: { mean: 5, std: 5, ranges: [
                    { min: -10, max: 0, percentile: 95 },
                    { min: 0, max: 5, percentile: 75 },
                    { min: 5, max: 10, percentile: 50 },
                    { min: 10, max: 20, percentile: 25 },
                    { min: 20, max: 100, percentile: 5 }
                ]}
            }
        };
        
        // Initialize MediaPipe Hands
        function initializeHands() {
            hands = new Hands({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                }
            });

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.7
            });

            hands.onResults(onHandsResults);
        }

        // Initialize camera
        function initializeCamera() {
            const videoElement = document.getElementById('inputVideo');
            const canvasElement = document.getElementById('outputCanvas');
            canvasCtx = canvasElement.getContext('2d');

            camera = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 640,
                height: 480
            });
            camera.start();
        }

        // Moving average filter
        function movingAverage(data, windowSize) {
            const result = [];
            for (let i = 0; i < data.length; i++) {
                let start = Math.max(0, i - Math.floor(windowSize / 2));
                let end = Math.min(data.length, i + Math.floor(windowSize / 2) + 1);
                let sum = 0;
                for (let j = start; j < end; j++) {
                    sum += data[j];
                }
                result.push(sum / (end - start));
            }
            return result;
        }

        // Calculate numerical derivative
        function calculateDerivative(data, timeData) {
            const derivative = [];
            for (let i = 1; i < data.length; i++) {
                const dt = (timeData[i] - timeData[i-1]) / 1000; // Convert to seconds
                const dy = data[i] - data[i-1];
                derivative.push(dy / dt);
            }
            return derivative;
        }

        // Find peaks in signal using adaptive thresholding
        function findPeaks(signal, prominence = MIN_PEAK_PROMINENCE) {
            const peaks = [];
            
            // Calculate signal statistics for adaptive thresholding
            const mean = signal.reduce((a, b) => a + b, 0) / signal.length;
            const variance = signal.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / signal.length;
            const std = Math.sqrt(variance);
            
            // Adaptive threshold based on signal statistics
            const threshold = mean + prominence * std;
            
            // Find local maxima above threshold
            for (let i = 1; i < signal.length - 1; i++) {
                if (signal[i] > signal[i-1] && signal[i] > signal[i+1] && signal[i] > threshold) {
                    // Check minimum distance from last peak
                    if (peaks.length === 0 || (timeSignal[i] - timeSignal[peaks[peaks.length - 1]]) > MIN_PEAK_DISTANCE) {
                        peaks.push(i);
                    }
                }
            }
            
            return peaks;
        }

        function detectTapsFromVelocity(velocitySignal, distanceSignal) {
            const taps = [];
            let state = 'open'; // can be 'open', 'closed', or 'must_open'
            let lastTapTime = -Infinity;

            for (let i = 1; i < velocitySignal.length - 1; i++) {
                const t = timeSignal[i];
                const dist = distanceSignal[i];
                const velPrev = velocitySignal[i - 1];
                const velCurr = velocitySignal[i];

                switch (state) {
                    case 'open':
                        if (dist < 30 && velPrev < 0 && velCurr >= 0) {
                            // Fingers just closed — register a tap
                            if ((t - lastTapTime) > MIN_PEAK_DISTANCE) {
                                taps.push({
                                    index: i,
                                    time: t,
                                    amplitude: dist
                                });
                                lastTapTime = t;
                                state = 'must_open';
                            }
                        }
                        break;

                    case 'must_open':
                        if (dist > 35) {
                            state = 'open';
                        }
                        break;

                    default:
                        // fallback in case of unexpected state
                        state = 'open';
                }
            }

            return taps;
        }



        // Process hand detection results
        function onHandsResults(results) {
            const canvasElement = document.getElementById('outputCanvas');
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            
            // Draw the image
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                handDetected = true;
                const landmarks = results.multiHandLandmarks[0];

                const handedness = results.multiHandedness?.[0]?.label || "Unknown";
                if ((trialConditions[trialIndex % trialConditions.length].hand === "Right" && handedness !== "Right") ||
                    (trialConditions[trialIndex % trialConditions.length].hand === "Left" && handedness !== "Left")) {
                    return; // Skip frames with wrong hand
                }

                
                // Draw hand skeleton
                drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
                drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 1, radius: 3});

                // Process finger tap data if recording
                if (recording) {
                    processFingerTapAdvanced(landmarks, results.image.width, results.image.height);
                }

                // Highlight thumb and index fingertips
                const thumbTip = landmarks[THUMB_TIP];
                const indexTip = landmarks[INDEX_TIP];
                
                // Draw larger circles for thumb and index
                canvasCtx.fillStyle = '#667eea';
                canvasCtx.beginPath();
                canvasCtx.arc(thumbTip.x * canvasElement.width, thumbTip.y * canvasElement.height, 8, 0, 2 * Math.PI);
                canvasCtx.fill();
                
                canvasCtx.beginPath();
                canvasCtx.arc(indexTip.x * canvasElement.width, indexTip.y * canvasElement.height, 8, 0, 2 * Math.PI);
                canvasCtx.fill();

                // Draw line between thumb and index
                canvasCtx.strokeStyle = '#667eea';
                canvasCtx.lineWidth = 3;
                canvasCtx.beginPath();
                canvasCtx.moveTo(thumbTip.x * canvasElement.width, thumbTip.y * canvasElement.height);
                canvasCtx.lineTo(indexTip.x * canvasElement.width, indexTip.y * canvasElement.height);
                canvasCtx.stroke();

                // Draw detected peaks
                if (peakIndices.length > 0 && distanceSignal.length > 0) {
                    canvasCtx.fillStyle = '#e53e3e';
                    peakIndices.forEach(peakIdx => {
                        if (peakIdx < distanceSignal.length) {
                            // Visual indicator for detected taps
                            canvasCtx.beginPath();
                            canvasCtx.arc(
                                (thumbTip.x + indexTip.x) / 2 * canvasElement.width,
                                (thumbTip.y + indexTip.y) / 2 * canvasElement.height,
                                15, 0, 2 * Math.PI
                            );
                            canvasCtx.fill();
                        }
                    });
                }
            } else {
                handDetected = false;
            }

            canvasCtx.restore();
        }

        // MediaPipe hand connections
        const HAND_CONNECTIONS = [
            [0, 1], [1, 2], [2, 3], [3, 4],
            [0, 5], [5, 6], [6, 7], [7, 8],
            [5, 9], [9, 10], [10, 11], [11, 12],
            [9, 13], [13, 14], [14, 15], [15, 16],
            [13, 17], [17, 18], [18, 19], [19, 20],
            [0, 17]
        ];

        // Helper functions for drawing
        function drawConnectors(ctx, landmarks, connections, style) {
            ctx.strokeStyle = style.color;
            ctx.lineWidth = style.lineWidth;
            
            connections.forEach(([start, end]) => {
                const startLandmark = landmarks[start];
                const endLandmark = landmarks[end];
                
                ctx.beginPath();
                ctx.moveTo(startLandmark.x * ctx.canvas.width, startLandmark.y * ctx.canvas.height);
                ctx.lineTo(endLandmark.x * ctx.canvas.width, endLandmark.y * ctx.canvas.height);
                ctx.stroke();
            });
        }

        function drawLandmarks(ctx, landmarks, style) {
            ctx.fillStyle = style.color;
            
            landmarks.forEach(landmark => {
                ctx.beginPath();
                ctx.arc(landmark.x * ctx.canvas.width, landmark.y * ctx.canvas.height, 
                       style.radius, 0, 2 * Math.PI);
                ctx.fill();
            });
        }

        // Advanced finger tap processing with signal analysis
        function processFingerTapAdvanced(landmarks, imageWidth, imageHeight) {
            const currentTime = Date.now() - startTime;
            frameCount++;
            
            // Calculate 3D distance between thumb and index tips
            const thumbTip = landmarks[THUMB_TIP];
            const indexTip = landmarks[INDEX_TIP];
            const wrist = landmarks[WRIST];
            const middleMcp = landmarks[MIDDLE_MCP];
            
            // Calculate hand size for normalization
            const handSize = Math.sqrt(
                Math.pow((wrist.x - middleMcp.x) * imageWidth, 2) +
                Math.pow((wrist.y - middleMcp.y) * imageHeight, 2)
            );
            
            // Calculate normalized distance
            const distance = Math.sqrt(
                Math.pow((thumbTip.x - indexTip.x) * imageWidth, 2) +
                Math.pow((thumbTip.y - indexTip.y) * imageHeight, 2) +
                Math.pow((thumbTip.z - indexTip.z) * imageWidth * 0.5, 2) // Z depth with reduced weight
            );
            
            const normalizedDistance = (distance / handSize) * 100;
            
            // Add to signal arrays
            distanceSignal.push(normalizedDistance);
            timeSignal.push(currentTime);
            
            // Apply signal processing every few frames
            if (frameCount % 2 === 0 && distanceSignal.length > SMOOTHING_WINDOW) {
                // Smooth the signal
                smoothedSignal = movingAverage(distanceSignal, SMOOTHING_WINDOW);
                
                // Calculate velocity
                if (smoothedSignal.length > 1) {
                    velocitySignal = calculateDerivative(smoothedSignal, timeSignal);
                    
                    // Detect taps using multiple methods
                    detectTapsMultiMethod();
                }
                
                // Update real-time metrics
                updateRealtimeMetrics();
                
                // Update charts
                updateCharts();
            }

            frameData.push({
                timestamp: currentTime,
                handSize: handSize,
                normalizedDistance: normalizedDistance,
                thumbTip: { x: thumbTip.x, y: thumbTip.y, z: thumbTip.z },
                indexTip: { x: indexTip.x, y: indexTip.y, z: indexTip.z },
                wrist: { x: wrist.x, y: wrist.y, z: wrist.z },
                middleMcp: { x: middleMcp.x, y: middleMcp.y, z: middleMcp.z },
                rawLandmarks: landmarks.map(lm => ({ x: lm.x, y: lm.y, z: lm.z }))
            });

        }

        // Multi-method tap detection for robustness
        function detectTapsMultiMethod() {
            const rawEvents = [];            // collect all raw detections here
            const added     = new Set();     // prevent duplicate indices

            /* --------- 1. Velocity zero-crossings (most reliable) --------- */
            detectTapsFromVelocity(velocitySignal, smoothedSignal).forEach(ev => {
                if (!added.has(ev.index)) { rawEvents.push(ev); added.add(ev.index); }
            });

            /* --------- 2. Distance-based peaks at full closure --------- */
            const inverted = smoothedSignal.map(d => 100 - d);
            findPeaks(inverted, 0.5).forEach(idx => {
                if (smoothedSignal[idx] < CLOSED_THRESHOLD_PCT && !added.has(idx)) {
                    rawEvents.push({ index: idx, time: timeSignal[idx], amplitude: smoothedSignal[idx] });
                    added.add(idx);
                }
            });

            /* --------- ➊ sort by time, ➋ enforce reopen gate --------- */
            rawEvents.sort((a, b) => a.time - b.time);
            tapEvents = [];

            for (const ev of rawEvents) {
                if (tapEvents.length === 0) {          // always accept the first tap
                    tapEvents.push(ev);
                    continue;
                }

                const last = tapEvents[tapEvents.length - 1];

                // (a) honour MIN_PEAK_DISTANCE
                if (ev.time - last.time < MIN_PEAK_DISTANCE) continue;

                // (b) NEW — require signal to reopen past OPEN_THRESHOLD_PCT
                let reopened = false;
                for (let i = last.index + 1; i < ev.index; i++) {
                    if (smoothedSignal[i] > OPEN_THRESHOLD_PCT) { reopened = true; break; }
                }
                if (!reopened) continue;              // still the same closed dwell

                tapEvents.push(ev);
            }
        }

        // Find local minima in signal
        function findMinima(signal) {
            const minima = [];
            for (let i = 1; i < signal.length - 1; i++) {
                if (signal[i] < signal[i-1] && signal[i] < signal[i+1]) {
                    minima.push(i);
                }
            }
            return minima;
        }

        // Update real-time metrics display
        function updateRealtimeMetrics() {
            if (tapEvents.length === 0) return;
            
            // Tap count
            document.getElementById('tapCount').textContent = tapEvents.length;
            
            // Calculate inter-tap intervals and metrics
            if (tapEvents.length > 1) {
                const intervals = [];
                const amplitudes = [];
                
                for (let i = 1; i < tapEvents.length; i++) {
                    intervals.push(tapEvents[i].time - tapEvents[i-1].time);
                }
                
                // Get peak amplitudes (maximum distance between taps)
                for (let i = 0; i < tapEvents.length - 1; i++) {
                    const startIdx = tapEvents[i].index;
                    const endIdx = tapEvents[i+1].index;
                    let maxAmp = 0;
                    for (let j = startIdx; j < endIdx && j < smoothedSignal.length; j++) {
                        maxAmp = Math.max(maxAmp, smoothedSignal[j]);
                    }
                    amplitudes.push(maxAmp);
                }
                
                // Average frequency
                const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
                const frequency = 1000 / avgInterval;
                document.getElementById('avgFrequency').innerHTML = frequency.toFixed(2) + '<span class="metric-unit">Hz</span>';
                
                // Average amplitude
                if (amplitudes.length > 0) {
                    const avgAmplitude = amplitudes.reduce((a, b) => a + b, 0) / amplitudes.length;
                    document.getElementById('avgAmplitude').innerHTML = avgAmplitude.toFixed(1) + '<span class="metric-unit">%</span>';
                    
                    // Amplitude decrement
                    if (amplitudes.length >= 3) {
                        const firstThird = amplitudes.slice(0, Math.floor(amplitudes.length / 3));
                        const lastThird = amplitudes.slice(-Math.floor(amplitudes.length / 3));
                        const firstAvg = firstThird.reduce((a, b) => a + b, 0) / firstThird.length;
                        const lastAvg = lastThird.reduce((a, b) => a + b, 0) / lastThird.length;
                        const decrement = ((firstAvg - lastAvg) / firstAvg) * 100;
                        document.getElementById('ampDecrement').innerHTML = decrement.toFixed(1) + '<span class="metric-unit">%</span>';
                    }
                }
                
                // Rhythm variability
                const mean = intervals.reduce((a, b) => a + b, 0) / intervals.length;
                const variance = intervals.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / intervals.length;
                const std = Math.sqrt(variance);
                const cv = (std / mean) * 100;
                document.getElementById('rhythmCV').innerHTML = cv.toFixed(1) + '<span class="metric-unit">%</span>';
                
                // Hesitations
                const hesitations = intervals.filter(i => i > 500).length;
                document.getElementById('hesitations').textContent = hesitations;
            }
        }

        // Initialize charts
        function initializeCharts() {
            const chartOptions = {
                responsive: true,
                maintainAspectRatio: false,
                animation: {
                    duration: 0
                },
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Time (seconds)',
                            color: '#ffffff'
                        },
                        ticks: { color: '#ffffff' },
                        grid: { color: 'rgba(255, 255, 255, 0.1)' }
                    },
                    y: {
                        ticks: { color: '#ffffff' },
                        grid: { color: 'rgba(255, 255, 255, 0.1)' }
                    }
                },
                plugins: {
                    legend: {
                        labels: { color: '#ffffff' }
                    }
                }
            };

            // Distance chart
            const distCtx = document.getElementById('distanceChart').getContext('2d');
            distanceChart = new Chart(distCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Finger Distance',
                        data: [],
                        borderColor: '#667eea',
                        backgroundColor: 'rgba(102, 126, 234, 0.1)',
                        tension: 0.1,
                        pointRadius: 0
                    }, {
                        label: 'Smoothed',
                        data: [],
                        borderColor: '#48bb78',
                        backgroundColor: 'rgba(72, 187, 120, 0.1)',
                        tension: 0.1,
                        pointRadius: 0
                    }, {
                        label: 'Detected Taps',
                        data: [],
                        borderColor: '#e53e3e',
                        backgroundColor: '#e53e3e',
                        showLine: false,
                        pointRadius: 8,
                        pointStyle: 'triangle'
                    }]
                },
                options: {
                    ...chartOptions,
                    scales: {
                        ...chartOptions.scales,
                        y: {
                            ...chartOptions.scales.y,
                            title: {
                                display: true,
                                text: 'Distance (% hand size)',
                                color: '#ffffff'
                            }
                        }
                    }
                }
            });

            // Velocity chart
            const velCtx = document.getElementById('velocityChart').getContext('2d');
            velocityChart = new Chart(velCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Velocity',
                        data: [],
                        borderColor: '#ed8936',
                        backgroundColor: 'rgba(237, 137, 54, 0.1)',
                        tension: 0.1,
                        pointRadius: 0
                    }, {
                        label: 'Zero Line',
                        data: [],
                        borderColor: 'rgba(255, 255, 255, 0.3)',
                        borderDash: [5, 5],
                        pointRadius: 0
                    }]
                },
                options: {
                    ...chartOptions,
                    scales: {
                        ...chartOptions.scales,
                        y: {
                            ...chartOptions.scales.y,
                            title: {
                                display: true,
                                text: 'Velocity (% hand size/s)',
                                color: '#ffffff'
                            }
                        }
                    }
                }
            });
        }

        // Update charts with new data
        function updateCharts() {
            if (distanceSignal.length < 2) return;

            // Prepare time labels
            const timeLabels = timeSignal.map(t => (t / 1000).toFixed(2));
            
            // Update distance chart
            distanceChart.data.labels = timeLabels;
            distanceChart.data.datasets[0].data = distanceSignal;
            distanceChart.data.datasets[1].data = smoothedSignal;
            
            // Add tap markers
            const tapData = new Array(distanceSignal.length).fill(null);
            tapEvents.forEach(tap => {
                if (tap.index < tapData.length) {
                    tapData[tap.index] = smoothedSignal[tap.index];
                }
            });
            distanceChart.data.datasets[2].data = tapData;
            
            distanceChart.update('none');

            // Update velocity chart
            if (velocitySignal.length > 0) {
                const velTimeLabels = timeSignal.slice(1).map(t => (t / 1000).toFixed(2));
                velocityChart.data.labels = velTimeLabels;
                velocityChart.data.datasets[0].data = velocitySignal;
                velocityChart.data.datasets[1].data = new Array(velocitySignal.length).fill(0);
                velocityChart.update('none');
            }
        }

        // Start recording with countdown and condition tracking
        function startRecording() {
            if (!handDetected) {
                alert('Please position your hand in view of the camera before starting.');
                return;
            }

            // Check if all trials are done
            if (trialIndex >= totalTrials) {
                alert('All trials complete!');
                return;
            }

            // Update condition UI and hand selector
            updateConditionUI();

            // Reset all data
            distanceSignal = [];
            timeSignal = [];
            smoothedSignal = [];
            velocitySignal = [];
            tapEvents = [];
            frameCount = 0;
            frameData = []; // Reset before trial


            // Start countdown
            let countdown = 3;
            const countdownEl = document.getElementById('countdown');
            countdownEl.style.display = 'block';
            countdownEl.textContent = countdown;

            const startBtn = document.getElementById('startBtn');
            startBtn.disabled = true;
            startBtn.style.display = 'none';
            startBtn.textContent = 'Start'; // reset for future trials

            countdownInterval = setInterval(() => {
                countdown--;
                if (countdown > 0) {
                    countdownEl.textContent = countdown;
                    countdownEl.style.animation = 'none';
                    setTimeout(() => {
                        countdownEl.style.animation = 'countdownPulse 1s ease-in-out';
                    }, 10);
                } else {
                    clearInterval(countdownInterval);
                    countdownEl.style.display = 'none';
                    startActualRecording();
                }
            }, 1000);
        }

        // Start actual recording
        function startActualRecording() {
            recording = true;
            startTime = Date.now();
            distanceSignal = [];
            timeSignal = [];
            smoothedSignal = [];
            velocitySignal = [];
            tapEvents = [];
            frameCount = 0;

            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            document.getElementById('status').textContent = 'Recording';
            document.getElementById('status').className = 'status-indicator status-recording';
            document.getElementById('algorithmStatus').textContent = 'Algorithm: Recording signal data...';

            // Show main timer
            const mainTimerEl = document.getElementById('mainTimer');
            mainTimerEl.style.display = 'block';
            
            // Update timer every 100ms for smooth display
            mainTimerInterval = setInterval(() => {
                const elapsed = Date.now() - startTime;
                const remaining = Math.max(0, Math.ceil((recordingDuration - elapsed) / 1000));
                mainTimerEl.textContent = `Time Remaining: ${remaining}s`;
                
                // Show final countdown in the middle
                if (remaining <= 3 && remaining > 0) {
                    const countdownEl = document.getElementById('countdown');
                    countdownEl.style.display = 'block';
                    countdownEl.textContent = remaining;
                    countdownEl.style.animation = 'none';
                    setTimeout(() => {
                        countdownEl.style.animation = 'countdownPulse 1s ease-in-out';
                    }, 10);
                }
            }, 100);

            // Auto-stop after 30 seconds
            setTimeout(() => {
                if (recording) {
                    stopRecording();
                }
            }, recordingDuration);
        }

        function stopRecording() {
            recording = false;
            
            // Clear timer
            clearInterval(mainTimerInterval);
            document.getElementById('mainTimer').style.display = 'none';
            document.getElementById('countdown').style.display = 'none';
            
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('status').textContent = 'Analyzing';
            document.getElementById('status').className = 'status-indicator status-analyzing';
            document.getElementById('algorithmStatus').textContent = 'Algorithm: Processing signal and detecting peaks...';

            // Perform final analysis
            setTimeout(() => {
                // Calculate and store results
                const result = calculateClinicalAssessment();

                // Get subject name (Prolific ID) from sessionStorage
                const subjectName = sessionStorage.getItem('prolificID') || 'anonymous';

                // Prepare trial document name
                const trialDocName = `trial_${trialIndex + 1}`;

                // Save full trial data to Firestore
                db.collection("Trial Data")
                .doc(subjectName)
                .collection("Trials")
                .doc(trialDocName)
                .set({
                    summary: result,
                    allCapturedData: frameData
                })
                .then(() => {
                    console.log(`Trial ${trialDocName} saved for ${subjectName}`);
                })
                .catch((error) => {
                    console.error("Error saving trial data:", error);
                });

                allTrialResults.push({
                    condition: trialConditions[trialIndex % trialConditions.length],
                    repetition: Math.floor(trialIndex / trialConditions.length) + 1,
                    result: result
                });

                // Show brief trial complete message
                displayTrialComplete(result);

                trialIndex++;

                if (trialIndex < totalTrials) {
                    // Setup for next trial
                    document.getElementById('status').textContent = 'Ready for Next Trial';
                    document.getElementById('status').className = 'status-indicator status-ready';
                    document.getElementById('algorithmStatus').textContent = 'Click "Start Next Trial" to continue.';

                    // Setup "Start Next Trial" button
                    const startBtn = document.getElementById('startBtn');
                    startBtn.textContent = 'Start Next Trial';
                    startBtn.disabled = false;
                    startBtn.style.display = 'inline-block';
                    
                    // Update condition info for next trial
                    updateConditionUI();
                } else {
                    // All trials complete - show comprehensive results
                    analyzeAllTrials();
                }

            }, 500);
        }

        // Display brief trial complete message
        function displayTrialComplete(assessment) {
            const resultsDiv = document.getElementById('resultsDiv');
            const assessmentResults = document.getElementById('assessmentResults');
            
            resultsDiv.style.display = 'block';
            
            let html = `
                <div class="result-item">
                    <span>Taps Detected:</span>
                    <span>${assessment.metrics.tapCount}</span>
                </div>
                <div class="result-item">
                    <span>Average Frequency:</span>
                    <span>${assessment.metrics.avgFrequency.toFixed(2)} Hz</span>
                </div>
                <div class="result-item">
                    <span>Trial Duration:</span>
                    <span>${assessment.metrics.testDuration.toFixed(1)} seconds</span>
                </div>
                <div class="result-item">
                    <span>Trials Remaining:</span>
                    <span>${totalTrials - trialIndex}</span>
                </div>
            `;
            
            assessmentResults.innerHTML = html;
        }

        // Calculate clinical assessment based on MDS-UPDRS criteria
        function calculateClinicalAssessment() {
            const tapCount = tapEvents.length;
            const intervals = [];
            const amplitudes = [];
            
            // Calculate intervals and amplitudes
            for (let i = 1; i < tapEvents.length; i++) {
                intervals.push(tapEvents[i].time - tapEvents[i-1].time);
            }
            
            // Get peak amplitudes between taps
            for (let i = 0; i < tapEvents.length - 1; i++) {
                const startIdx = tapEvents[i].index;
                const endIdx = tapEvents[i+1].index;
                let maxAmp = 0;
                for (let j = startIdx; j < endIdx && j < smoothedSignal.length; j++) {
                    maxAmp = Math.max(maxAmp, smoothedSignal[j]);
                }
                amplitudes.push(maxAmp);
            }
            
            // Calculate metrics
            const avgFrequency = intervals.length > 0 ? 1000 / (intervals.reduce((a, b) => a + b, 0) / intervals.length) : 0;
            const avgAmplitude = amplitudes.length > 0 ? amplitudes.reduce((a, b) => a + b, 0) / amplitudes.length : 0;
            
            // Amplitude decrement
            let amplitudeDecrement = 0;
            if (amplitudes.length >= 3) {
                const firstThird = amplitudes.slice(0, Math.floor(amplitudes.length / 3));
                const lastThird = amplitudes.slice(-Math.floor(amplitudes.length / 3));
                const firstAvg = firstThird.reduce((a, b) => a + b, 0) / firstThird.length;
                const lastAvg = lastThird.reduce((a, b) => a + b, 0) / lastThird.length;
                amplitudeDecrement = ((firstAvg - lastAvg) / firstAvg) * 100;
            }
            
            // Rhythm variability
            let rhythmCV = 0;
            if (intervals.length > 0) {
                const mean = intervals.reduce((a, b) => a + b, 0) / intervals.length;
                const variance = intervals.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / intervals.length;
                rhythmCV = (Math.sqrt(variance) / mean) * 100;
            }
            
            // Hesitations and freezing
            const hesitations = intervals.filter(i => i > 500 && i < 1000).length;
            const freezing = intervals.filter(i => i >= 1000).length;
            
            // Speed-amplitude index (novel composite measure)
            const speedAmplitudeIndex = avgFrequency * (avgAmplitude / 100);
            
            // Clinical scoring based on MDS-UPDRS criteria
            let score = 0;
            let details = [];
            
            // Speed assessment
            if (avgFrequency < 1.5) {
                score = Math.max(score, 3);
                details.push("Moderate to severe slowing");
            } else if (avgFrequency < 2.0) {
                score = Math.max(score, 2);
                details.push("Mild slowing");
            } else if (avgFrequency < 2.5) {
                score = Math.max(score, 1);
                details.push("Slight slowing");
            }
            
            // Amplitude assessment
            if (avgAmplitude < 20) {
                score = Math.max(score, 2);
                details.push("Small amplitude movements");
            }
            
            // Amplitude decrement assessment
            if (amplitudeDecrement > 50) {
                score = Math.max(score, 3);
                details.push("Severe amplitude decrement");
            } else if (amplitudeDecrement > 30) {
                score = Math.max(score, 2);
                details.push("Amplitude decrements midway");
            } else if (amplitudeDecrement > 15) {
                score = Math.max(score, 1);
                details.push("Amplitude decrements near the end");
            }
            
            // Hesitations/interruptions
            if (freezing > 0) {
                score = Math.max(score, 3);
                details.push(`${freezing} freezing episode(s)`);
            } else if (hesitations >= 5) {
                score = Math.max(score, 3);
                details.push("More than 5 interruptions");
            } else if (hesitations >= 3) {
                score = Math.max(score, 2);
                details.push("3-5 interruptions");
            } else if (hesitations >= 1) {
                score = Math.max(score, 1);
                details.push("1-2 interruptions");
            }
            
            // Rhythm irregularity
            if (rhythmCV > 40) {
                score = Math.max(score, 2);
                details.push("Significant rhythm irregularity");
            } else if (rhythmCV > 25) {
                score = Math.max(score, 1);
                details.push("Mild rhythm irregularity");
            }
            
            return {
                score: score,
                details: details,
                metrics: {
                    tapCount: tapCount,
                    avgFrequency: avgFrequency,
                    avgAmplitude: avgAmplitude,
                    amplitudeDecrement: amplitudeDecrement,
                    rhythmCV: rhythmCV,
                    hesitations: hesitations,
                    freezing: freezing,
                    speedAmplitudeIndex: speedAmplitudeIndex,
                    testDuration: (timeSignal[timeSignal.length - 1] || 0) / 1000,
                    signalQuality: {
                        framesProcessed: frameCount,
                        samplingRate: frameCount / ((timeSignal[timeSignal.length - 1] || 1) / 1000),
                        detectionsConfidence: tapEvents.length / (frameCount / 30)
                    }
                }
            };
        }

        function updateConditionUI() {
            const trialNum = trialIndex + 1;
            const condition = trialConditions[trialIndex % trialConditions.length];
            const repetition = Math.floor(trialIndex / trialConditions.length) + 1;
            document.getElementById('conditionInfo').textContent =
                `Trial ${trialNum} of ${totalTrials} — ${condition.hand.toUpperCase()} hand, ${condition.pace} pace (Rep ${repetition})`;
            document.getElementById('handSelect').value = condition.hand;
            updateConditionDescription();
        }

        function updateConditionDescription() {
            const condition = trialConditions[trialIndex % trialConditions.length];
            let msg = "";

            if (condition.pace === 'comfortable') {
                msg = "Using just your thumb and index finger, tap them together repeatedly at a comfortable, steady pace—like a gentle pinching motion. Keep going for 30 seconds. Try to stay relaxed and consistent throughout.";
            } else if (condition.pace === 'fast') {
                msg = "Using just your thumb and index finger, tap them together as quickly as you can, like you're pinching repeatedly. Keep going for 30 seconds. Try to stay relaxed and consistent, but move as fast as possible.";
            }

            document.getElementById('conditionDescription').textContent = msg;
        }

        function getPercentile(value, metric) {
            const ranges = POPULATION_NORMS[metric]?.healthy?.ranges;
            if (!ranges) return null;
            
            for (let range of ranges) {
                if (value >= range.min && value <= range.max) {
                    return range.percentile;
                }
            }
            return 50; // default
        }

        function analyzeAllTrials() {
            // Hide the main interface
            document.querySelector('.container').style.display = 'none';
            document.getElementById('finalResults').style.display = 'block';
            
            // Separate by conditions
            let rightComfortable = allTrialResults.filter(t => t.condition.hand === 'right' && t.condition.pace === 'comfortable');
            let rightFast = allTrialResults.filter(t => t.condition.hand === 'right' && t.condition.pace === 'fast');
            let leftComfortable = allTrialResults.filter(t => t.condition.hand === 'left' && t.condition.pace === 'comfortable');
            let leftFast = allTrialResults.filter(t => t.condition.hand === 'left' && t.condition.pace === 'fast');
            
            // Calculate averages for each condition
            const calculateAverage = (trials, metric) => {
                const values = trials.map(t => t.result.metrics[metric]);
                return values.reduce((a, b) => a + b, 0) / values.length;
            };
            
            // Enhanced analysis with multiple factors
            let possiblePD = false;
            let pdScore = 0;
            let reasoning = [];
            
            // 1. Frequency analysis
            const rightFastFreq = calculateAverage(rightFast, 'avgFrequency');
            const leftFastFreq = calculateAverage(leftFast, 'avgFrequency');
            const avgFastFreq = (rightFastFreq + leftFastFreq) / 2;
            
            if (avgFastFreq < 1.5) {
                pdScore += 3;
                reasoning.push("Severe bradykinesia detected (frequency < 1.5 Hz)");
            } else if (avgFastFreq < 2.0) {
                pdScore += 2;
                reasoning.push("Moderate bradykinesia (frequency < 2.0 Hz)");
            } else if (avgFastFreq < 2.5) {
                pdScore += 1;
                reasoning.push("Mild bradykinesia (frequency < 2.5 Hz)");
            }
            
            // 2. Amplitude decrement
            const avgDecrement = (
                calculateAverage(rightFast, 'amplitudeDecrement') +
                calculateAverage(leftFast, 'amplitudeDecrement')
            ) / 2;
            
            if (avgDecrement > 30) {
                pdScore += 2;
                reasoning.push("Significant amplitude decrement (>30%)");
            } else if (avgDecrement > 15) {
                pdScore += 1;
                reasoning.push("Mild amplitude decrement (>15%)");
            }
            
            // 3. Rhythm variability
            const avgRhythmCV = (
                calculateAverage(rightFast, 'rhythmCV') +
                calculateAverage(leftFast, 'rhythmCV')
            ) / 2;
            
            if (avgRhythmCV > 30) {
                pdScore += 2;
                reasoning.push("High rhythm variability (CV > 30%)");
            } else if (avgRhythmCV > 20) {
                pdScore += 1;
                reasoning.push("Moderate rhythm variability (CV > 20%)");
            }
            
            // 4. Speed-amplitude index
            const avgSpeedAmpIndex = (
                calculateAverage(rightFast, 'speedAmplitudeIndex') +
                calculateAverage(leftFast, 'speedAmplitudeIndex')
            ) / 2;
            
            if (avgSpeedAmpIndex < 1.0) {
                pdScore += 2;
                reasoning.push("Low speed-amplitude index (<1.0)");
            }
            
            // 5. Asymmetry analysis
            const asymmetry = Math.abs(rightFastFreq - leftFastFreq) / Math.max(rightFastFreq, leftFastFreq) * 100;
            if (asymmetry > 20) {
                pdScore += 1;
                reasoning.push(`Significant hand asymmetry (${asymmetry.toFixed(0)}%)`);
            }
            
            // Determine PD likelihood
            if (pdScore >= 5) {
                possiblePD = true;
                reasoning.unshift("Multiple motor abnormalities detected consistent with parkinsonian features");
            } else if (pdScore >= 3) {
                possiblePD = true;
                reasoning.unshift("Some motor abnormalities detected that may warrant further evaluation");
            } else {
                reasoning.unshift("Motor function within normal limits");
            }
            
            // Create comprehensive report
            let html = `
                <div class="header" style="margin-bottom: 40px;">
                    <h1>Your Motor Function Analysis Results</h1>
                    <p>Comprehensive assessment of your finger tapping performance</p>
                </div>
                
                <div class="results-summary" style="margin-bottom: 40px;">
                    <h3>Overall Assessment</h3>
                    <div class="result-item">
                        <span>Clinical Impression:</span>
                        <span class="severity-indicator ${possiblePD ? 'severity-moderate' : 'severity-normal'}">
                            ${possiblePD ? 'Potential Motor Impairment Detected' : 'Normal Motor Function'}
                        </span>
                    </div>
                    <div class="result-item">
                        <span>Key Findings:</span>
                        <span>${reasoning.join('. ')}</span>
                    </div>
                </div>
                
                <div class="metric-explanation">
                    <h4>Understanding Your Results</h4>
                    <p>Your finger tapping test measured several important aspects of motor control. Here's what each metric means for your brain health:</p>
                </div>
            `;
            
            // Add detailed metric explanations with percentiles
            const metrics = [
                {
                    name: 'Tapping Frequency',
                    value: avgFastFreq,
                    unit: 'Hz',
                    explanation: 'How fast you can tap your fingers. This measures the speed of your motor neurons and muscle control. Normal adults tap at 2-3 Hz during fast-paced trials.',
                    percentile: getPercentile(avgFastFreq, 'frequency')
                },
                {
                    name: 'Movement Amplitude',
                    value: calculateAverage([...rightFast, ...leftFast], 'avgAmplitude'),
                    unit: '%',
                    explanation: 'How wide you open your fingers between taps. This reflects the range and control of your movements. Reduced amplitude can indicate muscle weakness or motor planning issues.',
                    percentile: getPercentile(calculateAverage([...rightFast, ...leftFast], 'avgAmplitude'), 'amplitude')
                },
                {
                    name: 'Amplitude Decrement',
                    value: avgDecrement,
                    unit: '%',
                    explanation: 'Whether your taps get smaller over time. This measures motor fatigue and sustainability. Healthy individuals show minimal decrement (<10%).',
                    percentile: getPercentile(avgDecrement, 'amplitudeDecrement')
                },
                {
                    name: 'Rhythm Consistency',
                    value: avgRhythmCV,
                    unit: '% CV',
                    explanation: 'How regular your tapping rhythm is. Lower values mean more consistent timing. This reflects the precision of your brain\'s internal timing mechanisms.',
                    percentile: getPercentile(avgRhythmCV, 'rhythmCV')
                },
                {
                    name: 'Hand Asymmetry',
                    value: asymmetry,
                    unit: '%',
                    explanation: 'The difference in performance between your hands. Most people show <10% difference. Higher asymmetry can indicate unilateral motor issues.',
                    percentile: asymmetry < 10 ? 95 : asymmetry < 20 ? 50 : 25
                }
            ];
            
            metrics.forEach(metric => {
                html += `
                    <div class="metric-explanation">
                        <h4>${metric.name}: ${metric.value.toFixed(1)} ${metric.unit}
                            <span class="percentile-indicator">Top ${metric.percentile}%</span>
                        </h4>
                        <p>${metric.explanation}</p>
                        <p style="color: #667eea;">Your performance is better than ${100 - metric.percentile}% of healthy adults.</p>
                    </div>
                `;
            });
            
            // Add condition-specific results
            html += `
                <div class="results-summary" style="margin-top: 40px;">
                    <h3>Detailed Results by Condition</h3>
                    <table style="width: 100%; color: white; border-collapse: collapse;">
                        <thead>
                            <tr style="border-bottom: 2px solid #667eea;">
                                <th style="padding: 10px; text-align: left;">Condition</th>
                                <th style="padding: 10px;">Avg Frequency (Hz)</th>
                                <th style="padding: 10px;">Avg Amplitude (%)</th>
                                <th style="padding: 10px;">Rhythm CV (%)</th>
                                <th style="padding: 10px;">Tap Count</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            const conditions = [
                { name: 'Right Hand - Comfortable', data: rightComfortable },
                { name: 'Right Hand - Fast', data: rightFast },
                { name: 'Left Hand - Comfortable', data: leftComfortable },
                { name: 'Left Hand - Fast', data: leftFast }
            ];
            
            conditions.forEach(cond => {
                const freq = calculateAverage(cond.data, 'avgFrequency');
                const amp = calculateAverage(cond.data, 'avgAmplitude');
                const cv = calculateAverage(cond.data, 'rhythmCV');
                const taps = cond.data.map(t => t.result.metrics.tapCount).reduce((a,b) => a+b, 0) / cond.data.length;
                
                html += `
                    <tr style="border-bottom: 1px solid rgba(255,255,255,0.1);">
                        <td style="padding: 10px;">${cond.name}</td>
                        <td style="padding: 10px; text-align: center;">${freq.toFixed(2)}</td>
                        <td style="padding: 10px; text-align: center;">${amp.toFixed(1)}</td>
                        <td style="padding: 10px; text-align: center;">${cv.toFixed(1)}</td>
                        <td style="padding: 10px; text-align: center;">${taps.toFixed(0)}</td>
                    </tr>
                `;
            });
            
            html += `
                        </tbody>
                    </table>
                </div>
                
                <div class="metric-explanation" style="margin-top: 40px;">
                    <h4>What These Results Mean</h4>
                    <p>The finger tapping test is a sensitive measure of motor control that can detect subtle changes in brain function. It evaluates:</p>
                    <ul style="margin-left: 20px; line-height: 1.8;">
                        <li><strong>Basal ganglia function:</strong> Controls movement initiation and speed</li>
                        <li><strong>Motor cortex integrity:</strong> Plans and executes voluntary movements</li>
                        <li><strong>Cerebellar coordination:</strong> Maintains rhythm and precision</li>
                        <li><strong>Neuromuscular efficiency:</strong> How well your brain communicates with muscles</li>
                    </ul>
                    ${possiblePD ? 
                        '<p style="margin-top: 20px; padding: 15px; background: rgba(237, 137, 54, 0.2); border-radius: 10px; border: 1px solid #ed8936;">⚠️ <strong>Important:</strong> Your results suggest some motor function differences that may benefit from medical evaluation. This test is a screening tool, not a diagnosis. Please consult with a healthcare provider for comprehensive assessment.</p>' :
                        '<p style="margin-top: 20px; padding: 15px; background: rgba(72, 187, 120, 0.2); border-radius: 10px; border: 1px solid #48bb78;">✓ Your motor function appears to be within normal limits. Regular exercise and staying active can help maintain healthy motor control as you age.</p>'
                    }
                </div>
                
                <div class="export-section" style="margin-top: 40px; text-align: center;">
                    <button onclick="exportAllResults()" style="margin-right: 10px;">Export Full Report (JSON)</button>
                    <button onclick="printResults()">Print Results</button>
                    <button onclick="location.reload()" style="margin-left: 10px;">Start New Test</button>
                </div>
            `;
            
            document.getElementById('finalResults').innerHTML = html;

            const participantID = sessionStorage.getItem('prolificID') || 'anonymous';

            // Initialize summary trackers
            let totalFreq = 0, totalAmp = 0, totalCV = 0, totalDec = 0;
            let rightHand = [], leftHand = [];
            let conditionBreakdown = {};

            allTrialResults.forEach((trial, index) => {
            const trialNum = `Trial ${index + 1}`;
            const metrics = trial.result.metrics;

            // Save individual trial under participant document
            db.collection("Results")
                .doc(participantID)
                .collection("Trials")
                .doc(trialNum)
                .set({
                condition: trial.condition,
                repetition: trial.repetition,
                ...metrics,
                score: trial.result.score,
                details: trial.result.details,
                timestamp: new Date().toISOString()
                });

            // Aggregate for summary
            totalFreq += metrics.avgFrequency;
            totalAmp += metrics.avgAmplitude;
            totalCV += metrics.rhythmCV;
            totalDec += metrics.amplitudeDecrement;

            if (trial.condition.hand === "right") rightHand.push(metrics.avgAmplitude);
            if (trial.condition.hand === "left") leftHand.push(metrics.avgAmplitude);

            const condKey = `${trial.condition.hand} - ${trial.condition.pace}`;
            conditionBreakdown[condKey] = {
                avgFrequency: metrics.avgFrequency,
                avgAmplitude: metrics.avgAmplitude,
                rhythmCV: metrics.rhythmCV,
                tapCount: metrics.tapEvents?.length || 0
            };
            });

            // Now calculate and store Final Prognosis
            const avgFreq = totalFreq / 8;
            const avgAmp = totalAmp / 8;
            const avgCV = totalCV / 8;
            const avgDec = totalDec / 8;

            const mean = arr => arr.reduce((a, b) => a + b, 0) / arr.length;
            const rightAvg = mean(rightHand);
            const leftAvg = mean(leftHand);
            const finalAsymmetry = Math.abs(rightAvg - leftAvg) / Math.max(rightAvg, leftAvg) * 100;

            db.collection("Results")
            .doc(participantID)
            .collection("Summary")
            .doc("Final Prognosis")
            .set({
                tappingFrequency: avgFreq,
                movementAmplitude: avgAmp,
                amplitudeDecrement: avgDec,
                rhythmConsistency: avgCV,
                handAsymmetry: finalAsymmetry,
                conditionBreakdown: conditionBreakdown,
                generatedAt: new Date().toISOString()
            });


        }

        // Export all results
        function exportAllResults() {
            const exportData = {
                testDate: new Date().toISOString(),
                summary: {
                    totalTrials: allTrialResults.length,
                    conditions: trialConditions,
                    overallAssessment: document.querySelector('.severity-indicator').textContent
                },
                detailedResults: allTrialResults,
                populationComparisons: POPULATION_NORMS,
                processingParameters: {
                    smoothingWindow: SMOOTHING_WINDOW,
                    minPeakProminence: MIN_PEAK_PROMINENCE,
                    minPeakDistance: MIN_PEAK_DISTANCE
                }
            };

            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `motor_function_analysis_${new Date().toISOString().slice(0, 10)}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // Print results
        function printResults() {
            window.print();
        }

        // Export results as JSON
        function exportResults() {
            if (tapEvents.length === 0) {
                alert('No data to export. Please complete a recording first.');
                return;
            }

            const assessment = calculateClinicalAssessment();
            const exportData = {
                testDate: new Date().toISOString(),
                hand: document.getElementById('handSelect').value,
                assessment: assessment,
                signalData: {
                    raw: distanceSignal,
                    smoothed: smoothedSignal,
                    velocity: velocitySignal,
                    time: timeSignal
                },
                tapEvents: tapEvents,
                processingParameters: {
                    smoothingWindow: SMOOTHING_WINDOW,
                    minPeakProminence: MIN_PEAK_PROMINENCE,
                    minPeakDistance: MIN_PEAK_DISTANCE
                }
            };

            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `pd_finger_tap_advanced_${new Date().toISOString().slice(0, 10)}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // Export data as CSV
        function exportCSV() {
            if (distanceSignal.length === 0) {
                alert('No data to export. Please complete a recording first.');
                return;
            }

            let csv = 'Time (s),Raw Distance,Smoothed Distance,Velocity,Tap Event\n';
            
            for (let i = 0; i < distanceSignal.length; i++) {
                const time = (timeSignal[i] / 1000).toFixed(3);
                const raw = distanceSignal[i].toFixed(2);
                const smooth = i < smoothedSignal.length ? smoothedSignal[i].toFixed(2) : '';
                const vel = i > 0 && i <= velocitySignal.length ? velocitySignal[i-1].toFixed(2) : '';
                const isTap = tapEvents.some(tap => tap.index === i) ? '1' : '0';
                
                csv += `${time},${raw},${smooth},${vel},${isTap}\n`;
            }

            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `pd_finger_tap_signal_${new Date().toISOString().slice(0, 10)}.csv`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // Reset analysis
        function resetAnalysis() {
            recording = false;
            distanceSignal = [];
            timeSignal = [];
            smoothedSignal = [];
            velocitySignal = [];
            tapEvents = [];
            frameCount = 0;
            trialIndex = 0;
            allTrialResults = [];
            
            // Clear countdown and timer
            clearInterval(countdownInterval);
            clearInterval(mainTimerInterval);
            document.getElementById('countdown').style.display = 'none';
            document.getElementById('mainTimer').style.display = 'none';
            
            // Reset UI
            document.getElementById('startBtn').disabled = false;
            document.getElementById('startBtn').textContent = 'Start Recording';
            document.getElementById('startBtn').style.display = 'inline-block';
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('status').textContent = 'Ready';
            document.getElementById('status').className = 'status-indicator status-ready';
            document.getElementById('resultsDiv').style.display = 'none';
            document.getElementById('algorithmStatus').textContent = 'Algorithm: Advanced peak detection with signal processing';
            
            // Reset metrics
            document.getElementById('tapCount').textContent = '0';
            document.getElementById('avgFrequency').innerHTML = '0.00<span class="metric-unit">Hz</span>';
            document.getElementById('avgAmplitude').innerHTML = '0.00<span class="metric-unit">%</span>';
            document.getElementById('ampDecrement').innerHTML = '0.00<span class="metric-unit">%</span>';
            document.getElementById('rhythmCV').innerHTML = '0.00<span class="metric-unit">%</span>';
            document.getElementById('hesitations').textContent = '0';
            
            // Clear charts
            distanceChart.data.labels = [];
            distanceChart.data.datasets.forEach(dataset => {
                dataset.data = [];
            });
            distanceChart.update();
            
            velocityChart.data.labels = [];
            velocityChart.data.datasets.forEach(dataset => {
                dataset.data = [];
            });
            velocityChart.update();
            
            // Show main interface again if final results were shown
            document.querySelector('.container').style.display = 'block';
            document.getElementById('finalResults').style.display = 'none';
            
            // Reset condition UI
            updateConditionUI();
        }

        function showInfoForm() {
                document.getElementById('container-consent').style.display = 'none';
                document.getElementById('container-info').style.display = 'block';
            }

            function startExperiment() {
                // Optionally validate form fields
                const pid = document.getElementById('prolificID').value;
                const age = document.getElementById('age').value;

                if (!pid || !age) {
                    alert('Please fill in all required fields.');
                    return;
                }

                document.getElementById('consent-section').style.display = 'none';
                document.querySelector('.container').style.display = 'block';
            }


        window.onload = function() {
            initializeHands();
            initializeCamera();
            initializeCharts();
            updateConditionUI();
        };

    </script>
</body>
</html>