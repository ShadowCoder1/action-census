<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Parkinsense Assessment</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100;200;300;400;500;600;700;800;900&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            background-color: #fafafa;
            color: #1a1a1a;
            line-height: 1.6;
            height: 100vh;
            overflow: hidden;
            position: relative;
            font-size: 1.25rem;
        }
        
        body.results-page {
            overflow: auto;
            height: auto;
            min-height: 100vh;
        }
        /* Subtle geometric background pattern */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: 
                radial-gradient(circle at 20% 80%, rgba(59, 130, 246, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(34, 197, 94, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(147, 51, 234, 0.02) 0%, transparent 50%);
            pointer-events: none;
            z-index: 0;
        }

h1, h2, h3, h4, h5, h6 {
    font-size: 2.8rem; /* Makes headings larger */
    margin-bottom: 1.5rem;
}

p, li, label, input, button, textarea {
    font-size: 1.6rem; /* Makes all text elements larger */
    line-height: 1.8; /* Increases line spacing for better readability */
}

button, input[type="submit"], .btn {
    font-size: 1.75rem; /* Makes buttons even larger */
    padding: 1.25rem 2.5rem; /* Increases button padding */
}

@media (max-width: 480px) {
    body {
        font-size: 1rem;
    }
    
    h1, h2, h3, h4, h5, h6 {
        font-size: 1.8rem;
    }
    
    p, li, label, input, button, textarea {
        font-size: 1rem;
    }
    
    .timer-display {
        font-size: 2rem !important;
    }
    
    .taps-display {
        font-size: 2.5rem !important;
    }
    
    .hand-instruction {
        font-size: 1.2rem !important;
    }
}

        /* Floating geometric shapes */
        .geometric-shape {
            position: fixed;
            pointer-events: none;
            opacity: 0.03;
            z-index: 0;
        }

        .shape-1 {
            width: 400px;
            height: 400px;
            background: linear-gradient(45deg, #3b82f6, #8b5cf6);
            border-radius: 30% 70% 70% 30% / 30% 30% 70% 70%;
            top: -200px;
            right: -200px;
            animation: float1 20s ease-in-out infinite;
        }

        .shape-2 {
            width: 300px;
            height: 300px;
            background: linear-gradient(135deg, #22c55e, #10b981);
            border-radius: 50%;
            bottom: -150px;
            left: -150px;
            animation: float2 25s ease-in-out infinite;
        }

        @keyframes float1 {
            0%, 100% { transform: translate(0, 0) rotate(0deg); }
            50% { transform: translate(-30px, 30px) rotate(180deg); }
        }

        @keyframes float2 {
            0%, 100% { transform: translate(0, 0) scale(1); }
            50% { transform: translate(30px, -30px) scale(1.1); }
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @media (min-width: 769px) {
            #mobile-loading-overlay {
                display: none !important;
            }
        }

        /* Main layout container */
        .main-container {
            display: flex;
            height: 100vh;
            width: 100vw;
            position: relative;
            z-index: 2;
        }

        /* Left panel - Minimal, clean instructions */
        .left-panel {
            width: 320px;
            display: flex;
            flex-direction: column;
            padding: 2.5rem 2rem;
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(20px);
            border-right: 1px solid rgba(0, 0, 0, 0.05);
            transition: all 0.3s ease;
            z-index: 10;
        }

        /* Top section with timer and taps */
        .metrics-section {
            margin-bottom: 3rem;
        }

        /* Timer display - Clean and prominent */
        .timer-display {
            font-size: 5.6rem;
            font-weight: 200;
            color: #1a1a1a;
            margin-bottom: 0.5rem;
            letter-spacing: -0.02em;
            line-height: 1;
        }

        /* Taps counter - Large and clear */
        .taps-counter {
            display: flex;
            align-items: baseline;
            gap: 1rem;
            margin-bottom: 3rem;
        }

        .taps-display {
            font-size: 7rem;
            font-weight: 100;
            color: #1a1a1a;
            letter-spacing: -0.03em;
            line-height: 1;
        }

        .taps-subtitle {
            font-size: 1.3rem;
            font-weight: 400;
            color: #666666;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }


        .trial-info {
            margin-bottom: 2rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid rgba(0, 0, 0, 0.08);
        }

        .trial-number {
            font-size: 1.1rem;
            color: #999999;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 0.75rem;
        }
        
        .hand-instruction {
            font-size: 2.8rem;
            color: #1a1a1a;
            font-weight: 300;
            letter-spacing: -0.02em;
        }

        .instructions {
            background: rgba(247, 247, 247, 0.5);
            border-radius: 12px;
            padding: 1.2rem;
            border: 1px solid rgba(0, 0, 0, 0.05);
            margin-bottom: 1rem;
        }

        .instructions h3 {
            font-size: 1.15rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: #666666;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .instruction-item {
            margin-bottom: 0.75rem;
            padding-left: 1.5rem;
            position: relative;
            font-size: 1.2rem;
            font-weight: 400;
            color: #1a1a1a;
            line-height: 1.5;
        }

        .instruction-item::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0.5rem;
            width: 4px;
            height: 4px;
            background: #22c55e;
            border-radius: 50%;
        }

        /* Right panel - Video focused */
        .right-panel {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #000;
            position: relative;
            overflow: hidden;
        }

        /* Video container - Full screen */
        .video-container {
            position: relative;
            width: 100%;
            height: 100%;
            background: #000;
        }

        video, canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        video#inputVideo {
            transform: scaleX(-1);
        }

        canvas#outputCanvas {
            transform: scaleX(-1);
        }

        /* Hand positioning guide */
        .hand-guide-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 100;
        }
        
        .position-status {
            font-size: 1.5rem;
            font-weight: 500;
            color: white;
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            padding: 1.25rem 2.5rem;
            border-radius: 50px;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            white-space: nowrap;
        }

        .position-status.ready {
            background: rgba(34, 197, 94, 0.9);  /* keep the green pill */
            white-space: normal !important;      /* allow wrapping */
            text-align: center;                  /* center text */
            line-height: 1.4;                    /* spacing for 2 lines */
            font-size: 1.2rem;                   /* slightly smaller so it fits */
            padding: 1rem 1.5rem;                /* balanced padding */
            max-width: 90%;                      /* prevent overflow on small screens */
            margin: 0 auto;                      /* center horizontally */
        }
        

        .position-status.warning {
            background: rgba(245, 158, 11, 0.9);
        }

        .position-status.error {
            background: rgba(239, 68, 68, 0.9);
        }

        /* Hand outline - Simplified */
/* Hand outline - Simplified */
        #hand-outline {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 420px;
            height: auto;
            opacity: 0.3;
            pointer-events: none;
            z-index: 80;
            transition: all 0.3s ease;
            filter: invert(1);
        }

        .hand-outline-ready {
            opacity: 0.6 !important;
            filter: invert(1) drop-shadow(0 0 20px #22c55e);
        }

        .hand-outline-not-ready {
            opacity: 0.4 !important;
            filter: invert(1) drop-shadow(0 0 20px #ef4444);
        }

        /* Countdown - Clean and modern */
        .countdown {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 14rem;
            font-weight: 100;
            color: #ffffff;
            text-shadow: 0 0 40px rgba(59, 130, 246, 0.8);
            z-index: 200;
            animation: countdownPulse 1s ease-in-out;
        }

        @keyframes countdownPulse {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 0.9; }
        }

        /* Centered recording timer (replaces left-column timer) */
        .center-timer {
          position: absolute;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          font-size: 6.5rem;
          font-weight: 200;
          color: #ffffff;
          text-shadow: 0 0 40px rgba(59, 130, 246, 0.8);
          z-index: 210; /* above video and outline, below overlays if needed */
          letter-spacing: -0.02em;
          line-height: 1;
          display: none; /* shown only while recording */
        }
        
        @media (max-width: 768px) {
          .center-timer { font-size: 4.5rem; }
        }



        /* Trial overlay - Clean modal */
        .trial-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 3rem;
        }

        .trial-overlay-content {
            max-width: 600px;
            text-align: center;
        }

        .trial-overlay-title {
            font-size: 4.9rem;
            font-weight: 200;
            margin-bottom: 2rem;
            color: #1a1a1a;
            letter-spacing: -0.02em;
        }

        .trial-overlay-instruction {
            font-size: 2rem;
            color: #1a1a1a;
            margin: 2rem 0;
            font-weight: 400;
        }
        .trial-overlay-instruction strong {
            color: #3b82f6;
            font-weight: 600;
        }

        .trial-overlay-footer {
            font-size: 1.3rem;
            color: #666666;
            font-weight: 400;
            margin-top: 3rem;
            padding: 1.25rem 2.5rem;
            background: rgba(0, 0, 0, 0.05);
            border-radius: 50px;
            display: inline-block;
            transition: all 0.2s ease;
        }
        
        /* Mobile tap functionality */
        @media (max-width: 768px) {
            .trial-overlay-footer {
                cursor: pointer;
                background: rgba(59, 130, 246, 0.1);
                border: 2px solid rgba(59, 130, 246, 0.3);
                color: #3b82f6;
                font-weight: 500;
            }
            
            .trial-overlay-footer:active {
                background: rgba(59, 130, 246, 0.2);
                transform: scale(0.98);
            }
        }

        /* Feedback panel - Floating pill */
        .feedback-panel {
            position: absolute;
            bottom: 3rem;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(245, 158, 11, 0.9);
            padding: 1rem 2rem;
            border-radius: 50px;
            color: white;
            text-align: center;
            z-index: 100;
            display: none;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
        }

        .feedback-message {
            font-size: 1.3rem;
            font-weight: 500;
        }

        /* Final results - Clean report style */
        .final-results {
            max-width: 1200px;
            margin: 0 auto;
            padding: 4rem 2rem;
            position: relative;
            z-index: 2;
            background: #fafafa;
            min-height: 100vh;
        }

        .results-card {
            background: white;
            border-radius: 16px;
            padding: 3rem;
            margin-bottom: 2rem;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.04);
            border: 1px solid rgba(0, 0, 0, 0.05);
        }

        /* Responsive design */
        @media (max-width: 1024px) {
            .left-panel {
                width: 280px;
                padding: 2rem 1.25rem;
            }
            
            .timer-display {
                font-size: 5rem;
            }
            
            .taps-display {
                font-size: 6rem;
            }
            
            .hand-instruction {
                font-size: 2.2rem;
            }
        }
        @media (max-width: 768px) {
            .main-container {
                flex-direction: column !important;
                height: 100vh !important;
            }
            
            .left-panel {
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                width: 100%;
                height: auto;
                min-height: 120px;
                max-height: 150px;
                padding: 1rem;
                border-right: none !important;
                border-left: none !important;
                border-top: 1px solid rgba(0, 0, 0, 0.05);
                border-bottom: none;
                flex-shrink: 0;
                z-index: 100;
                background: rgba(255, 255, 255, 0.9);
                backdrop-filter: blur(20px);
            }
            
            .right-panel {
                flex: 1;
                height: 100vh;
                min-height: 0;
            }
            
            .video-container {
                height: 100%;
                position: relative;
            }
            
            video, canvas {
                height: 100% !important;
                width: 100% !important;
                object-fit: cover !important;
            }
            
            .metrics-section {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 0.75rem;
                gap: 1rem;
            }
            
            .timer-display {
                font-size: 2.5rem;
                line-height: 1;
            }
            
            .taps-counter {
                margin-bottom: 0;
                gap: 0.5rem;
            }
            
            .taps-display {
                font-size: 3rem;
                line-height: 1;
            }
            
            .taps-subtitle {
                font-size: 0.9rem;
            }
            
            .trial-info {
                margin-bottom: 0.5rem;
                padding-bottom: 0.5rem;
            }
            
            .trial-number {
                font-size: 0.8rem;
                margin-bottom: 0.25rem;
            }
            
            .hand-instruction {
                font-size: 1.4rem;
                line-height: 1.2;
            }
            
            .instructions {
                display: none;
            }
            
            .trial-overlay-title {
                font-size: 2.5rem;
            }
            
            .trial-overlay-instruction {
                font-size: 1.4rem;
            }
       }

        /* Layout adjustments - panel matches hand side to avoid Simon effect */
        .layout-right-hand .main-container {
            flex-direction: row-reverse; /* Panel on right, video on left */
        }
        
        .layout-right-hand .left-panel {
            border-left: 1px solid rgba(0, 0, 0, 0.05);
            border-right: none;
        }
        
        .layout-left-hand .main-container {
            flex-direction: row; /* Panel on left, video on right */
        }
        
        .layout-left-hand .left-panel {
            border-right: 1px solid rgba(0, 0, 0, 0.05);
            border-left: none;
        }

                /* Force mobile layout regardless of hand side */
        @media (max-width: 768px) {
            .layout-right-hand .main-container,
            .layout-left-hand .main-container {
                flex-direction: column !important;
            }
            
            .layout-right-hand .left-panel,
            .layout-left-hand .left-panel {
                border-left: none !important;
                border-right: none !important;
                border-bottom: 1px solid rgba(0, 0, 0, 0.05) !important;
            }
            
            .layout-left-hand #hand-outline,
            .layout-right-hand #hand-outline {
                left: 50% !important;
                transform: translate(-50%, -50%) !important;
            }
            
            .layout-left-hand .hand-guide-overlay,
            .layout-right-hand .hand-guide-overlay {
                left: 50% !important;
            }
        }
        /* Hand outline positioning based on hand */
        .layout-left-hand #hand-outline {
            left: 30% !important;
            transform: translate(-50%, -50%) scaleX(-1);
        }
        
        
        .layout-right-hand #hand-outline {
            left: 70% !important;
            transform: translate(-50%, -50%);
        }
        
        /* Hand guide positioning based on hand */
        .layout-left-hand .hand-guide-overlay {
            left: 29% !important;
        }
        
        .layout-right-hand .hand-guide-overlay {
            left: 72% !important;
        }

.likert-scale {
            display: flex;
            align-items: center;
            gap: 0.3rem;
            margin-bottom: 0.3rem;
        }

        .likert-option {
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
            padding: 0.2rem;
            flex: 1;
        }

        .likert-option input[type="radio"] {
            margin-bottom: 0.1rem;
            transform: scale(1.1);
            cursor: pointer;
        }

        .likert-option label {
            font-size: 0.75rem;
            color: #666666;
            text-align: center;
            cursor: pointer;
            line-height: 1.1;
        }

        @media (max-width: 768px) {
            .likert-scale {
                gap: 0.1rem;
            }
            
            .likert-option {
                padding: 0.1rem;
            }
            
            .likert-option label {
                font-size: 0.7rem;
            }
            
            /* Stack questions vertically on mobile */
            div[style*="grid-template-columns: 1fr 1fr"],
            div[style*="grid-template-columns: 1fr 1fr 1fr"] {
                grid-template-columns: 1fr !important;
            }
        }
        @media (max-width: 768px) {
            .hand-guide-overlay {
                top: 50% !important;
                left: 50% !important;
            }
                    /* FIXED: Ensure position status is visible and functional on mobile */
            .position-status {
                position: relative;
                z-index: 150;
                pointer-events: auto;
                display: block !important;
            }
            
            .position-status {
                font-size: 1rem;
                padding: 0.75rem 1.5rem;
                white-space: normal;
                max-width: 280px;
                line-height: 1.3;
            }
        
            /* Proportional outline on phones (roughly matches desktop visual scale) */
            #hand-outline {
                width: clamp(280px, 65vw, 420px) !important;


                top: 35% !important;
                left: 50% !important;
                /* No generic transform here; layout classes control mirroring */
            }
        
            /* Preserve correct mirroring by hand side even on mobile */

            .layout-left-hand #hand-outline {
                transform: translate(-40%, -50%) scaleX(-1) !important;
            }



            .layout-right-hand #hand-outline {
                transform: translate(-60%, -50%) !important;
            }


            
            .feedback-panel {
                bottom: 1rem;
                padding: 0.5rem 1rem;
            }
            
            .feedback-message {
                font-size: 1rem;
            }
            
            .countdown {
                font-size: 8rem;
            }
        }

                /* Mobile-specific questionnaire and results styling */
        @media (max-width: 768px) {
            #questionnaire-overlay {
                padding: 0 !important;
            }
            
            #questionnaire-overlay > div {
                width: 100vw !important;
                height: 100vh !important;
                max-width: none !important;
                max-height: none !important;
                border-radius: 0 !important;
                padding: 1rem !important;
                box-sizing: border-box;
                overflow-y: auto;
            }
        
            .mobile-question-group {
                background: rgba(0, 0, 0, 0.02);
                border-radius: 8px;
                padding: 1rem;
                margin-bottom: 1.5rem;
                border: 1px solid rgba(0, 0, 0, 0.05);
            }
        
            .mobile-likert-container {
                background: white;
                border-radius: 8px;
                padding: 0.75rem;
                border: 1px solid rgba(0, 0, 0, 0.1);
            }
        
            .mobile-likert-scale {
                display: flex;
                justify-content: space-between;
                align-items: center;
                gap: 0.1rem;
            }
        
            .mobile-likert-scale .likert-option {
                flex: 1;
                display: flex;
                flex-direction: column;
                align-items: center;
                padding: 0.25rem;
                cursor: pointer;
            }
        
            .mobile-likert-scale .likert-option input[type="radio"] {
                transform: scale(1.3);
                margin-bottom: 0.25rem;
            }
        
            .mobile-likert-scale .likert-option span {
                font-size: 0.8rem;
                color: #666;
                font-weight: 500;
            }
        
            .final-results {
                padding: 2rem 1rem !important;
                min-height: 100vh;
            }
        
            .final-results > div {
                padding: 2rem 1rem !important;
                text-align: center;
            }
        
            .final-results p {
                font-size: 1.4rem !important;
                line-height: 1.4 !important;
                margin-bottom: 2rem !important;
            }
        
            .final-results p strong {
                font-size: 1.6rem !important;
                color: #22c55e;
            }
        
            .final-results .mobile-button-container {
                display: flex;
                flex-direction: column;
                gap: 1rem;
                width: 100%;
            }
        
            .final-results button {
                width: 100% !important;
                padding: 1.25rem 2rem !important;
                font-size: 1.2rem !important;
                border-radius: 12px !important;
                margin: 0 !important;
            }
        
            .mobile-prolific-code {
                background: rgba(34, 197, 94, 0.1) !important;
                border: 2px solid #22c55e !important;
                border-radius: 12px !important;
                padding: 1.5rem !important;
                margin: 2rem 0 !important;
                text-align: center;
            }
        
            .mobile-prolific-code p:first-child {
                font-size: 1.2rem !important;
                margin-bottom: 0.75rem !important;
            }
        
            .mobile-prolific-code p:nth-child(2) {
                font-size: 2rem !important;
                font-weight: 700 !important;
                letter-spacing: 0.1em;
                color: #22c55e !important;
                font-family: 'Courier New', monospace !important;
                margin-bottom: 0.75rem !important;
            }
        
            .mobile-prolific-code p:last-child {
                font-size: 1rem !important;
                color: #666 !important;
                margin: 0 !important;
            }
        }
                
    </style>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore-compat.js"></script>

    <script>
    const firebaseConfig = {
        apiKey: "AIzaSyCIijYBeCcyl8Mt414nueAgIId8PfWaW5M",
        authDomain: "pdstudy-99397.firebaseapp.com",
        projectId: "pdstudy-99397",
        storageBucket: "pdstudy-99397.firebasestorage.app",
        messagingSenderId: "235927780090",
        appId: "1:235927780090:web:348a8c85c130371686a743",
        measurementId: "G-Y116J49LYT"
    };

    firebase.initializeApp(firebaseConfig);
    const db = firebase.firestore();

    let participantID = sessionStorage.getItem('prolificID');
    if (!participantID) {
        participantID = `anon_${Date.now()}`;
        sessionStorage.setItem('prolificID', participantID);
    }
    </script>
</head>
<body>

    <!-- Mobile Loading Overlay -->
    <div id="mobile-loading-overlay" style="display: none;">
        <div style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(255, 255, 255, 0.95); z-index: 99999; backdrop-filter: blur(10px);">
            <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; padding: 2rem;">
                <div style="width: 60px; height: 60px; margin: 0 auto 2rem; position: relative;">
                    <div class="loading-spinner" style="width: 100%; height: 100%; border: 3px solid rgba(59, 130, 246, 0.2); border-top: 3px solid #3b82f6; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                </div>
                <h3 style="font-size: 1.5rem; color: #1a1a1a; margin-bottom: 1rem; font-weight: 500;">Starting Camera</h3>
                <p id="loading-status" style="font-size: 1rem; color: #666666; margin-bottom: 1.5rem;">Initializing hand tracking...</p>
                <div style="width: 100%; max-width: 300px; height: 4px; background: rgba(59, 130, 246, 0.2); border-radius: 2px; margin: 0 auto; overflow: hidden;">
                    <div id="loading-progress" style="width: 0%; height: 100%; background: linear-gradient(90deg, #3b82f6, #8b5cf6); border-radius: 2px; transition: width 0.3s ease;"></div>
                </div>
                <p style="font-size: 0.9rem; color: #999999; margin-top: 1.5rem; max-width: 280px;">Make sure your camera permissions are enabled and you're in good lighting</p>
            </div>
        </div>
    </div>
    <!-- Subtle geometric shapes -->
    <div class="geometric-shape shape-1"></div>
    <div class="geometric-shape shape-2"></div>

    <!-- Trial instructions overlay -->
    <div id="trial-instructions-overlay" class="trial-overlay" style="display: none;">
        <div class="trial-overlay-content">
            <div id="trial-instructions-text" class="trial-overlay-title">
                <!-- Dynamically filled -->
            </div>
            <div class="trial-overlay-instruction">
               Tap your fingers to start—go as <strong style="color: #ef4444;">FAST</strong> as you can!
                 
            </div>
            <p class="trial-overlay-footer" id="begin-instruction">Press SPACEBAR to begin</p>
        </div>
    </div>
    <!-- Questionnaire overlay -->
<!-- Questionnaire overlay -->
    <div id="questionnaire-overlay" class="trial-overlay" style="display: none;">
        <div style="max-width: 1200px; width: 95%; max-height: 95vh; overflow-y: auto; background: white; border-radius: 20px; padding: 2rem; box-shadow: 0 10px 40px rgba(0,0,0,0.1);">
            <div style="text-align: center; margin-bottom: 2rem;">
                <h2 style="font-size: 2.4rem; font-weight: 300; color: #1a1a1a; margin-bottom: 0.5rem; letter-spacing: -0.02em;">Quick Questions</h2>
                <p style="font-size: 1.1rem; color: #666666; font-weight: 400;">Please answer these brief questions about your experience</p>
            </div>

            <form id="questionnaire-form" style="text-align: left;">
                <!-- Likert Scale Explanation -->
                <div style="background: rgba(59, 130, 246, 0.05); border-radius: 8px; padding: 1rem; margin-bottom: 1.5rem; border-left: 3px solid #3b82f6;">
                    <p style="font-size: 1rem; color: #1a1a1a; margin: 0;"><strong>Rating Scale:</strong> 1 = Very Low/Poor, 7 = Very High/Excellent</p>
                </div>

                <!-- Experience Questions Grid -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem; margin-bottom: 1.5rem;">
                    <div class="question-group">
                        <label style="font-size: 1.1rem; font-weight: 500; color: #1a1a1a; margin-bottom: 0.5rem; display: block;">Video game experience:</label>
                        <div class="likert-scale" id="videogame-scale"></div>
                    </div>

                    <div class="question-group">
                        <label style="font-size: 1.1rem; font-weight: 500; color: #1a1a1a; margin-bottom: 0.5rem; display: block;">Musical experience:</label>
                        <div class="likert-scale" id="musical-scale"></div>
                    </div>

                    <div class="question-group">
                        <label style="font-size: 1.1rem; font-weight: 500; color: #1a1a1a; margin-bottom: 0.5rem; display: block;">Sports experience:</label>
                        <div class="likert-scale" id="sports-scale"></div>
                    </div>

                    <div class="question-group">
                        <label style="font-size: 1.1rem; font-weight: 500; color: #1a1a1a; margin-bottom: 0.5rem; display: block;">Caffeine intake today:</label>
                        <div class="likert-scale" id="caffeine-scale"></div>
                    </div>
                </div>

                <!-- Mood and Performance Grid -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem; margin-bottom: 1.5rem;">
                    <div class="question-group">
                        <label style="font-size: 1.1rem; font-weight: 500; color: #1a1a1a; margin-bottom: 0.5rem; display: block;">Current mood:</label>
                        <div class="likert-scale" id="mood-scale"></div>
                    </div>

                    <div class="question-group">
                        <label style="font-size: 1.1rem; font-weight: 500; color: #1a1a1a; margin-bottom: 0.5rem; display: block;">Task motivation:</label>
                        <div class="likert-scale" id="motivated-scale"></div>
                    </div>

                    <div class="question-group">
                        <label style="font-size: 1.1rem; font-weight: 500; color: #1a1a1a; margin-bottom: 0.5rem; display: block;">Task distraction:</label>
                        <div class="likert-scale" id="distracted-scale"></div>
                    </div>

                    <div class="question-group">
                        <label style="font-size: 1.1rem; font-weight: 500; color: #1a1a1a; margin-bottom: 0.5rem; display: block;">Expected performance vs. others:</label>
                        <div class="likert-scale" id="performance-scale"></div>
                    </div>

                    <div class="question-group">
                        <label style="font-size: 1.1rem; font-weight: 500; color: #1a1a1a; margin-bottom: 0.5rem; display: block;">Persistence when tasks get frustrating:</label>
                        <div class="likert-scale" id="persistence-scale"></div>
                    </div>
                    
                    <div class="question-group">
                        <label style="font-size: 1.1rem; font-weight: 500; color: #1a1a1a; margin-bottom: 0.5rem; display: block;">Attention span in general:</label>
                        <div class="likert-scale" id="attention-scale"></div>
                    </div>
                    
                    <div class="question-group">
                        <label style="font-size: 1.1rem; font-weight: 500; color: #1a1a1a; margin-bottom: 0.5rem; display: block;">Enjoyment of competition:</label>
                        <div class="likert-scale" id="competition-scale"></div>
                    </div>
                </div>

                <!-- Neurological Question -->
                <div class="question-group" style="margin-bottom: 1.5rem; background: rgba(0,0,0,0.02); padding: 1rem; border-radius: 8px;">
                    <label style="font-size: 1.1rem; font-weight: 500; color: #1a1a1a; margin-bottom: 0.5rem; display: block;">Do you have any known neurological conditions?</label>
                    <div style="display: flex; gap: 2rem;">
                        <label style="display: flex; align-items: center; font-size: 1.1rem; cursor: pointer;">
                            <input type="radio" name="neurological" value="no" required style="margin-right: 0.5rem; transform: scale(1.2);">
                            No
                        </label>
                        <label style="display: flex; align-items: center; font-size: 1.1rem; cursor: pointer;">
                            <input type="radio" name="neurological" value="yes" style="margin-right: 0.5rem; transform: scale(1.2);">
                            Yes
                        </label>
                    </div>
                </div>

                                <!-- Hand Pain Question -->
                <div class="question-group" style="margin-bottom: 1.5rem; background: rgba(0,0,0,0.02); padding: 1rem; border-radius: 8px;">
                    <label style="font-size: 1.1rem; font-weight: 500; color: #1a1a1a; margin-bottom: 0.5rem; display: block;">Do you currently have hand-related pain that affects your performance on tasks like this?</label>
                    <div style="display: flex; gap: 2rem;">
                        <label style="display: flex; align-items: center; font-size: 1.1rem; cursor: pointer;">
                            <input type="radio" name="handPain" value="no" required style="margin-right: 0.5rem; transform: scale(1.2);">
                            No
                        </label>
                        <label style="display: flex; align-items: center; font-size: 1.1rem; cursor: pointer;">
                            <input type="radio" name="handPain" value="yes" style="margin-right: 0.5rem; transform: scale(1.2);">
                            Yes
                        </label>
                    </div>
                </div>

                <!-- Injury/Disease History Question -->
                <div class="question-group" style="margin-bottom: 1.5rem; background: rgba(0,0,0,0.02); padding: 1rem; border-radius: 8px;">
                    <label style="font-size: 1.1rem; font-weight: 500; color: #1a1a1a; margin-bottom: 0.5rem; display: block;">History of injury/disease affecting hand/arm movement:</label>
                    <div style="display: flex; gap: 2rem;">
                        <label style="display: flex; align-items: center; font-size: 1.1rem; cursor: pointer;">
                            <input type="radio" name="handInjuryHistory" value="no" required style="margin-right: 0.5rem; transform: scale(1.2);">
                            No
                        </label>
                        <label style="display: flex; align-items: center; font-size: 1.1rem; cursor: pointer;">
                            <input type="radio" name="handInjuryHistory" value="yes" style="margin-right: 0.5rem; transform: scale(1.2);">
                            Yes
                        </label>
                    </div>
                </div>

<!-- Demographics Questions -->
<div style="border-top: 1px solid rgba(0,0,0,0.1); padding-top: 1.5rem;">
    <div style="background: rgba(59, 130, 246, 0.05); border-radius: 8px; padding: 1rem; margin-bottom: 1.5rem; border-left: 3px solid #3b82f6;">
        <p style="font-size: 0.95rem; color: #1a1a1a; margin: 0;"><strong>Why we ask:</strong> Understanding participants' income levels and geographic location helps us examine how economic factors may influence physical ability. Your response helps ensure our findings reflect the experiences of people from diverse financial and geographical backgrounds.</p>
    </div>
    
    <div class="question-group" style="margin-bottom: 1.5rem;">
        <label style="font-size: 1.1rem; font-weight: 500; color: #1a1a1a; margin-bottom: 1rem; display: block;">What is your total annual household income before taxes? (Please select the range that best represents your income.)</label>
        <div style="display: flex; flex-direction: column; gap: 0.5rem;">
            <label style="display: flex; align-items: center; font-size: 1rem; cursor: pointer; padding: 0.3rem 0;">
                <input type="radio" name="income" value="less-than-20k" required style="margin-right: 0.75rem; transform: scale(1.2);">
                "Less than $20,000"
            </label>
            <label style="display: flex; align-items: center; font-size: 1rem; cursor: pointer; padding: 0.3rem 0;">
                <input type="radio" name="income" value="20k-39k" style="margin-right: 0.75rem; transform: scale(1.2);">
                "$20,000 - $39,999"
            </label>
            <label style="display: flex; align-items: center; font-size: 1rem; cursor: pointer; padding: 0.3rem 0;">
                <input type="radio" name="income" value="40k-59k" style="margin-right: 0.75rem; transform: scale(1.2);">
                "$40,000 - $59,999"
            </label>
            <label style="display: flex; align-items: center; font-size: 1rem; cursor: pointer; padding: 0.3rem 0;">
                <input type="radio" name="income" value="60k-79k" style="margin-right: 0.75rem; transform: scale(1.2);">
                "$60,000 - $79,999"
            </label>
            <label style="display: flex; align-items: center; font-size: 1rem; cursor: pointer; padding: 0.3rem 0;">
                <input type="radio" name="income" value="80k-99k" style="margin-right: 0.75rem; transform: scale(1.2);">
                "$80,000 - $99,999"
            </label>
            <label style="display: flex; align-items: center; font-size: 1rem; cursor: pointer; padding: 0.3rem 0;">
                <input type="radio" name="income" value="100k-149k" style="margin-right: 0.75rem; transform: scale(1.2);">
                "$100,000 - $149,999"
            </label>
            <label style="display: flex; align-items: center; font-size: 1rem; cursor: pointer; padding: 0.3rem 0;">
                <input type="radio" name="income" value="150k-plus" style="margin-right: 0.75rem; transform: scale(1.2);">
                "$150,000 or more"
            </label>
            <label style="display: flex; align-items: center; font-size: 1rem; cursor: pointer; padding: 0.3rem 0;">
                <input type="radio" name="income" value="prefer-not-to-answer" style="margin-right: 0.75rem; transform: scale(1.2);">
                "Prefer not to answer"
            </label>
        </div>
    </div>

    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem; margin-bottom: 1rem;">
        <div class="question-group">
            <label style="font-size: 1rem; font-weight: 500; color: #1a1a1a; margin-bottom: 0.5rem; display: block;">Zip/Postal code:</label>
            <input type="text" name="zipcode" placeholder="Your zip code" required style="width: 100%; padding: 0.5rem; font-size: 1rem; border: 2px solid #e5e7eb; border-radius: 6px;">
        </div>

        <div style="display: flex; align-items: end;">
            <button type="submit" style="background-color: #000000; color: white; border: none; padding: 0.75rem 2rem; font-size: 1.1rem; font-weight: 500; border-radius: 40px; cursor: pointer; transition: all 0.2s ease; font-family: 'Inter', sans-serif; width: 100%;">
                Continue to Results
            </button>
        </div>
    </div>

                    <div class="question-group">
                        <label style="font-size: 1rem; font-weight: 500; color: #1a1a1a; margin-bottom: 0.5rem; display: block;">Additional feedback or comments:</label>
                        <textarea name="feedback" rows="2" placeholder="Any additional thoughts about the test..." style="width: 100%; padding: 0.5rem; font-size: 1rem; border: 2px solid #e5e7eb; border-radius: 6px; resize: vertical; font-family: 'Inter', sans-serif;"></textarea>
                    </div>
                </div>
            </form>
        </div>
    </div>

    <!-- Main assessment interface -->
    <div id="page-webcam" style="display:none;">
        <div class="main-container" id="main-container">
            <!-- Left Panel: Timer and Instructions -->
            <div class="left-panel">
                <!-- Metrics Section -->
                <div class="metrics-section">
                    


                    <div class="taps-counter">
                        <div class="taps-display" id="taps-display">0</div>
                        <div class="taps-subtitle" id="taps-subtitle">TAPS</div>
                    </div>
                </div>
                
                <!-- Trial Information -->
                <div class="trial-info">
                    <div class="trial-number" id="trial-number">Trial 1 of 6</div>
                    <div class="hand-instruction" id="hand-instruction">Right Hand</div>
                </div>
                
                <div class="instructions">
                    <h3>Guidelines</h3>
                    <div class="instruction-item" style="color: #ef4444;">Tap your fingers to start—go as fast as you can!</div>
                    <div class="instruction-item">Fingers wide open</div>
                    <div class="instruction-item">Palm facing camera</div>
                    <div class="instruction-item">Large, clear taps</div>
                    <div class="instruction-item">Consistent rhythm</div>
                </div>
            </div>

            <!-- Right Panel: Video -->
            <div class="right-panel">
                <div class="video-container">
                    <video id="inputVideo" autoplay playsinline></video>
                    <canvas id="outputCanvas"></canvas>
                    
                    <!-- Hand outline guide -->
                    <img id="hand-outline" src="https://raw.githubusercontent.com/ShadowCoder1/pd-video-analyzer/main/download.png" alt="Hand Outline Guide">


                    <!-- Hand positioning guide -->
                    <div id="hand-guide-overlay" class="hand-guide-overlay">
                        <div id="position-status" class="position-status">
                            Position hand in view
                        </div>
                    </div>

                    <!-- Feedback panel -->
                    <div id="tapWidthFeedback" class="feedback-panel">
                        <div id="tapWidthMessage" class="feedback-message">Open fingers wider</div>
                    </div>

                    <div id="countdown" class="countdown" style="display: none;"></div>
                    <div id="center-timer" class="center-timer">00:10</div>


                </div>
            </div>
        </div>
    </div>

    <div id="finalResults" class="final-results" style="display: none;">
        <!-- Final results will be inserted here -->
    </div>

    <script>
        // Global variables - keeping all the original functionality
        let camera, hands, canvasCtx, recording = false;
        let startTime, handDetected = false;
        let distanceChart, velocityChart;
        let recordingDuration = 10000;


        let countdownInterval;
        let frameCount = 0;
        let mainTimerInterval;
        
        // NEW: global handles to prevent “leftover” timers from previous trials
        let inactivityInterval = null;
        let stopTimeoutId = null;
        
        // NEW: token to invalidate late callbacks from old trials
        let currentTrialToken = 0;
        let activeTrialToken = 0;
        
        // Tap detection for auto-start
        let iPadLastProcessedFrame = 0;
        // Tap detection for auto-start
        let readyToStart = false;
        let preStartTapCount = 0;
        let lastPreStartTapTime = 0;
        
        // Hand detection tracking during recording
        // Hand detection tracking during recording
        let lastHandSeenTime = 0;
   
        const MAX_ALLOWED_HAND_LOSS = 3000; // 3 seconds max without hand consecutively
        const MAX_ALLOWED_NO_TAPS = 5000; // 5 seconds max without tapping
        // Signal processing variables
        let distanceSignal = [];
        let timeSignal = [];
        let smoothedSignal = [];
        let velocitySignal = [];
        let peakIndices = [];
        let landmarkSeries = [];
        let frameData = [];

        // Reset position checking state
        window.handPositionCorrect = false;
        frameCount = 0;
        window.tapFeedbackTimer = 0;

        let currentDetectedHand = null;

                // Because video and canvas are mirrored with scaleX(-1)
        const VIDEO_MIRRORED = true;
        
        // Hand label smoothing to avoid frame-to-frame flips
        const HAND_LABEL_WINDOW = 7;
        let handLabelBuffer = [];
        function pushHandLabel(lbl) {
          if (!lbl) return;
          handLabelBuffer.push(lbl);
          if (handLabelBuffer.length > HAND_LABEL_WINDOW) handLabelBuffer.shift();
        }
        function getStableHandLabel() {
          if (handLabelBuffer.length === 0) return null;
          const counts = {};
          for (const l of handLabelBuffer) counts[l] = (counts[l] ?? 0) + 1;
          // mode
          return Object.entries(counts).sort((a,b)=>b[1]-a[1])[0][0];
        }



        // Helper: check if the correct hand for this trial is visible
        function isCorrectHandDetectedForCurrentTrial() {
            const requiredHand = trialConditions[trialIndex % trialConditions.length].hand.toLowerCase();
            if (!currentDetectedHand) return false;
            return currentDetectedHand.toLowerCase() === requiredHand;
        }

        let tapEvents = [];
        let lastPeakTime = 0;
        
        // Parameters for signal processing
        const SAMPLE_RATE = 30;
        
// Randomize starting hand - 50% chance to start with left vs right
        const startWithLeft = Math.random() < 0.5;
        const trialConditions = startWithLeft ? [
            { hand: 'left' },
            { hand: 'right' },
            { hand: 'left' },
            { hand: 'right' },
            { hand: 'left' },
            { hand: 'right' }
        ] : [
            { hand: 'right' },
            { hand: 'left' },
            { hand: 'right' },
            { hand: 'left' },
            { hand: 'right' },
            { hand: 'left' }
        ];
        let trialIndex = 0;
        let totalTrials = trialConditions.length;

        let allTrialResults = []
        let totalTapsAcrossAllTrials = 0;
        function createLikertScale(name, leftLabel, rightLabel) {
                    let html = '<div style="display: flex; align-items: center; gap: 0.5rem;">';
                    html += `<span style="font-size: 0.8rem; color: #666666; min-width: 60px; text-align: right;">${leftLabel}</span>`;
                    
                    for (let i = 1; i <= 7; i++) {
                        html += `
                            <label class="likert-option">
                                <input type="radio" name="${name}" value="${i}" required>
                                <span style="font-size: 0.75rem; color: #666666;">${i}</span>
                            </label>
                        `;
                    }
                    
                    html += `<span style="font-size: 0.8rem; color: #666666; min-width: 60px; text-align: left;">${rightLabel}</span>`;
                    html += '</div>';
                    return html;
        }

        function generateProlificCode() {
            const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let result = '';
            for (let i = 0; i < 8; i++) {
                result += characters.charAt(Math.floor(Math.random() * characters.length));
            }
            return result;
        }

        function isIPadOrTablet() {
            // Detect iPad specifically, including newer iPads that identify as Mac
            const isIPad = /iPad/.test(navigator.userAgent) || 
                           (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
            
            // Also catch other large tablets (screen size between phone and desktop)
            const isLargeTablet = window.innerWidth > 768 && window.innerWidth <= 1024 && 'ontouchstart' in window;
            
            return isIPad || isLargeTablet;
        }

        function isIPad() {
            return /iPad/.test(navigator.userAgent) || 
                   (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
        }
function showQuestionnaire() {
    document.getElementById('page-webcam').style.display = 'none';
    
    // Mobile-responsive questionnaire HTML
    const questionnaireHTML = `
        <div style="${window.innerWidth <= 768 ? 'width: 100vw; height: 100vh; overflow-y: auto; background: white; padding: 1rem; box-sizing: border-box;' : 'max-width: 1200px; width: 95%; max-height: 95vh; overflow-y: auto; background: white; border-radius: 20px; padding: 2rem; box-shadow: 0 10px 40px rgba(0,0,0,0.1);'}">
            <div style="text-align: center; margin-bottom: 2rem;">
                <h2 style="font-size: ${window.innerWidth <= 768 ? 'clamp(1.8rem, 5vw, 2.2rem)' : '2.4rem'}; font-weight: 300; color: #1a1a1a; margin-bottom: 0.5rem; letter-spacing: -0.02em;">Quick Questions</h2>
                <p style="font-size: ${window.innerWidth <= 768 ? 'clamp(1rem, 3vw, 1.1rem)' : '1.1rem'}; color: #666666; font-weight: 400;">Please answer these brief questions about your experience</p>
            </div>

            <form id="questionnaire-form" style="text-align: left;">
                <!-- Likert Scale Explanation -->
                <div style="background: rgba(59, 130, 246, 0.05); border-radius: 8px; padding: 1rem; margin-bottom: 1.5rem; border-left: 3px solid #3b82f6;">
                    <p style="font-size: ${window.innerWidth <= 768 ? 'clamp(0.9rem, 2.5vw, 1rem)' : '1rem'}; color: #1a1a1a; margin: 0;"><strong>Rating Scale:</strong> 1 = Very Low/Poor, 7 = Very High/Excellent</p>
                </div>

                <!-- Experience Questions -->
                <div style="${window.innerWidth <= 768 ? 'margin-bottom: 2rem;' : 'display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem; margin-bottom: 1.5rem;'}">
                    <div class="${window.innerWidth <= 768 ? 'mobile-question-group' : 'question-group'}">
                        <label style="font-size: ${window.innerWidth <= 768 ? 'clamp(1rem, 3vw, 1.1rem)' : '1.1rem'}; font-weight: 500; color: #1a1a1a; margin-bottom: 0.5rem; display: block;">Video game experience:</label>
                        <div class="${window.innerWidth <= 768 ? 'mobile-likert-container' : 'likert-scale'}" id="videogame-scale-container">
                            <div class="${window.innerWidth <= 768 ? 'mobile-likert-scale' : 'likert-scale'}" id="videogame-scale"></div>
                        </div>
                    </div>

                    <div class="${window.innerWidth <= 768 ? 'mobile-question-group' : 'question-group'}">
                        <label style="font-size: ${window.innerWidth <= 768 ? 'clamp(1rem, 3vw, 1.1rem)' : '1.1rem'}; font-weight: 500; color: #1a1a1a; margin-bottom: 0.5rem; display: block;">Musical experience:</label>
                        <div class="${window.innerWidth <= 768 ? 'mobile-likert-container' : 'likert-scale'}" id="musical-scale-container">
                            <div class="${window.innerWidth <= 768 ? 'mobile-likert-scale' : 'likert-scale'}" id="musical-scale"></div>
                        </div>
                    </div>

                    <div class="${window.innerWidth <= 768 ? 'mobile-question-group' : 'question-group'}">
                        <label style="font-size: ${window.innerWidth <= 768 ? 'clamp(1rem, 3vw, 1.1rem)' : '1.1rem'}; font-weight: 500; color: #1a1a1a; margin-bottom: 0.5rem; display: block;">Sports experience:</label>
                        <div class="${window.innerWidth <= 768 ? 'mobile-likert-container' : 'likert-scale'}" id="sports-scale-container">
                            <div class="${window.innerWidth <= 768 ? 'mobile-likert-scale' : 'likert-scale'}" id="sports-scale"></div>
                        </div>
                    </div>

                    <div class="${window.innerWidth <= 768 ? 'mobile-question-group' : 'question-group'}">
                        <label style="font-size: ${window.innerWidth <= 768 ? 'clamp(1rem, 3vw, 1.1rem)' : '1.1rem'}; font-weight: 500; color: #1a1a1a; margin-bottom: 0.5rem; display: block;">Caffeine intake today:</label>
                        <div class="${window.innerWidth <= 768 ? 'mobile-likert-container' : 'likert-scale'}" id="caffeine-scale-container">
                            <div class="${window.innerWidth <= 768 ? 'mobile-likert-scale' : 'likert-scale'}" id="caffeine-scale"></div>
                        </div>
                    </div>
                </div>

                <!-- Mood and Performance Questions -->
                <div style="${window.innerWidth <= 768 ? 'margin-bottom: 2rem;' : 'display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem; margin-bottom: 1.5rem;'}">
                    <div class="${window.innerWidth <= 768 ? 'mobile-question-group' : 'question-group'}">
                        <label style="font-size: ${window.innerWidth <= 768 ? 'clamp(1rem, 3vw, 1.1rem)' : '1.1rem'}; font-weight: 500; color: #1a1a1a; margin-bottom: 0.5rem; display: block;">Current mood:</label>
                        <div class="${window.innerWidth <= 768 ? 'mobile-likert-container' : 'likert-scale'}" id="mood-scale-container">
                            <div class="${window.innerWidth <= 768 ? 'mobile-likert-scale' : 'likert-scale'}" id="mood-scale"></div>
                        </div>
                    </div>

                    <div class="${window.innerWidth <= 768 ? 'mobile-question-group' : 'question-group'}">
                        <label style="font-size: ${window.innerWidth <= 768 ? 'clamp(1rem, 3vw, 1.1rem)' : '1.1rem'}; font-weight: 500; color: #1a1a1a; margin-bottom: 0.5rem; display: block;">Task motivation:</label>
                        <div class="${window.innerWidth <= 768 ? 'mobile-likert-container' : 'likert-scale'}" id="motivated-scale-container">
                            <div class="${window.innerWidth <= 768 ? 'mobile-likert-scale' : 'likert-scale'}" id="motivated-scale"></div>
                        </div>
                    </div>

                    <div class="${window.innerWidth <= 768 ? 'mobile-question-group' : 'question-group'}">
                        <label style="font-size: ${window.innerWidth <= 768 ? 'clamp(1rem, 3vw, 1.1rem)' : '1.1rem'}; font-weight: 500; color: #1a1a1a; margin-bottom: 0.5rem; display: block;">Task distraction:</label>
                        <div class="${window.innerWidth <= 768 ? 'mobile-likert-container' : 'likert-scale'}" id="distracted-scale-container">
                            <div class="${window.innerWidth <= 768 ? 'mobile-likert-scale' : 'likert-scale'}" id="distracted-scale"></div>
                        </div>
                    </div>


                    <div class="${window.innerWidth <= 768 ? 'mobile-question-group' : 'question-group'}">
                        <label style="font-size: ${window.innerWidth <= 768 ? 'clamp(1rem, 3vw, 1.1rem)' : '1.1rem'}; font-weight: 500; color: #1a1a1a; margin-bottom: 0.5rem; display: block;">Persistence when tasks get frustrating:</label>
                        <div class="${window.innerWidth <= 768 ? 'mobile-likert-container' : 'likert-scale'}" id="persistence-scale-container">
                            <div class="${window.innerWidth <= 768 ? 'mobile-likert-scale' : 'likert-scale'}" id="persistence-scale"></div>
                        </div>
                    </div>
                    
                    <div class="${window.innerWidth <= 768 ? 'mobile-question-group' : 'question-group'}">
                        <label style="font-size: ${window.innerWidth <= 768 ? 'clamp(1rem, 3vw, 1.1rem)' : '1.1rem'}; font-weight: 500; color: #1a1a1a; margin-bottom: 0.5rem; display: block;">Attention span in general:</label>
                        <div class="${window.innerWidth <= 768 ? 'mobile-likert-container' : 'likert-scale'}" id="attention-scale-container">
                            <div class="${window.innerWidth <= 768 ? 'mobile-likert-scale' : 'likert-scale'}" id="attention-scale"></div>
                        </div>
                    </div>
                    
                    <div class="${window.innerWidth <= 768 ? 'mobile-question-group' : 'question-group'}">
                        <label style="font-size: ${window.innerWidth <= 768 ? 'clamp(1rem, 3vw, 1.1rem)' : '1.1rem'}; font-weight: 500; color: #1a1a1a; margin-bottom: 0.5rem; display: block;">Enjoyment of competition:</label>
                        <div class="${window.innerWidth <= 768 ? 'mobile-likert-container' : 'likert-scale'}" id="competition-scale-container">
                            <div class="${window.innerWidth <= 768 ? 'mobile-likert-scale' : 'likert-scale'}" id="competition-scale"></div>
                        </div>
                    </div>
                </div>

                <!-- Neurological Question -->
                <div class="${window.innerWidth <= 768 ? 'mobile-question-group' : 'question-group'}" style="margin-bottom: 1.5rem; background: rgba(0,0,0,0.02); padding: 1rem; border-radius: 8px;">
                    <label style="font-size: ${window.innerWidth <= 768 ? 'clamp(1rem, 3vw, 1.1rem)' : '1.1rem'}; font-weight: 500; color: #1a1a1a; margin-bottom: 0.5rem; display: block;">Do you have any known neurological conditions?</label>
                    <div style="display: flex; gap: 2rem;">
                        <label style="display: flex; align-items: center; font-size: ${window.innerWidth <= 768 ? 'clamp(1rem, 3vw, 1.1rem)' : '1.1rem'}; cursor: pointer;">
                            <input type="radio" name="neurological" value="no" required style="margin-right: 0.5rem; transform: scale(1.2);">
                            No
                        </label>
                        <label style="display: flex; align-items: center; font-size: ${window.innerWidth <= 768 ? 'clamp(1rem, 3vw, 1.1rem)' : '1.1rem'}; cursor: pointer;">
                            <input type="radio" name="neurological" value="yes" style="margin-right: 0.5rem; transform: scale(1.2);">
                            Yes
                        </label>
                    </div>
                </div>

                <!-- Hand Pain Question -->
                <div class="${window.innerWidth <= 768 ? 'mobile-question-group' : 'question-group'}" style="margin-bottom: 1.5rem; background: rgba(0,0,0,0.02); padding: 1rem; border-radius: 8px;">
                    <label style="font-size: ${window.innerWidth <= 768 ? 'clamp(1rem, 3vw, 1.1rem)' : '1.1rem'}; font-weight: 500; color: #1a1a1a; margin-bottom: 0.5rem; display: block;">Do you currently have hand-related pain that affects your performance on tasks like this?</label>
                    <div style="display: flex; gap: 2rem;">
                        <label style="display: flex; align-items: center; font-size: ${window.innerWidth <= 768 ? 'clamp(1rem, 3vw, 1.1rem)' : '1.1rem'}; cursor: pointer;">
                            <input type="radio" name="handPain" value="no" required style="margin-right: 0.5rem; transform: scale(1.2);">
                            No
                        </label>
                        <label style="display: flex; align-items: center; font-size: ${window.innerWidth <= 768 ? 'clamp(1rem, 3vw, 1.1rem)' : '1.1rem'}; cursor: pointer;">
                            <input type="radio" name="handPain" value="yes" style="margin-right: 0.5rem; transform: scale(1.2);">
                            Yes
                        </label>
                    </div>
                </div>

                <!-- Injury/Disease History Question -->
                <div class="${window.innerWidth <= 768 ? 'mobile-question-group' : 'question-group'}" style="margin-bottom: 1.5rem; background: rgba(0,0,0,0.02); padding: 1rem; border-radius: 8px;">
                    <label style="font-size: ${window.innerWidth <= 768 ? 'clamp(1rem, 3vw, 1.1rem)' : '1.1rem'}; font-weight: 500; color: #1a1a1a; margin-bottom: 0.5rem; display: block;">History of injury/disease affecting hand/arm movement:</label>
                    <div style="display: flex; gap: 2rem;">
                        <label style="display: flex; align-items: center; font-size: ${window.innerWidth <= 768 ? 'clamp(1rem, 3vw, 1.1rem)' : '1.1rem'}; cursor: pointer;">
                            <input type="radio" name="handInjuryHistory" value="no" required style="margin-right: 0.5rem; transform: scale(1.2);">
                            No
                        </label>
                        <label style="display: flex; align-items: center; font-size: ${window.innerWidth <= 768 ? 'clamp(1rem, 3vw, 1.1rem)' : '1.1rem'}; cursor: pointer;">
                            <input type="radio" name="handInjuryHistory" value="yes" style="margin-right: 0.5rem; transform: scale(1.2);">
                            Yes
                        </label>
                    </div>
                </div>

                <!-- Demographics Questions -->
                <div style="border-top: 1px solid rgba(0,0,0,0.1); padding-top: 1.5rem;">
                    <div style="background: rgba(59, 130, 246, 0.05); border-radius: 8px; padding: 1rem; margin-bottom: 1.5rem; border-left: 3px solid #3b82f6;">
                        <p style="font-size: ${window.innerWidth <= 768 ? 'clamp(0.9rem, 2.5vw, 0.95rem)' : '0.95rem'}; color: #1a1a1a; margin: 0;"><strong>Why we ask:</strong> Understanding participants' income levels and geographic location helps us examine how economic factors may influence physical ability. Your response helps ensure our findings reflect the experiences of people from diverse financial and geographical backgrounds.</p>
                    </div>
                    
                    <div class="${window.innerWidth <= 768 ? 'mobile-question-group' : 'question-group'}" style="margin-bottom: 1.5rem;">
                        <label style="font-size: ${window.innerWidth <= 768 ? 'clamp(1rem, 3vw, 1.1rem)' : '1.1rem'}; font-weight: 500; color: #1a1a1a; margin-bottom: 1rem; display: block;">What is your total annual household income before taxes? (Please select the range that best represents your income.)</label>
                        <div style="display: flex; flex-direction: column; gap: 0.5rem;">
                            <label style="display: flex; align-items: center; font-size: ${window.innerWidth <= 768 ? 'clamp(0.95rem, 2.8vw, 1rem)' : '1rem'}; cursor: pointer; padding: 0.3rem 0;">
                                <input type="radio" name="income" value="less-than-20k" required style="margin-right: 0.75rem; transform: scale(1.2);">
                                "Less than $20,000"
                            </label>
                            <label style="display: flex; align-items: center; font-size: ${window.innerWidth <= 768 ? 'clamp(0.95rem, 2.8vw, 1rem)' : '1rem'}; cursor: pointer; padding: 0.3rem 0;">
                                <input type="radio" name="income" value="20k-39k" style="margin-right: 0.75rem; transform: scale(1.2);">
                                "$20,000 - $39,999"
                            </label>
                            <label style="display: flex; align-items: center; font-size: ${window.innerWidth <= 768 ? 'clamp(0.95rem, 2.8vw, 1rem)' : '1rem'}; cursor: pointer; padding: 0.3rem 0;">
                                <input type="radio" name="income" value="40k-59k" style="margin-right: 0.75rem; transform: scale(1.2);">
                                "$40,000 - $59,999"
                            </label>
                            <label style="display: flex; align-items: center; font-size: ${window.innerWidth <= 768 ? 'clamp(0.95rem, 2.8vw, 1rem)' : '1rem'}; cursor: pointer; padding: 0.3rem 0;">
                                <input type="radio" name="income" value="60k-79k" style="margin-right: 0.75rem; transform: scale(1.2);">
                                "$60,000 - $79,999"
                            </label>
                            <label style="display: flex; align-items: center; font-size: ${window.innerWidth <= 768 ? 'clamp(0.95rem, 2.8vw, 1rem)' : '1rem'}; cursor: pointer; padding: 0.3rem 0;">
                                <input type="radio" name="income" value="80k-99k" style="margin-right: 0.75rem; transform: scale(1.2);">
                                "$80,000 - $99,999"
                            </label>
                            <label style="display: flex; align-items: center; font-size: ${window.innerWidth <= 768 ? 'clamp(0.95rem, 2.8vw, 1rem)' : '1rem'}; cursor: pointer; padding: 0.3rem 0;">
                                <input type="radio" name="income" value="100k-149k" style="margin-right: 0.75rem; transform: scale(1.2);">
                                "$100,000 - $149,999"
                            </label>
                            <label style="display: flex; align-items: center; font-size: ${window.innerWidth <= 768 ? 'clamp(0.95rem, 2.8vw, 1rem)' : '1rem'}; cursor: pointer; padding: 0.3rem 0;">
                                <input type="radio" name="income" value="150k-plus" style="margin-right: 0.75rem; transform: scale(1.2);">
                                "$150,000 or more"
                            </label>
                            <label style="display: flex; align-items: center; font-size: ${window.innerWidth <= 768 ? 'clamp(0.95rem, 2.8vw, 1rem)' : '1rem'}; cursor: pointer; padding: 0.3rem 0;">
                                <input type="radio" name="income" value="prefer-not-to-answer" style="margin-right: 0.75rem; transform: scale(1.2);">
                                "Prefer not to answer"
                            </label>
                        </div>
                    </div>

                    <div style="${window.innerWidth <= 768 ? 'margin-bottom: 2rem;' : 'display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem; margin-bottom: 1rem;'}">
                        <div class="${window.innerWidth <= 768 ? 'mobile-question-group' : 'question-group'}">
                            <label style="font-size: ${window.innerWidth <= 768 ? 'clamp(1rem, 3vw, 1rem)' : '1rem'}; font-weight: 500; color: #1a1a1a; margin-bottom: 0.5rem; display: block;">Zip/Postal code:</label>
                            <input type="text" name="zipcode" placeholder="Your zip code" required style="width: 100%; padding: 0.5rem; font-size: ${window.innerWidth <= 768 ? 'clamp(1rem, 3vw, 1rem)' : '1rem'}; border: 2px solid #e5e7eb; border-radius: 6px;">
                        </div>

                        <div style="${window.innerWidth <= 768 ? 'margin-top: 1rem;' : 'display: flex; align-items: end;'}">
                            <button type="submit" style="background-color: #000000; color: white; border: none; padding: 0.75rem 2rem; font-size: ${window.innerWidth <= 768 ? 'clamp(1.1rem, 3.5vw, 1.3rem)' : '1.1rem'}; font-weight: 500; border-radius: 40px; cursor: pointer; transition: all 0.2s ease; font-family: 'Inter', sans-serif; width: 100%;">
                                Continue to Results
                            </button>
                        </div>
                    </div>

                    <div class="${window.innerWidth <= 768 ? 'mobile-question-group' : 'question-group'}">
                        <label style="font-size: ${window.innerWidth <= 768 ? 'clamp(1rem, 3vw, 1rem)' : '1rem'}; font-weight: 500; color: #1a1a1a; margin-bottom: 0.5rem; display: block;">Additional feedback or comments:</label>
                        <textarea name="feedback" rows="2" placeholder="Any additional thoughts about the test..." style="width: 100%; padding: 0.5rem; font-size: ${window.innerWidth <= 768 ? 'clamp(1rem, 3vw, 1rem)' : '1rem'}; border: 2px solid #e5e7eb; border-radius: 6px; resize: vertical; font-family: 'Inter', sans-serif;"></textarea>
                    </div>
                </div>
            </form>
        </div>
    `;
    
    document.getElementById('questionnaire-overlay').innerHTML = questionnaireHTML;
    
    // Create mobile-optimized Likert scales
    function createMobileLikertScale(name, leftLabel, rightLabel) {
                // FIXED: Mobile/tablet-specific validation without alerts that freeze camera
        if (window.innerWidth <= 768 || isIPadOrTablet()) {
            let html = '';
            for (let i = 1; i <= 7; i++) {
                html += `
                    <label class="likert-option">
                        <input type="radio" name="${name}" value="${i}" required>
                        <span>${i}</span>
                    </label>
                `;
            }
            return html;
        } else {
            // Desktop version (unchanged)
            let html = '<div style="display: flex; align-items: center; gap: 0.5rem;">';
            html += `<span style="font-size: 0.8rem; color: #666666; min-width: 60px; text-align: right;">${leftLabel}</span>`;
            
            for (let i = 1; i <= 7; i++) {
                html += `
                    <label class="likert-option">
                        <input type="radio" name="${name}" value="${i}" required>
                        <span style="font-size: 0.75rem; color: #666666;">${i}</span>
                    </label>
                `;
            }
            
            html += `<span style="font-size: 0.8rem; color: #666666; min-width: 60px; text-align: left;">${rightLabel}</span>`;
            html += '</div>';
            return html;
        }
    }
    
    // Populate Likert scales
    document.getElementById('videogame-scale').innerHTML = createMobileLikertScale('videogame', 'Very Low', 'Very High');
    document.getElementById('musical-scale').innerHTML = createMobileLikertScale('musical', 'Very Low', 'Very High');
    document.getElementById('sports-scale').innerHTML = createMobileLikertScale('sports', 'Very Low', 'Very High');
    document.getElementById('caffeine-scale').innerHTML = createMobileLikertScale('caffeine', 'None', 'Very High');
    document.getElementById('mood-scale').innerHTML = createMobileLikertScale('mood', 'Very Poor', 'Excellent');
    document.getElementById('motivated-scale').innerHTML = createMobileLikertScale('motivated', 'Not at all', 'Extremely');
    document.getElementById('distracted-scale').innerHTML = createMobileLikertScale('distracted', 'Not at all', 'Extremely');
    document.getElementById('persistence-scale').innerHTML = createMobileLikertScale('persistence', 'Give up quickly', 'Push through');
    document.getElementById('attention-scale').innerHTML = createMobileLikertScale('attention', 'Very short', 'Very long');
    document.getElementById('competition-scale').innerHTML = createMobileLikertScale('competition', 'Not at all', 'Very much');
    
    document.getElementById('questionnaire-overlay').style.display = 'flex';
            // Handle form submission
// Handle form submission
document.getElementById('questionnaire-form').addEventListener('submit', function(e) {
    e.preventDefault();
    
    const formData = new FormData(this);
    const responses = {};
    
    // Collect all form data
    for (let [key, value] of formData.entries()) {
        responses[key] = value;
    }
    
    // Log what we're about to save
    console.log("📋 Questionnaire responses to save:", responses);
    
    const expectedFields = [
        'videogame', 'musical', 'sports', 'caffeine', 
        'mood', 'motivated', 'distracted',
        'neurological', 'handPain', 'handInjuryHistory', 'persistence', 'attention', 'competition', 'income', 'zipcode'
    ];
    
    const missingFields = expectedFields.filter(field => !responses[field]);
    if (missingFields.length > 0) {
        console.warn("⚠️ Missing required fields:", missingFields);
        alert(`Please complete all required fields: ${missingFields.join(', ')}`);
        return;
    }
    
    // Structure the data properly
    const questionnaireData = {
        // Experience ratings (1-7 scale)
        experienceRatings: {
            videogameExperience: parseInt(responses.videogame),
            musicalExperience: parseInt(responses.musical),
            sportsExperience: parseInt(responses.sports),
            caffeineIntakeToday: parseInt(responses.caffeine)
        },
        
        // Mood and performance ratings (1-7 scale)
        moodPerformanceRatings: {
            currentMood: parseInt(responses.mood),
            taskMotivation: parseInt(responses.motivated),
            taskDistraction: parseInt(responses.distracted),
            expectedPerformanceVsOthers: parseInt(responses.performance)
        },
        
        // Demographics and health
        demographics: {
            hasNeurologicalConditions: responses.neurological === 'yes',
            hasHandPain: responses.handPain === 'yes',
            hasHandInjuryHistory: responses.handInjuryHistory === 'yes',
            householdIncome: responses.income,
            zipCode: responses.zipcode
        },
        
        // Optional feedback
        feedback: responses.feedback || '',
        
        // Metadata
        completedAt: new Date().toISOString(),
        participantID: sessionStorage.getItem('prolificID') || 'anonymous'
    };
    
    console.log("💾 Structured questionnaire data:", questionnaireData);
    
    // Save to MULTIPLE Firebase locations for redundancy
    const participantID = sessionStorage.getItem('prolificID') || 'anonymous';
    
    // Location 1: Under Results collection (existing)
    const savePromise1 = db.collection("Results")
        .doc(participantID)
        .collection("Questionnaire")
        .doc("Responses")
        .set(questionnaireData);
    
    // Location 2: Under main participant document for easy access
    const savePromise2 = db.collection("Participants")
        .doc(participantID)
        .collection("Questionnaire")
        .doc("Demographics")
        .set(questionnaireData);
        
    // Location 3: Flat structure for easy querying
    const savePromise3 = db.collection("QuestionnaireResponses")
        .doc(participantID)
        .set(questionnaireData);
    
    // Wait for all saves to complete
    Promise.all([savePromise1, savePromise2, savePromise3])
        .then(() => {
            console.log("✅ Questionnaire data saved successfully to all locations");
            
            // Now show the results
            document.getElementById('questionnaire-overlay').style.display = 'none';
            showFinalResults();
        })
        .catch(err => {
            console.error("❌ Error saving questionnaire data:", err);
            alert("There was an error saving your responses. Please try again.");
        });
});
        }

        const SMOOTHING_WINDOW = 3;
        const MIN_PEAK_PROMINENCE = 0.3;
        const MIN_PEAK_DISTANCE = 100;
        const CLOSED_THRESHOLD_PCT = 30;
        const OPEN_THRESHOLD_PCT = 35;
        const HAND_TOO_FAR_THRESHOLD = 0.28; // Scaled up proportionally (0.2 * 1.4)
        const HAND_TOO_CLOSE_THRESHOLD = 0.84; // Scaled up proportionally (0.6 * 1.4)
        const VELOCITY_THRESHOLD_PERCENTILE = 70;
        const MIN_REQUIRED_TAPS = 15; // Minimum taps required to avoid restart

        // Hand landmarks indices
        const WRIST = 0;
        const THUMB_TIP = 4;
        const INDEX_TIP = 8;
        const MIDDLE_MCP = 9;

        const POPULATION_NORMS = {
            frequency: {
                healthy: {
                    // Based on Ruff & Parker (1993) - 358 adults, ages 16-70
                    base_mean_taps_per_10sec: 50.6,
                    base_standard_deviation: 6.3,
                    performance_validity_cutoffs: {
                        men: 36,    // Keep these - validated validity thresholds
                        women: 29   // Keep these - validated validity thresholds
                    }
                }
            }
        };
                
        function getDemographicAdjustedNorms() {
            // Get demographic data from sessionStorage
            const age = parseInt(sessionStorage.getItem('age')) || 30;
            const gender = sessionStorage.getItem('gender') || 'male';
            
            // Research-based norms from Ruff & Parker (1993), n=358
            let adjustedMean = 50.6; // Combined population mean
            let adjustedSD = 6.3;    // Combined population SD
            
            // Gender adjustments (based on Ruff & Parker, 1993)
            if (gender === 'male') {
                adjustedMean = 53.4; // Men's mean from research
                adjustedSD = 6.0;    // Men's SD from research
            } else if (gender === 'female') {
                adjustedMean = 47.8; // Women's mean from research
                adjustedSD = 5.3;    // Women's SD from research
                
                // Age adjustments (mainly affects women per research)
                if (age >= 55) {
                    adjustedMean -= 3.8; // Women 55-70: 45.7 vs 49.5 for 16-24
                } else if (age >= 40) {
                    adjustedMean -= 1.5; // Women 40-54: 47.0 vs 49.5 for 16-24
                }
            }
            // Men show minimal age effects in research, so no age adjustments for males
            
            return { mean: adjustedMean, sd: adjustedSD };
        }
        // Later in the code, replace the norm calculation:
        // OLD:
        // const normMean = 55;
        // const normSD = 8;
        
        // Research-based demographic norms from Ruff & Parker (1993)
        const demographicNorms = getDemographicAdjustedNorms();
        const normMean = demographicNorms.mean;
        const normSD = demographicNorms.sd;
                // Initialize MediaPipe Hands
        function initializeHands() {
            try {
                hands = new Hands({
                    locateFile: (file) => {
                        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                    }
                });
        
                // iPad-specific MediaPipe optimizations
// iPad-specific MediaPipe optimizations
                if (isIPadOrTablet()) {
                    hands.setOptions({
                        maxNumHands: 1,
                        modelComplexity: 0,  // Reduced from 1 to 0 for iPad only
                        minDetectionConfidence: 0.6,  // Slightly reduced for better performance
                        minTrackingConfidence: 0.6   // Slightly reduced for better performance
                    });
                } else {
                    // Desktop and mobile settings (unchanged)
                    hands.setOptions({
                        maxNumHands: 1,
                        modelComplexity: 1,
                        minDetectionConfidence: 0.7,
                        minTrackingConfidence: 0.7
                    });
                }
        
                hands.onResults(onHandsResults);
                
                // iPad-specific optimizations - ADD THIS HERE
                if (isIPadOrTablet()) {
                    console.log('iPad detected - applying performance optimizations');
                    const originalOnResults = hands.onResults;
                    let frameSkipCounter = 0;
                    
                    hands.onResults = function(results) {
                        frameSkipCounter++;
                        originalOnResults.call(this, results);
                    };
                }
                
                console.log('MediaPipe Hands initialized successfully');
            } catch (error) {
                console.error('Failed to initialize MediaPipe Hands:', error);
                document.getElementById('position-status').textContent = 'Failed to load hand tracking. Please refresh the page.';
            }
        }

        // Mobile loading overlay functions
        function showMobileLoading() {
            if (window.innerWidth <= 768 || isIPadOrTablet()) {
                const overlay = document.getElementById('mobile-loading-overlay');
                overlay.style.display = 'block';
                updateLoadingProgress(0, "Requesting camera access...");
                setTimeout(() => updateLoadingProgress(25, "Loading hand tracking..."), 500);
                setTimeout(() => updateLoadingProgress(50, "Initializing MediaPipe..."), 1500);
                setTimeout(() => updateLoadingProgress(75, "Starting video feed..."), 3000);
            }
        }

        function updateLoadingProgress(percent, status) {
            const progressBar = document.getElementById('loading-progress');
            const statusText = document.getElementById('loading-status');
            if (progressBar) progressBar.style.width = percent + '%';
            if (statusText) statusText.textContent = status;
        }

        function hideMobileLoading() {
            const overlay = document.getElementById('mobile-loading-overlay');
            if (overlay) {
                updateLoadingProgress(100, "Ready!");
                setTimeout(() => { overlay.style.display = 'none'; }, 500);
            }
        }

        // Initialize camera
        // REPLACE YOUR initializeCamera function with this version:
        function initializeCamera() {
            const videoElement = document.getElementById('inputVideo');
            const canvasElement = document.getElementById('outputCanvas');
            canvasCtx = canvasElement.getContext('2d');
        
        // iPad-specific video constraints
            const videoConstraints = isIPadOrTablet() ? {
                video: {
                    width: { ideal: 1280 },  // Reduced resolution for iPad
                    height: { ideal: 720 },  // Reduced resolution for iPad
                    facingMode: "user",
                    frameRate: { ideal: 24, max: 30 }  // Limit frame rate on iPad
                }
            } : {
                video: {
                    width: { ideal: 1920 },
                    height: { ideal: 1080 },
                    facingMode: "user"
                }
            };
        
            navigator.mediaDevices.getUserMedia(videoConstraints).then(async (stream) => {
                videoElement.srcObject = stream;
            
                // FIXED: Proper mobile video setup
                if (window.innerWidth <= 768) {
                    videoElement.setAttribute('playsinline', 'true');
                    videoElement.setAttribute('webkit-playsinline', 'true');
                    videoElement.muted = true;
                    videoElement.autoplay = true;
                    
                    // Force play on mobile after metadata loads
                    videoElement.addEventListener('loadedmetadata', async () => {
                        try {
                            await videoElement.play();
                            console.log('📱 Mobile video started successfully');
                        } catch (e) {
                            console.warn('📱 Mobile video autoplay blocked, will play on user interaction');
                        }
                    });
                }
            
                videoElement.onloadedmetadata = () => {
                    canvasElement.width = videoElement.videoWidth;
                    canvasElement.height = videoElement.videoHeight;
                    hideMobileLoading();
            
                    let lastFrameTime = Date.now();
            
                    const processFrame = async () => {
                        try {
                            if (videoElement.readyState >= 2 && !videoElement.paused) {
                                // iPad-specific frame rate limiting
// iPad-specific frame rate limiting
                                if (isIPadOrTablet()) {
                                    const now = Date.now();
                         
                                    if (now - iPadLastProcessedFrame < 16) { // Allow up to ~60fps for accuracy// Limit to ~40fps max instead of 30fps
                                        requestAnimationFrame(processFrame);
                                        return;
                                    }
                                    iPadLastProcessedFrame = now;
                                }
                                
                                await hands.send({ image: videoElement });
                                lastFrameTime = Date.now();
                            }
                        } catch (err) {
                            console.warn("MediaPipe processing error:", err);
                        }
                        requestAnimationFrame(processFrame);
                    };
            
                    // FIXED: Simplified watchdog for mobile
                    const startWatchdog = () => {
                        setInterval(async () => {
                            const now = Date.now();
                            if (now - lastFrameTime > 3000) {
                                console.warn("Hand tracking frozen, restarting...");
                                try {
                                    hands.close();
                                    initializeHands();
                                    
                                    // FIXED: Resume video on mobile if paused
                                    if (window.innerWidth <= 768 && videoElement.paused) {
                                        await videoElement.play();
                                    }
                                } catch (e) {
                                    console.warn("Restart failed:", e);
                                }
                            }
                        }, 2000);
                    };
            
                    requestAnimationFrame(processFrame);
                    startWatchdog();
                };
            }).catch(err => {
                            console.error("Camera access error:", err);
                            hideMobileLoading();
                            alert("Camera access denied. Please refresh and grant camera permissions.");
            });
        }
        

        // Moving average filter
        function movingAverage(data, windowSize) {
            const result = [];
            for (let i = 0; i < data.length; i++) {
                let start = Math.max(0, i - Math.floor(windowSize / 2));
                let end = Math.min(data.length, i + Math.floor(windowSize / 2) + 1);
                let sum = 0;
                for (let j = start; j < end; j++) {
                    sum += data[j];
                }
                result.push(sum / (end - start));
            }
            return result;
        }

        // Calculate numerical derivative
        function calculateDerivative(data, timeData) {
            const derivative = [];
            for (let i = 1; i < data.length; i++) {
                const dt = (timeData[i] - timeData[i-1]) / 1000;
                const dy = data[i] - data[i-1];
                derivative.push(dy / dt);
            }
            return derivative;
        }

        // Find peaks in signal using adaptive thresholding
        function findPeaks(signal, prominence = MIN_PEAK_PROMINENCE) {
            const peaks = [];
            
            const mean = signal.reduce((a, b) => a + b, 0) / signal.length;
            const variance = signal.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / signal.length;
            const std = Math.sqrt(variance);
            
            const threshold = mean + prominence * std;
            
            for (let i = 1; i < signal.length - 1; i++) {
                if (signal[i] > signal[i-1] && signal[i] > signal[i+1] && signal[i] > threshold) {
                    if (peaks.length === 0 || (timeSignal[i] - timeSignal[peaks[peaks.length - 1]]) > MIN_PEAK_DISTANCE) {
                        peaks.push(i);
                    }
                }
            }
            
            return peaks;
        }

        function detectTapsFromVelocity(velocitySignal, distanceSignal) {
            const taps = [];
            let state = 'open';
            let lastTapTime = -Infinity;

            for (let i = 1; i < velocitySignal.length - 1; i++) {
                const t = timeSignal[i];
                const dist = distanceSignal[i];
                const velPrev = velocitySignal[i - 1];
                const velCurr = velocitySignal[i];

                switch (state) {
                    case 'open':
                        if (dist < 30 && velPrev < 0 && velCurr >= 0) {
                            if ((t - lastTapTime) > MIN_PEAK_DISTANCE) {
                                taps.push({
                                    index: i,
                                    time: t,
                                    amplitude: dist
                                });
                                lastTapTime = t;
                                state = 'must_open';
                            }
                        }
                        break;

                    case 'must_open':
                        if (dist > 35) {
                            state = 'open';
                        }
                        break;

                    default:
                        state = 'open';
                }
            }

            return taps;
        }

        // Process hand detection results
 function onHandsResults(results) {
    const canvasElement = document.getElementById('outputCanvas');
    canvasCtx.save();
    canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
    
    canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        handDetected = true;
        const landmarks = results.multiHandLandmarks[0];
        frameCount++;

        // Track hand detection during recording
        if (recording) {
            lastHandSeenTime = Date.now();
        }
        
        // Get hand label (flip because the video/canvas are mirrored)
        if (results.multiHandedness && results.multiHandedness.length > 0) {
          // pick highest-score hand classification
          const best = results.multiHandedness
            .slice()
            .sort((a, b) => (b.score ?? 0) - (a.score ?? 0))[0];
        
          let raw = best?.label?.toLowerCase() || null; // "left" | "right"
          if (raw) {
            // Flip only because we draw with scaleX(-1)
            const logical = VIDEO_MIRRORED ? (raw === "right" ? "left" : "right") : raw;
            pushHandLabel(logical);
            // Use a stable (mode) label to avoid jitter; once recording, keep first stable value
            const stable = getStableHandLabel();
            currentDetectedHand = recording ? (currentDetectedHand || stable) : stable;
          } else {
            currentDetectedHand = null;
            handLabelBuffer = [];
          }
        } else {
          currentDetectedHand = null;
          handLabelBuffer = [];
        }
        
        
        // Always update hand position feedback when not recording
        if (!recording) {
            updateHandPositionFeedback(landmarks);
            
            // SIMPLIFIED: Only check if correct hand is detected for auto-start
            if (readyToStart && isCorrectHandDetectedForCurrentTrial()) {
                detectPreStartTaps(landmarks, results.image.width, results.image.height);
            }
        }
        
        // Handle recording state
        if (recording) {
            const currentTime = Date.now() - startTime;
            if (currentTime < recordingDuration) {
                // Check if correct hand is being used
                    if (isCorrectHandDetectedForCurrentTrial()) {
                    // iPad-specific processing optimization
                        if (isIPadOrTablet()) {
                            processFingerTapAdvancedIPad(landmarks, results.image.width, results.image.height);
                        } else {
                            processFingerTapAdvanced(landmarks, results.image.width, results.image.height);
                        }
                } else {
                    // Wrong hand detected during recording - restart trial
                    console.log("Wrong hand detected during recording, restarting trial");
                    restartTrialDueToWrongHand();
                    return;
                }
            }
        }
        
        // Draw visualization with iPad optimization
        if (isIPadOrTablet()) {
            drawHandVisualizationIPad(landmarks, canvasElement);
        } else {
            drawHandVisualization(landmarks, canvasElement);
        }
        
    } else {
        handDetected = false;
        currentDetectedHand = null;
        
        // Always update feedback when no hand detected
        if (!recording) {
            updateHandPositionFeedback(null);
        }
    }
    
    canvasCtx.restore();
 }


function detectPreStartTaps(landmarks, imageWidth, imageHeight) {
    const currentTime = Date.now();
    
    const thumbTip = landmarks[THUMB_TIP];
    const indexTip = landmarks[INDEX_TIP];
    const wrist = landmarks[WRIST];
    const middleMcp = landmarks[MIDDLE_MCP];
    
    const handSize = Math.sqrt(
        Math.pow((wrist.x - middleMcp.x) * imageWidth, 2) +
        Math.pow((wrist.y - middleMcp.y) * imageHeight, 2)
    );
    
    const distance = Math.sqrt(
        Math.pow((thumbTip.x - indexTip.x) * imageWidth, 2) +
        Math.pow((thumbTip.y - indexTip.y) * imageHeight, 2) +
        Math.pow((thumbTip.z - indexTip.z) * imageWidth * 0.5, 2)
    );
    
    const normalizedDistance = (distance / handSize) * 100;
    
    // MUCH MORE AGGRESSIVE: Start immediately on any finger movement that looks like a tap
    if (normalizedDistance < 40) { // More lenient threshold
        if (currentTime - lastPreStartTapTime > 100) { // Faster detection
            console.log("🚀 TAP DETECTED - STARTING NOW! Distance:", normalizedDistance);
            lastPreStartTapTime = currentTime;
            startActualRecording();
            return;
        }
    }
}
         // REPLACE your updateHandPositionFeedback function with this version:
        function updateHandPositionFeedback(landmarks) {
            const positionStatus = document.getElementById('position-status');
            const handOutline = document.getElementById('hand-outline');
            
            if (!landmarks) {
                positionStatus.textContent = 'No hand detected';
                positionStatus.className = 'position-status error';
                handOutline.classList.remove('hand-outline-ready');
                handOutline.classList.add('hand-outline-not-ready');
                window.handPositionCorrect = false;
                return;
            }
        
            const wrist = landmarks[WRIST];
            const thumbTip = landmarks[THUMB_TIP];
            const indexTip = landmarks[INDEX_TIP];
            const middleMcp = landmarks[MIDDLE_MCP];
            
            const handSize = Math.sqrt(
                Math.pow((wrist.x - middleMcp.x), 2) +
                Math.pow((wrist.y - middleMcp.y), 2)
            );
            
            // More liberal thresholds - allow hand to be further away and closer
            const goodDistance = (handSize > 0.18 && handSize < 0.55);
                                    
            const fingerDistance = Math.sqrt(
                Math.pow((thumbTip.x - indexTip.x), 2) +
                Math.pow((thumbTip.y - indexTip.y), 2)
            );
            
            // More liberal finger opening threshold
            const fingersOpen = (fingerDistance > 0.08);
            
            window.handPositionCorrect = goodDistance && fingersOpen;
            
            if (!isCorrectHandDetectedForCurrentTrial()) {
                const requiredHand = trialConditions[trialIndex % trialConditions.length].hand.toUpperCase();
                positionStatus.textContent = `Wrong hand! Use ${requiredHand} hand`;
                positionStatus.className = 'position-status error';
                handOutline.classList.remove('hand-outline-ready');
                handOutline.classList.add('hand-outline-not-ready');
                } else if (goodDistance && fingersOpen) {
                    positionStatus.innerHTML = 'The timer starts once you begin tapping<br>as fast as you can for 10 seconds.';


                    positionStatus.className = 'position-status ready';
                    handOutline.classList.remove('hand-outline-not-ready');
                    handOutline.classList.add('hand-outline-ready');
                    
                    // Remove any click handlers since we're using tap detection
                    positionStatus.style.cursor = '';
                    positionStatus.onclick = null;

            } else {
                handOutline.classList.remove('hand-outline-ready');
                handOutline.classList.add('hand-outline-not-ready');
                positionStatus.className = 'position-status warning';
                positionStatus.style.cursor = '';
                positionStatus.onclick = null;
                
                if (!goodDistance) {
                    const tooClose = 0.15;
                    const tooFar = 0.58; // Much more forgiving far threshold
                    if (handSize < tooClose) {
                        positionStatus.textContent = 'Move closer to camera';
                    } else if (handSize > tooFar) {
                        positionStatus.textContent = 'Move back from camera';
                    } else {
                        positionStatus.textContent = 'Adjust distance';
                    }
                } else if (!fingersOpen) {
                    positionStatus.textContent = 'Open fingers wider';
                }
            }
        }
        function drawHandVisualization(landmarks, canvasElement) {
            const thumbTip = landmarks[THUMB_TIP];
            const indexTip = landmarks[INDEX_TIP];
            const distance = Math.sqrt(
                Math.pow((thumbTip.x - indexTip.x) * canvasElement.width, 2) +
                Math.pow((thumbTip.y - indexTip.y) * canvasElement.height, 2)
            );
            
            const isTapping = recording && distance < 30;
            
            let justTapped = false;
            if (recording && tapEvents.length > 0) {
                const currentTime = Date.now() - startTime;
                const lastTap = tapEvents[tapEvents.length - 1];
                justTapped = (currentTime - lastTap.time) < 150;
            }
            
            // Clean visual feedback
            let dotColor = '#ffffff';
            let lineColor = 'rgba(255, 255, 255, 0.5)';
            let dotSize = 10;
            
            if (justTapped) {
                dotColor = '#22c55e';
                lineColor = 'rgba(34, 197, 94, 1)';
                dotSize = 14;
                canvasCtx.shadowBlur = 20;
                canvasCtx.shadowColor = '#22c55e';
            } else if (isTapping) {
                dotColor = '#16a34a';
                lineColor = 'rgba(22, 163, 74, 0.8)';
                dotSize = 12;
            }
            
            // Draw connection line
            canvasCtx.strokeStyle = lineColor;
            canvasCtx.lineWidth = 2;
            canvasCtx.beginPath();
            canvasCtx.moveTo(thumbTip.x * canvasElement.width, thumbTip.y * canvasElement.height);
            canvasCtx.lineTo(indexTip.x * canvasElement.width, indexTip.y * canvasElement.height);
            canvasCtx.stroke();
            
            // Draw finger dots
            [thumbTip, indexTip].forEach(tip => {
                // Outer glow
                canvasCtx.fillStyle = dotColor;
                canvasCtx.globalAlpha = 0.3;
                canvasCtx.beginPath();
                canvasCtx.arc(tip.x * canvasElement.width, tip.y * canvasElement.height, dotSize + 4, 0, 2 * Math.PI);
                canvasCtx.fill();

                // Inner dot
                canvasCtx.globalAlpha = 1;
                canvasCtx.fillStyle = dotColor;
                canvasCtx.beginPath();
                canvasCtx.arc(tip.x * canvasElement.width, tip.y * canvasElement.height, dotSize, 0, 2 * Math.PI);
                canvasCtx.fill();
            });
            
            canvasCtx.shadowBlur = 0;
        }

        // Advanced finger tap processing
        function processFingerTapAdvanced(landmarks, imageWidth, imageHeight) {
            const currentTime = Date.now() - startTime;
            
            const thumbTip = landmarks[THUMB_TIP];
            const indexTip = landmarks[INDEX_TIP];
            const wrist = landmarks[WRIST];
            const middleMcp = landmarks[MIDDLE_MCP];
            
            const handSize = Math.sqrt(
                Math.pow((wrist.x - middleMcp.x) * imageWidth, 2) +
                Math.pow((wrist.y - middleMcp.y) * imageHeight, 2)
            );
            
            const distance = Math.sqrt(
                Math.pow((thumbTip.x - indexTip.x) * imageWidth, 2) +
                Math.pow((thumbTip.y - indexTip.y) * imageHeight, 2) +
                Math.pow((thumbTip.z - indexTip.z) * imageWidth * 0.5, 2)
            );
            
            const normalizedDistance = (distance / handSize) * 100;
            
            // Always maintain full signal accuracy
            distanceSignal.push(normalizedDistance);
            timeSignal.push(currentTime);

            // CRITICAL: Add performance monitoring for iPad
            if (frameCount % 30 === 0) {
                console.log(`iPad Performance Check - Frame ${frameCount}: ${tapEvents.length} taps detected, Signal length: ${distanceSignal.length}`);
            }
            // Don't update live metrics here - it's done in onHandsResults

            // Feedback for tap width
            if (recording) {
                const tapWidthFeedback = document.getElementById('tapWidthFeedback');
                const tapWidthMessage = document.getElementById('tapWidthMessage');
                
                const recentSamples = distanceSignal.slice(-30);
                const maxRecentAmplitude = Math.max(...recentSamples);
                
                if (!window.tapFeedbackTimer) {
                    window.tapFeedbackTimer = 0;
                }
                
                if (maxRecentAmplitude < 45) {
                    tapWidthFeedback.style.display = 'block';
                    tapWidthMessage.textContent = 'Open fingers wider';
                    window.tapFeedbackTimer = 45;
                } else if (window.tapFeedbackTimer > 0) {
                    window.tapFeedbackTimer--;
                } else {
                    tapWidthFeedback.style.display = 'none';
                }
            }
                        
// SigPROCESS EVERY FRAME for maximum accuracy on iPad
            if (distanceSignal.length > SMOOTHING_WINDOW) {
                smoothedSignal = movingAverage(distanceSignal, SMOOTHING_WINDOW);
                
                if (smoothedSignal.length > 1) {
                    velocitySignal = calculateDerivative(smoothedSignal, timeSignal);
                }
                
                detectTapsMultiMethod();


            }
  

            // Ensure frameData is always an array
            frameData = frameData || [];
            frameData.push({
                timestamp: currentTime,
                normalizedDistance: normalizedDistance,
                thumbIndexAngle: Math.atan2(
                    (indexTip.y - thumbTip.y),
                    (indexTip.x - thumbTip.x)
                ) * 180 / Math.PI,
                handSize: handSize,
                thumbTip: { x: thumbTip.x, y: thumbTip.y, z: thumbTip.z },
                indexTip: { x: indexTip.x, y: indexTip.y, z: indexTip.z },
                wrist: { x: wrist.x, y: wrist.y, z: wrist.z },
                middleMcp: { x: middleMcp.x, y: middleMcp.y, z: middleMcp.z },
                rawLandmarks: landmarks.map(lm => ({ x: lm.x, y: lm.y, z: lm.z }))
            });
        }

                // iPad-optimized finger tap processing - maintains full accuracy
        function processFingerTapAdvancedIPad(landmarks, imageWidth, imageHeight) {
            const currentTime = Date.now() - startTime;
        
            const thumbTip = landmarks[THUMB_TIP];
            const indexTip = landmarks[INDEX_TIP];
            const wrist = landmarks[WRIST];
            const middleMcp = landmarks[MIDDLE_MCP];
        
            const handSize = Math.sqrt(
                Math.pow((wrist.x - middleMcp.x) * imageWidth, 2) +
                Math.pow((wrist.y - middleMcp.y) * imageHeight, 2)
            );
        
            const distance = Math.sqrt(
                Math.pow((thumbTip.x - indexTip.x) * imageWidth, 2) +
                Math.pow((thumbTip.y - indexTip.y) * imageHeight, 2) +
                Math.pow((thumbTip.z - indexTip.z) * imageWidth * 0.5, 2)
            );
        
            const normalizedDistance = (distance / handSize) * 100;
        
            // Always maintain full signal accuracy
            distanceSignal.push(normalizedDistance);
            timeSignal.push(currentTime);
        
            // Optimized feedback for iPad - reduce DOM updates
            if (recording && frameCount % 3 === 0) {
                const tapWidthFeedback = document.getElementById('tapWidthFeedback');
                const tapWidthMessage = document.getElementById('tapWidthMessage');
        
                const recentSamples = distanceSignal.slice(-30);
                const maxRecentAmplitude = Math.max(...recentSamples);
        
                if (!window.tapFeedbackTimer) {
                    window.tapFeedbackTimer = 0;
                }
        
                if (maxRecentAmplitude < 45) {
                    tapWidthFeedback.style.display = 'block';
                    tapWidthMessage.textContent = 'Open fingers wider';
                    window.tapFeedbackTimer = 45;
                } else if (window.tapFeedbackTimer > 0) {
                    window.tapFeedbackTimer--;
                } else {
                    tapWidthFeedback.style.display = 'none';
                }
            }
        
            // Process EVERY frame for iPad - no skipping
            if (distanceSignal.length > SMOOTHING_WINDOW) {
                smoothedSignal = movingAverage(distanceSignal, SMOOTHING_WINDOW);
        
                if (smoothedSignal.length > 1) {
                    velocitySignal = calculateDerivative(smoothedSignal, timeSignal);
                    // IMPORTANT: use the iPad-specific detector
                    detectTapsMultiMethodIPad();
                }
            }
        
            // Store essential frame data only (iPad optimization)
            const essentialFrameData = {
                timestamp: currentTime,
                normalizedDistance: normalizedDistance,
                thumbIndexAngle: Math.atan2(
                    (indexTip.y - thumbTip.y),
                    (indexTip.x - thumbTip.x)
                ) * 180 / Math.PI,
                handSize: handSize,
                thumbTip: { x: thumbTip.x, y: thumbTip.y, z: thumbTip.z },
                indexTip: { x: indexTip.x, y: indexTip.y, z: indexTip.z },
                wrist: { x: wrist.x, y: wrist.y, z: wrist.z },
                middleMcp: { x: middleMcp.x, y: middleMcp.y, z: middleMcp.z },
                rawLandmarks: [
                    landmarks[WRIST], landmarks[THUMB_TIP],
                    landmarks[INDEX_TIP], landmarks[MIDDLE_MCP]
                ].map(lm => ({ x: lm.x, y: lm.y, z: lm.z }))
            };
        
            frameData = frameData || [];
            frameData.push(essentialFrameData);
        }
        


                        // iPad-specific tap detection with more aggressive thresholds
              // iPad-specific tap detection with instantaneous detection
        function detectTapsMultiMethodIPad() {
            const rawEvents = [];
            const added = new Set();
        
            // STATE MACHINE: track closing/opening
            let lastState = 'unknown';
            let stateChangeIndices = [];
        
            for (let i = 1; i < distanceSignal.length; i++) {
                const current = distanceSignal[i];
                const prev = distanceSignal[i - 1];
                const delta = current - prev;
        
                let currentState = 'stable';
                if (delta < -3) currentState = 'closing';
                else if (delta > 3) currentState = 'opening';
        
                if (currentState !== lastState && currentState === 'closing') {
                    stateChangeIndices.push({
                        index: i,
                        type: 'close_start',
                        distance: current
                    });
                }
                lastState = currentState;
            }
        
            // Strategy 1: any significant closing movement
            for (const change of stateChangeIndices) {
                if (change.type === 'close_start') {
                    const time = timeSignal[change.index];
                    const lastEventTime = rawEvents.length > 0 ? rawEvents[rawEvents.length - 1].time : -1000;
                    if (time - lastEventTime > 30) {
                        rawEvents.push({
                            index: change.index,
                            time,
                            amplitude: change.distance,
                            type: 'state_change'
                        });
                        added.add(change.index);
                    }
                }
            }
        
            // Strategy 2: local minima (closest positions)
            for (let i = 2; i < distanceSignal.length - 2; i++) {
                const current = distanceSignal[i];
                const isLocalMin = current < distanceSignal[i - 1] &&
                                   current < distanceSignal[i - 2] &&
                                   current <= distanceSignal[i + 1] &&
                                   current <= distanceSignal[i + 2];
        
                if (isLocalMin && current < 50 && !added.has(i)) {
                    const time = timeSignal[i];
                    const lastEventTime = rawEvents.length > 0 ? rawEvents[rawEvents.length - 1].time : -1000;
                    if (time - lastEventTime > 30) {
                        rawEvents.push({
                            index: i,
                            time,
                            amplitude: current,
                            type: 'local_min'
                        });
                        added.add(i);
                    }
                }
            }
        
            // Strategy 3: velocity zero-crossing (neg -> ~0/+)
            if (velocitySignal.length > 2) {
                for (let i = 1; i < velocitySignal.length - 1; i++) {
                    const prevVel = velocitySignal[i - 1];
                    const currVel = velocitySignal[i];
                    const crossingPoint = prevVel < -0.5 && currVel >= -0.5 && currVel <= 0.5;
                    const atMinimum = distanceSignal[i] < 55;
        
                    if (crossingPoint && atMinimum && !added.has(i)) {
                        const time = timeSignal[i];
                        const lastEventTime = rawEvents.length > 0 ? rawEvents[rawEvents.length - 1].time : -1000;
                        if (time - lastEventTime > 30) {
                            rawEvents.push({
                                index: i,
                                time,
                                amplitude: distanceSignal[i],
                                type: 'velocity_cross'
                            });
                            added.add(i);
                        }
                    }
                }
            }
        
            // Strategy 4: rhythmic prediction (if taps are periodic)
            if (distanceSignal.length > 10 && rawEvents.length > 2) {
                const recentEvents = rawEvents.slice(-5);
                const intervals = [];
                for (let i = 1; i < recentEvents.length; i++) {
                    intervals.push(recentEvents[i].time - recentEvents[i - 1].time);
                }
                const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
                const lastEvent = rawEvents[rawEvents.length - 1];
                const predictedTime = lastEvent.time + avgInterval;
        
                for (let i = lastEvent.index + 1; i < distanceSignal.length; i++) {
                    const time = timeSignal[i];
                    const timeDiff = Math.abs(time - predictedTime);
        
                    if (timeDiff < avgInterval * 0.3 && distanceSignal[i] < 50 && !added.has(i)) {
                        // validate as local min in small window
                        const windowStart = Math.max(0, i - 2);
                        const windowEnd = Math.min(distanceSignal.length - 1, i + 2);
                        let isLocalMinInWindow = true;
                        for (let j = windowStart; j <= windowEnd; j++) {
                            if (j !== i && distanceSignal[j] < distanceSignal[i]) {
                                isLocalMinInWindow = false;
                                break;
                            }
                        }
                        if (isLocalMinInWindow) {
                            rawEvents.push({
                                index: i,
                                time,
                                amplitude: distanceSignal[i],
                                type: 'predicted'
                            });
                            added.add(i);
                            break;
                        }
                    }
                }
            }
        
            // Sort and enforce minimal spacing (30 ms)
            rawEvents.sort((a, b) => a.time - b.time);
            tapEvents = [];
            for (const ev of rawEvents) {
                if (tapEvents.length === 0 || ev.time - tapEvents[tapEvents.length - 1].time >= 30) {
                    tapEvents.push(ev);
                }
            }
        
            // Live update
            if (recording) {
                document.getElementById('taps-display').textContent = `${tapEvents.length}`;
            }
        
            // Optional debug
            if (frameCount % 30 === 0 && tapEvents.length > 0) {
                const tapsPerSecond = tapEvents.length / ((timeSignal[timeSignal.length - 1] || 1000) / 1000);
                console.log(`iPad Detection: ${tapEvents.length} taps, ${tapsPerSecond.toFixed(1)} taps/sec`);
            }
        }
        
        // iPad-optimized visualization - maintains visual quality but improves performance
        function drawHandVisualizationIPad(landmarks, canvasElement) {
            const thumbTip = landmarks[THUMB_TIP];
            const indexTip = landmarks[INDEX_TIP];
            const distance = Math.sqrt(
                Math.pow((thumbTip.x - indexTip.x) * canvasElement.width, 2) +
                Math.pow((thumbTip.y - indexTip.y) * canvasElement.height, 2)
            );
            
            const isTapping = recording && distance < 30;
            
            let justTapped = false;
            if (recording && tapEvents.length > 0) {
                const currentTime = Date.now() - startTime;
                const lastTap = tapEvents[tapEvents.length - 1];
                justTapped = (currentTime - lastTap.time) < 150;
            }
            
            // Simplified colors for iPad - no expensive effects
            let dotColor = '#ffffff';
            let lineColor = 'rgba(255, 255, 255, 0.5)';
            let dotSize = 10;
            
            if (justTapped) {
                dotColor = '#22c55e';
                lineColor = 'rgba(34, 197, 94, 1)';
                dotSize = 14;
                // Skip expensive shadow effects on iPad
            } else if (isTapping) {
                dotColor = '#16a34a';
                lineColor = 'rgba(22, 163, 74, 0.8)';
                dotSize = 12;
            }
            
            // Draw connection line
            canvasCtx.strokeStyle = lineColor;
            canvasCtx.lineWidth = 2;
            canvasCtx.beginPath();
            canvasCtx.moveTo(thumbTip.x * canvasElement.width, thumbTip.y * canvasElement.height);
            canvasCtx.lineTo(indexTip.x * canvasElement.width, indexTip.y * canvasElement.height);
            canvasCtx.stroke();
            
            // Draw finger dots - simplified for iPad
            [thumbTip, indexTip].forEach(tip => {
                // Skip outer glow on iPad for performance
                canvasCtx.globalAlpha = 1;
                canvasCtx.fillStyle = dotColor;
                canvasCtx.beginPath();
                canvasCtx.arc(tip.x * canvasElement.width, tip.y * canvasElement.height, dotSize, 0, 2 * Math.PI);
                canvasCtx.fill();
            });
        }

        function updateLiveMetrics() {
            const currentTime = Date.now() - startTime;
            const remaining = Math.max(0, (recordingDuration - currentTime) / 1000);
            const minutes = Math.floor(remaining / 60);
            const seconds = Math.floor(remaining % 60) + 1;
            const timerText = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            document.getElementById('center-timer').textContent = timerText;
            
            // Update taps count (just the number)
            document.getElementById('taps-display').textContent = `${tapEvents.length}`;
        }

        // Multi-method tap detection
        function detectTapsMultiMethod() {
            const rawEvents = [];
            const added = new Set();

            detectTapsFromVelocity(velocitySignal, smoothedSignal).forEach(ev => {
                if (!added.has(ev.index)) { rawEvents.push(ev); added.add(ev.index); }
            });

            const inverted = smoothedSignal.map(d => 100 - d);
            findPeaks(inverted, 0.5).forEach(idx => {
                if (smoothedSignal[idx] < CLOSED_THRESHOLD_PCT && !added.has(idx)) {
                    rawEvents.push({ index: idx, time: timeSignal[idx], amplitude: smoothedSignal[idx] });
                    added.add(idx);
                }
            });

            rawEvents.sort((a, b) => a.time - b.time);
            tapEvents = [];

            for (const ev of rawEvents) {
                if (tapEvents.length === 0) {
                    tapEvents.push(ev);
                    continue;
                }

                const last = tapEvents[tapEvents.length - 1];

                if (ev.time - last.time < MIN_PEAK_DISTANCE) continue;

                let reopened = false;
                for (let i = last.index + 1; i < ev.index; i++) {
                    if (smoothedSignal[i] > OPEN_THRESHOLD_PCT) { reopened = true; break; }
                }
                if (!reopened) continue;

                tapEvents.push(ev);
            }
        }

                // Start recording
         // REPLACE YOUR startRecording function with this version:
        function startRecording() {
            // FIXED: Mobile-specific validation without alerts that freeze camera
            if (window.innerWidth <= 768) {
                // On mobile, start countdown immediately if hand is detected
                if (!handDetected) {
                    // Instead of alert, show visual feedback
                    const positionStatus = document.getElementById('position-status');
                    positionStatus.textContent = 'Show your hand to camera';
                    positionStatus.className = 'position-status error';
                    return;
                }
            } else {
                // Desktop validation (unchanged)
                if (!handDetected) {
                    alert('Please position your hand in view of the camera before starting.');
                    return;
                }
        
                if (!window.handPositionCorrect) {
                    alert('Please position your hand correctly with fingers open before starting.');
                    return;
                }
        
                if (!isCorrectHandDetectedForCurrentTrial()) {
                    const required = trialConditions[trialIndex % trialConditions.length].hand.toUpperCase();
                    alert(`Please show your ${required} hand before starting.`);
                    return;
                }
            }
        
            if (trialIndex >= totalTrials) {
                if (window.innerWidth <= 768) {
                    const positionStatus = document.getElementById('position-status');
                    positionStatus.textContent = 'All trials complete!';
                    return;
                } else {
                    alert('All trials complete!');
                    return;
                }
            }
        
            // Reset data
            distanceSignal = [];
            timeSignal = [];
            smoothedSignal = [];
            velocitySignal = [];
            tapEvents = [];
            frameCount = 0;
            frameData = [];

                        // Ensure any previous countdown is cleared
            if (countdownInterval) {
              clearInterval(countdownInterval);
              countdownInterval = null;
            }
            
            
                    
            // Start countdown
            let countdown = 3;
            const countdownEl = document.getElementById('countdown');
            countdownEl.style.display = 'block';
            countdownEl.textContent = countdown;
        
            countdownInterval = setInterval(() => {
                // FIXED: More lenient countdown checks for mobile
                if (window.innerWidth <= 768) {
                    // On mobile, only check if hand is still detected
                    if (!handDetected) {
                        clearInterval(countdownInterval);
                        countdownEl.style.display = 'none';
                        const positionStatus = document.getElementById('position-status');
                        positionStatus.textContent = 'Hand lost - try again';
                        positionStatus.className = 'position-status error';
                        return;
                    }
                } else {
                    // Desktop checks (unchanged)
                    if (!handDetected || !isCorrectHandDetectedForCurrentTrial()) {
                        clearInterval(countdownInterval);
                        countdownEl.style.display = 'none';
                        window.handPositionCorrect = false;
                        return;
                    }
                }
                
                countdown--;
                if (countdown > 0) {
                    countdownEl.textContent = countdown;
                    countdownEl.style.animation = 'none';
                    setTimeout(() => {
                        countdownEl.style.animation = 'countdownPulse 1s ease-in-out';
                    }, 10);
                } else {
                    clearInterval(countdownInterval);
                    countdownEl.style.display = 'none';
                    startActualRecording();
                }
            }, 1000);
        }


 function startActualRecording() {
    // Invalidate any older trial’s callbacks
    currentTrialToken++;
    const myToken = currentTrialToken;
    activeTrialToken = myToken;

    readyToStart = false;
    preStartTapCount = 0;
    lastPreStartTapTime = 0;

    // Clear pre-start detection arrays
    window.preStartDistanceSignal = [];
    window.preStartTimeSignal = [];

    document.getElementById('hand-guide-overlay').style.display = 'none';
    document.getElementById('hand-outline').style.display = 'none';

    recording = true;
    const centerTimer = document.getElementById('center-timer');
    if (centerTimer) { centerTimer.style.display = 'block'; }



    // Reset ALL timing/data for a clean slate
    startTime = Date.now();
    lastHandSeenTime = Date.now();
    lastTapTime = 0;

    distanceSignal = [];
    timeSignal = [];
    smoothedSignal = [];
    velocitySignal = [];
    tapEvents = [];
    frameCount = 0;
    frameData = [];

    // Kill any previous timers from prior trials
    if (mainTimerInterval) { clearInterval(mainTimerInterval); mainTimerInterval = null; }
    if (inactivityInterval) { clearInterval(inactivityInterval); inactivityInterval = null; }
    if (stopTimeoutId) { clearTimeout(stopTimeoutId); stopTimeoutId = null; }
    if (countdownInterval) { clearInterval(countdownInterval); countdownInterval = null; }

    // Main UI timer (checks token so only this trial can update/stop)
    mainTimerInterval = setInterval(() => {
        // If this callback belongs to an old trial, stop it
        if (myToken !== activeTrialToken) {
            clearInterval(mainTimerInterval);
            mainTimerInterval = null;
            return;
        }

        const currentTime = Date.now() - startTime;
        const remaining = Math.max(0, (recordingDuration - currentTime) / 1000);

        // Hand-loss window
        if (!handDetected) {
            const timeSinceLastSeen = Date.now() - lastHandSeenTime;
            if (timeSinceLastSeen > MAX_ALLOWED_HAND_LOSS) {
                // This will clear timers and invalidate tokens
                restartTrialDueToHandLoss();
                return;
            }
        } else {
            lastHandSeenTime = Date.now();
        }

        const minutes = Math.floor(remaining / 60);
        const seconds = Math.max(1, Math.ceil(remaining % 60));
        const timerText = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        document.getElementById('center-timer').textContent = timerText;
        document.getElementById('taps-display').textContent = `${tapEvents.length}`;

        if (currentTime >= recordingDuration) {
            stopRecording(); // stopRecording() guards against token drift + recording flag
        }
    }, 100);

    // Single inactivity checker for this trial
    inactivityInterval = setInterval(() => {
        // If this callback belongs to an old trial, clean up and exit
        if (myToken !== activeTrialToken || !recording) {
            clearInterval(inactivityInterval);
            inactivityInterval = null;
            return;
        }

        const nowMs = Date.now() - startTime;

        // No taps at all for the first window
        if (nowMs > MAX_ALLOWED_NO_TAPS && tapEvents.length === 0) {
            clearInterval(inactivityInterval);
            inactivityInterval = null;
            restartTrialDueToInactivity();
            return;
        }

        if (tapEvents.length > 0) {
            const lastTapTimestamp = tapEvents[tapEvents.length - 1].time;
            const timeSinceLastTap = nowMs - lastTapTimestamp;
            if (timeSinceLastTap > MAX_ALLOWED_NO_TAPS) {
                clearInterval(inactivityInterval);
                inactivityInterval = null;
                restartTrialDueToInactivity();
                return;
            }
        }
    }, 500);

    // Single definitive stop timeout for this trial (guards by token)
    stopTimeoutId = setTimeout(() => {
        if (recording && myToken === activeTrialToken) {
            stopRecording();
        }
    }, recordingDuration);
}


function stopRecording() {
    // If already not recording, ignore
    if (!recording) return;

    recording = false;
    const centerTimer = document.getElementById('center-timer');
    if (centerTimer) { centerTimer.style.display = 'none'; }



    // Clear ALL timers/handles that could still be alive
    if (mainTimerInterval) { clearInterval(mainTimerInterval); mainTimerInterval = null; }
    if (inactivityInterval) { clearInterval(inactivityInterval); inactivityInterval = null; }
    if (stopTimeoutId) { clearTimeout(stopTimeoutId); stopTimeoutId = null; }
    if (countdownInterval) { clearInterval(countdownInterval); countdownInterval = null; }

    document.getElementById('tapWidthFeedback').style.display = 'none';
    window.tapFeedbackTimer = 0;
    window.handPositionCorrect = false;

    document.getElementById('countdown').style.display = 'none';

    // Show position status again
    document.getElementById('hand-guide-overlay').style.display = 'block';
    document.getElementById('hand-outline').style.display = 'block';

    const positionStatus = document.getElementById('position-status');
    positionStatus.textContent = 'Analyzing results...';
    positionStatus.className = 'position-status warning';

    // Check if minimum taps were achieved
    if (tapEvents.length < MIN_REQUIRED_TAPS) {
        showInsufficientTapsRestart();
        return;
    }

    const result = calculateClinicalAssessment();
    const trialDocName = `trial_${trialIndex + 1}`;

    // REDUCED: Save only essential data to avoid 1MB limit
    const essentialFrameData = frameData.map(f => ({
        t: f.timestamp,
        normDist: f.normalizedDistance,
        angle: f.thumbIndexAngle,
        handSize: f.handSize,
        thumb: f.thumbTip,
        index: f.indexTip,
        wrist: f.wrist
    }));

    db.collection("Participants")
      .doc(participantID)
      .collection("Trials")
      .doc(trialDocName)
      .set({
          trialNumber: trialIndex + 1,
          condition: trialConditions[trialIndex % trialConditions.length],
          timestamp: new Date().toISOString(),
          rawFrames: essentialFrameData,
          totalFramesRecorded: frameData.length
      })
      .then(() => console.log(`✅ Essential trial data saved for ${participantID} / ${trialDocName}`))
      .catch(err => console.error("❌ Error saving essential trial data:", err));

    // Save detailed landmarks separately (non-blocking)
    saveLandmarkDataAsync(participantID, trialIndex + 1, trialConditions[trialIndex % trialConditions.length], frameData);

    totalTapsAcrossAllTrials += tapEvents.length;

    allTrialResults.push({
        condition: trialConditions[trialIndex % trialConditions.length],
        repetition: Math.floor(trialIndex / trialConditions.length) + 1,
        result: result
    });

    trialIndex++;

    if (trialIndex < totalTrials) {
        positionStatus.textContent = 'Ready for next trial';
        positionStatus.className = 'position-status ready';

        // Prepare auto-start for next trial
        readyToStart = true;
        preStartTapCount = 0;
        lastPreStartTapTime = 0;

        updateConditionUI();
    } else {
        analyzeAllTrials();
    }
}


// FIXED: Optimized batch saving with fewer landmarks and grouped frames
async function saveLandmarkDataAsync(participantID, trialNumber, condition, frameData) {
    console.log(`💾 Starting optimized batch save of ${frameData.length} frames`);
    
    // Don't block the UI - run this in background
    setTimeout(async () => {
        try {
            // Group frames into batches of 30 frames (1 second of data at 30fps)
            const FRAMES_PER_BATCH = 30;
            const totalFrames = frameData.length;
            let savedBatches = 0;
            
            for (let batchStart = 0; batchStart < totalFrames; batchStart += FRAMES_PER_BATCH) {
                const batchEnd = Math.min(batchStart + FRAMES_PER_BATCH, totalFrames);
                const batchFrames = frameData.slice(batchStart, batchEnd);
                
                // Create one document per batch instead of per frame
                const batchDocId = `${participantID}_trial${trialNumber}_batch${Math.floor(batchStart / FRAMES_PER_BATCH)}`;
                
                // Prepare batch data - only the 4 essential landmarks
                const batchDocument = {
                    participantID: participantID,
                    trialID: `trial_${trialNumber}`,
                    trialNumber: trialNumber,
                    batchIndex: Math.floor(batchStart / FRAMES_PER_BATCH),
                    condition_hand: condition.hand,
                    frameStartIndex: batchStart,
                    frameEndIndex: batchEnd - 1,
                    frameCount: batchFrames.length,
                    
                    // Arrays for each measurement across all frames in this batch
                    timestamps: [],
                    normalizedDistances: [],
                    thumbIndexAngles: [],
                    handSizes: [],
                    
                    // Only the 4 essential landmarks as arrays
                    wrist_x: [], wrist_y: [], wrist_z: [],
                    thumbTip_x: [], thumbTip_y: [], thumbTip_z: [],
                    indexTip_x: [], indexTip_y: [], indexTip_z: [],
                    middleMcp_x: [], middleMcp_y: [], middleMcp_z: []
                };
                
                // Fill arrays with data from all frames in this batch
                batchFrames.forEach((frame, frameIndex) => {
                    batchDocument.timestamps.push(frame.timestamp);
                    batchDocument.normalizedDistances.push(frame.normalizedDistance);
                    batchDocument.thumbIndexAngles.push(frame.thumbIndexAngle);
                    batchDocument.handSizes.push(frame.handSize);
                    
                    // Only store the 4 essential landmarks
                    if (frame.rawLandmarks && Array.isArray(frame.rawLandmarks)) {
                        // WRIST (landmark 0)
                        const wrist = frame.rawLandmarks[0] || {};
                        batchDocument.wrist_x.push(wrist.x || 0);
                        batchDocument.wrist_y.push(wrist.y || 0);
                        batchDocument.wrist_z.push(wrist.z || 0);
                        
                        // THUMB_TIP (landmark 4)
                        const thumbTip = frame.rawLandmarks[4] || {};
                        batchDocument.thumbTip_x.push(thumbTip.x || 0);
                        batchDocument.thumbTip_y.push(thumbTip.y || 0);
                        batchDocument.thumbTip_z.push(thumbTip.z || 0);
                        
                        // INDEX_TIP (landmark 8)
                        const indexTip = frame.rawLandmarks[8] || {};
                        batchDocument.indexTip_x.push(indexTip.x || 0);
                        batchDocument.indexTip_y.push(indexTip.y || 0);
                        batchDocument.indexTip_z.push(indexTip.z || 0);
                        
                        // MIDDLE_MCP (landmark 9)
                        const middleMcp = frame.rawLandmarks[9] || {};
                        batchDocument.middleMcp_x.push(middleMcp.x || 0);
                        batchDocument.middleMcp_y.push(middleMcp.y || 0);
                        batchDocument.middleMcp_z.push(middleMcp.z || 0);
                    } else {
                        // Fill with zeros if no landmark data
                        ['wrist_x', 'wrist_y', 'wrist_z', 
                         'thumbTip_x', 'thumbTip_y', 'thumbTip_z',
                         'indexTip_x', 'indexTip_y', 'indexTip_z',
                         'middleMcp_x', 'middleMcp_y', 'middleMcp_z'].forEach(key => {
                            batchDocument[key].push(0);
                        });
                    }
                });
                
                // Save batch with retry logic
                let retries = 3;
                while (retries > 0) {
                    try {
                        await db.collection("LandmarkBatches").doc(batchDocId).set(batchDocument);
                        savedBatches++;
                        console.log(`✅ Saved batch ${savedBatches} (frames ${batchStart}-${batchEnd-1})`);
                        break;
                    } catch (error) {
                        retries--;
                        console.warn(`⚠️ Batch save failed, ${retries} retries left:`, error.message);
                        if (retries === 0) {
                            console.error(`❌ Failed to save batch after all retries`);
                        } else {
                            // Wait before retry
                            await new Promise(resolve => setTimeout(resolve, 1000 * (4 - retries)));
                        }
                    }
                }
                
                // Small delay between batches to avoid overwhelming Firebase
                if (batchEnd < totalFrames) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
            }
            
            console.log(`✅ Optimized landmark saving complete: ${savedBatches} batches saved`);
            
        } catch (error) {
            console.error(`❌ Error in optimized landmark saving:`, error);
        }
    }, 100);
}

// FIXED: Make questionnaire submission more robust
// Update your existing questionnaire form submission handler with this:
document.getElementById('questionnaire-form').addEventListener('submit', function(e) {
    e.preventDefault();
    
    const formData = new FormData(this);
    const responses = {};
    
    // Collect all form data
    for (let [key, value] of formData.entries()) {
        responses[key] = value;
    }
    
    console.log("📋 Questionnaire responses to save:", responses);
    
    const expectedFields = [
        'videogame', 'musical', 'sports', 'caffeine', 
        'mood', 'motivated', 'distracted', 'performance',
        'neurological', 'handPain', 'handInjuryHistory', 'persistence', 'attention', 'competition', 'income', 'zipcode'
    ];
    
    const missingFields = expectedFields.filter(field => !responses[field]);
    if (missingFields.length > 0) {
        console.warn("⚠️ Missing required fields:", missingFields);
        alert(`Please complete all required fields: ${missingFields.join(', ')}`);
        return;
    }
    
    const questionnaireData = {
        experienceRatings: {
            videogameExperience: parseInt(responses.videogame),
            musicalExperience: parseInt(responses.musical),
            sportsExperience: parseInt(responses.sports),
            caffeineIntakeToday: parseInt(responses.caffeine)
        },
        moodPerformanceRatings: {
            currentMood: parseInt(responses.mood),
            taskMotivation: parseInt(responses.motivated),
            taskDistraction: parseInt(responses.distracted),
                persistenceWhenFrustrated: parseInt(responses.persistence),
                attentionSpanGeneral: parseInt(responses.attention),
                enjoymentOfCompetition: parseInt(responses.competition)
        },
        demographics: {
            hasNeurologicalConditions: responses.neurological === 'yes',
            hasHandPain: responses.handPain === 'yes',
            hasHandInjuryHistory: responses.handInjuryHistory === 'yes',
            householdIncome: responses.income,
            zipCode: responses.zipcode
        },
        feedback: responses.feedback || '',
        completedAt: new Date().toISOString(),
        participantID: sessionStorage.getItem('prolificID') || 'anonymous'
    };
    
    console.log("💾 Structured questionnaire data:", questionnaireData);
    
    const participantID = sessionStorage.getItem('prolificID') || 'anonymous';
    
    // FIXED: Use more robust saving with better error handling
    const savePromises = [];
    
    // Save to multiple locations with individual error handling
    savePromises.push(
        db.collection("Results")
        .doc(participantID)
        .collection("Questionnaire")
        .doc("Responses")
        .set(questionnaireData)
        .catch(err => {
            console.warn("Failed to save to Results collection:", err);
            return { error: err, location: "Results" };
        })
    );
    
    savePromises.push(
        db.collection("Participants")
        .doc(participantID)
        .collection("Questionnaire")
        .doc("Demographics")
        .set(questionnaireData)
        .catch(err => {
            console.warn("Failed to save to Participants collection:", err);
            return { error: err, location: "Participants" };
        })
    );
    
    savePromises.push(
        db.collection("QuestionnaireResponses")
        .doc(participantID)
        .set(questionnaireData)
        .catch(err => {
            console.warn("Failed to save to QuestionnaireResponses:", err);
            return { error: err, location: "QuestionnaireResponses" };
        })
    );
    
    // Wait for saves but don't let errors block the UI
    Promise.allSettled(savePromises)
        .then((results) => {
            let successCount = 0;
            results.forEach((result, index) => {
                if (result.status === 'fulfilled' && !result.value?.error) {
                    successCount++;
                } else {
                    console.warn(`Save ${index} failed:`, result.reason || result.value?.error);
                }
            });
            
            console.log(`✅ Questionnaire saved to ${successCount}/3 locations`);
            
            // Always proceed to results, even if some saves failed
            document.getElementById('questionnaire-overlay').style.display = 'none';
            showFinalResults();
        })
        .catch(err => {
            console.error("❌ Unexpected error in questionnaire saving:", err);
            // Still proceed to results - don't let saving errors block the user
            alert("Some data may not have been saved, but your results are ready.");
            document.getElementById('questionnaire-overlay').style.display = 'none';
            showFinalResults();
        });
});
        function restartTrialDueToHandLoss() {
                        // Invalidate any old callbacks and clear all timers
            activeTrialToken++; // any late timer from the previous trial becomes a no-op
            if (mainTimerInterval) { clearInterval(mainTimerInterval); mainTimerInterval = null; }
            if (inactivityInterval) { clearInterval(inactivityInterval); inactivityInterval = null; }
            if (stopTimeoutId) { clearTimeout(stopTimeoutId); stopTimeoutId = null; }
            if (countdownInterval) { clearInterval(countdownInterval); countdownInterval = null; }


            if (!recording) return;
            
            recording = false;
            
            // CRITICAL FIX: Clear all intervals and reset timing
            if (mainTimerInterval) {
                clearInterval(mainTimerInterval);
                mainTimerInterval = null;
            }
            
            // Reset ALL tracking variables completely
            lastHandSeenTime = 0;
            lastTapTime = 0;
            startTime = null;
            
            // Clear all data arrays
            distanceSignal = [];
            timeSignal = [];
            smoothedSignal = [];
            velocitySignal = [];
            tapEvents = [];
            frameCount = 0;
            frameData = [];
            
            // Reset UI
            document.getElementById('hand-guide-overlay').style.display = 'block';
            document.getElementById('hand-outline').style.display = 'block';
            document.getElementById('tapWidthFeedback').style.display = 'none';
            document.getElementById('countdown').style.display = 'none';
            
            // Show restart message
            const overlay = document.getElementById('trial-instructions-overlay');
            const instructionText = document.getElementById('trial-instructions-text');
            
            instructionText.innerHTML = `
                <div style="color: #f59e0b; font-size: 2.8rem; margin-bottom: 1rem;">Hand Lost</div>
                <div style="color: #1a1a1a; font-size: 1.8rem; font-weight: 400;">Please keep your hand clearly visible</div>
            `;
                                
            document.querySelector('.trial-overlay-instruction').innerHTML = 
                'Please keep your hand <strong>clearly visible</strong> throughout the test';
            
            overlay.style.display = 'flex';
            
            // Reset displays
            document.getElementById('center-timer').textContent = '00:10';
            document.getElementById('taps-display').textContent = '0';
            
            // Reset position status
            const positionStatus = document.getElementById('position-status');
            positionStatus.textContent = 'Position hand in view';
            positionStatus.className = 'position-status';
            readyToStart = true;
            preStartTapCount = 0;
            lastPreStartTapTime = 0;
            
            // Force initial feedback update
            setTimeout(() => {
                if (!handDetected) {
                    updateHandPositionFeedback(null);
                }
            }, 100);
        }

        function restartTrialDueToInactivity() {
            // Invalidate any old callbacks and clear all timers
            activeTrialToken++; // any late timer from the previous trial becomes a no-op
            if (mainTimerInterval) { clearInterval(mainTimerInterval); mainTimerInterval = null; }
            if (inactivityInterval) { clearInterval(inactivityInterval); inactivityInterval = null; }
            if (stopTimeoutId) { clearTimeout(stopTimeoutId); stopTimeoutId = null; }
            if (countdownInterval) { clearInterval(countdownInterval); countdownInterval = null; }
            

            if (!recording) return;
            
            recording = false;
            
            // CRITICAL FIX: Clear all intervals and reset timing
            if (mainTimerInterval) {
                clearInterval(mainTimerInterval);
                mainTimerInterval = null;
            }
            
            // Reset ALL tracking variables completely
            lastHandSeenTime = 0;
            lastTapTime = 0;
            startTime = null;
            
            // Clear all data arrays
            distanceSignal = [];
            timeSignal = [];
            smoothedSignal = [];
            velocitySignal = [];
            tapEvents = [];
            frameCount = 0;
            frameData = [];
            // Reset tracking var
            // Reset UI
            document.getElementById('hand-guide-overlay').style.display = 'block';
            document.getElementById('hand-outline').style.display = 'block';
            document.getElementById('tapWidthFeedback').style.display = 'none';
            document.getElementById('countdown').style.display = 'none';
            
            // Show restart message
            const overlay = document.getElementById('trial-instructions-overlay');
            const instructionText = document.getElementById('trial-instructions-text');
            
            instructionText.innerHTML = `
                <div style="color: #f59e0b; font-size: 2.8rem; margin-bottom: 1rem;">Trial Paused</div>
                <div style="color: #1a1a1a; font-size: 1.8rem; font-weight: 400;">Please continue tapping throughout the test</div>
            `;
            
            document.querySelector('.trial-overlay-instruction').innerHTML = 
                'Keep tapping your <strong>thumb and index finger</strong> consistently';
            
            overlay.style.display = 'flex';
            
            // Reset displays
            document.getElementById('center-timer').textContent = '00:10';
            document.getElementById('taps-display').textContent = '0';
            
            const positionStatus = document.getElementById('position-status');
            positionStatus.textContent = 'Position hand in view';
            positionStatus.className = 'position-status';
            readyToStart = true;
            preStartTapCount = 0;
        }

        function restartTrialDueToWrongHand() {
                        // Invalidate any old callbacks and clear all timers
            activeTrialToken++; // any late timer from the previous trial becomes a no-op
            if (mainTimerInterval) { clearInterval(mainTimerInterval); mainTimerInterval = null; }
            if (inactivityInterval) { clearInterval(inactivityInterval); inactivityInterval = null; }
            if (stopTimeoutId) { clearTimeout(stopTimeoutId); stopTimeoutId = null; }
            if (countdownInterval) { clearInterval(countdownInterval); countdownInterval = null; }
            

            if (!recording) return;
            
            recording = false;
            clearInterval(mainTimerInterval);
            
            // Reset UI
            document.getElementById('hand-guide-overlay').style.display = 'block';
            document.getElementById('hand-outline').style.display = 'block';
            document.getElementById('tapWidthFeedback').style.display = 'none';
            document.getElementById('countdown').style.display = 'none';
            
            // Show restart message
            const overlay = document.getElementById('trial-instructions-overlay');
            const instructionText = document.getElementById('trial-instructions-text');
            const requiredHand = trialConditions[trialIndex % trialConditions.length].hand.toUpperCase();
            
            instructionText.innerHTML = `
                <div style="color: #ef4444; font-size: 2.8rem; margin-bottom: 1rem;">Wrong Hand!</div>
                <div style="color: #1a1a1a; font-size: 1.8rem; font-weight: 400;">Please use your ${requiredHand} hand</div>
            `;
            
            document.querySelector('.trial-overlay-instruction').innerHTML = 
                `Please tap with your <strong>${requiredHand}</strong> hand only`;
            
            overlay.style.display = 'flex';
            
            // Reset displays
            document.getElementById('center-timer').textContent = '00:10';
            document.getElementById('taps-display').textContent = '0';
            
            // Reset position status
            const positionStatus = document.getElementById('position-status');
            positionStatus.textContent = 'Position hand in view';
            positionStatus.className = 'position-status';
            readyToStart = true;
            preStartTapCount = 0;
        }
        // Calculate clinical assessment (keeping original)
        function calculateClinicalAssessment() {
            const tapCount = tapEvents.length;
            const intervals = [];
            const amplitudes = [];
            
            for (let i = 1; i < tapEvents.length; i++) {
                intervals.push(tapEvents[i].time - tapEvents[i-1].time);
            }
            
            for (let i = 0; i < tapEvents.length - 1; i++) {
                const startIdx = tapEvents[i].index;
                const endIdx = tapEvents[i+1].index;
                let maxAmp = 0;
                for (let j = startIdx; j < endIdx && j < smoothedSignal.length; j++) {
                    maxAmp = Math.max(maxAmp, smoothedSignal[j]);
                }
                amplitudes.push(maxAmp);
            }
            
            const avgFrequency = intervals.length > 0 ? 1000 / (intervals.reduce((a, b) => a + b, 0) / intervals.length) : 0;
            const avgAmplitude = amplitudes.length > 0 ? amplitudes.reduce((a, b) => a + b, 0) / amplitudes.length : 0;
            
            let amplitudeDecrement = 0;
            if (amplitudes.length >= 3) {
                const firstThird = amplitudes.slice(0, Math.floor(amplitudes.length / 3));
                const lastThird = amplitudes.slice(-Math.floor(amplitudes.length / 3));
                const firstAvg = firstThird.reduce((a, b) => a + b, 0) / firstThird.length;
                const lastAvg = lastThird.reduce((a, b) => a + b, 0) / lastThird.length;
                amplitudeDecrement = ((firstAvg - lastAvg) / firstAvg) * 100;
            }
            
            let rhythmCV = 0;
            if (intervals.length > 0) {
                const mean = intervals.reduce((a, b) => a + b, 0) / intervals.length;
                const variance = intervals.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / intervals.length;
                rhythmCV = (Math.sqrt(variance) / mean) * 100;
            }
            
            const hesitations = intervals.filter(i => i > 500 && i < 1000).length;
            const freezing = intervals.filter(i => i >= 1000).length;
            const speedAmplitudeIndex = avgFrequency * (avgAmplitude / 100);
            
            let score = 0;
            let details = [];
            
            if (avgFrequency < 1.25) {
                score = Math.max(score, 3);
                details.push("Severe slowing (<1.25 Hz)");
            } else if (avgFrequency < 2.0) {
                score = Math.max(score, 2);
                details.push("Moderate slowing (1.25–2.0 Hz)");
            } else if (avgFrequency < 2.5) {
                score = Math.max(score, 1);
                details.push("Slight slowing (2.0–2.5 Hz)");
            }

            if (avgAmplitude < 20) {
                score = Math.max(score, 2);
                details.push("Small amplitude movements");
            }
            
            if (amplitudeDecrement > 50) {
                score = Math.max(score, 3);
                details.push("Severe amplitude decrement");
            } else if (amplitudeDecrement > 30) {
                score = Math.max(score, 2);
                details.push("Amplitude decrements midway");
            } else if (amplitudeDecrement > 15) {
                score = Math.max(score, 1);
                details.push("Amplitude decrements near the end");
            }

            if (freezing > 0) {
                score = Math.max(score, 3);
                details.push(`${freezing} freezing episode(s)`);
            } else if (hesitations >= 5) {
                score = Math.max(score, 3);
                details.push("More than 5 interruptions");
            } else if (hesitations >= 3) {
                score = Math.max(score, 2);
                details.push("3-5 interruptions");
            } else if (hesitations >= 1) {
                score = Math.max(score, 1);
                details.push("1-2 interruptions");
            }
            
            if (rhythmCV > 40) {
                score = Math.max(score, 2);
                details.push("Significant rhythm irregularity");
            } else if (rhythmCV > 25) {
                score = Math.max(score, 1);
                details.push("Mild rhythm irregularity");
            }
            
            return {
                score: score,
                details: details,
                metrics: {
                    tapCount: tapCount,
                    avgFrequency: avgFrequency,
                    avgAmplitude: avgAmplitude,
                    amplitudeDecrement: amplitudeDecrement,
                    rhythmCV: rhythmCV,
                    hesitations: hesitations,
                    freezing: freezing,
                    speedAmplitudeIndex: speedAmplitudeIndex,
                    testDuration: (timeSignal[timeSignal.length - 1] || 0) / 1000,
                    signalQuality: {
                        framesProcessed: frameCount,
                        samplingRate: frameCount / ((timeSignal[timeSignal.length - 1] || 1) / 1000),
                        detectionsConfidence: tapEvents.length / (frameCount / 30)
                    }
                }
            };
        }
        
        function showInsufficientTapsRestart() {
            // Invalidate any old callbacks and clear all timers
            activeTrialToken++; // any late timer from the previous trial becomes a no-op
            if (mainTimerInterval) { clearInterval(mainTimerInterval); mainTimerInterval = null; }
            if (inactivityInterval) { clearInterval(inactivityInterval); inactivityInterval = null; }
            if (stopTimeoutId) { clearTimeout(stopTimeoutId); stopTimeoutId = null; }
            if (countdownInterval) { clearInterval(countdownInterval); countdownInterval = null; }


            recording = false;
            
            // CRITICAL FIX: Clear all intervals and reset timing
            if (mainTimerInterval) {
                clearInterval(mainTimerInterval);
                mainTimerInterval = null;
            }
            
            // Reset ALL tracking variables completely
            lastHandSeenTime = 0;
            lastTapTime = 0;
            startTime = null;
            
            // Clear all data arrays
            distanceSignal = [];
            timeSignal = [];
            smoothedSignal = [];
            velocitySignal = [];
            tapEvents = [];
            frameCount = 0;
            frameData = [];
            
            // Rest of function unchanged...
            // Reset UI
            document.getElementById('hand-guide-overlay').style.display = 'block';
            document.getElementById('hand-outline').style.display = 'block';
            document.getElementById('tapWidthFeedback').style.display = 'none';
            document.getElementById('countdown').style.display = 'none';
            
            // Show restart message
            const overlay = document.getElementById('trial-instructions-overlay');
            const instructionText = document.getElementById('trial-instructions-text');
            
            instructionText.innerHTML = `
                <div style="color: #f59e0b; font-size: 2.8rem; margin-bottom: 1rem;">Too Few Taps</div>
                <div style="color: #1a1a1a; font-size: 1.8rem; font-weight: 400;">Please tap more frequently during the test</div>
            `;
            
            document.querySelector('.trial-overlay-instruction').innerHTML = 
                'Please tap your <strong>thumb and index finger</strong> continuously and rapidly';
            
            overlay.style.display = 'flex';
            
            // Reset displays
            document.getElementById('center-timer').textContent = '00:10';
            document.getElementById('taps-display').textContent = '0';
            
            // Reset position status
            const positionStatus = document.getElementById('position-status');
            positionStatus.textContent = 'Position hand in view';
            positionStatus.className = 'position-status';
            readyToStart = true;
            preStartTapCount = 0;
        }


        
  function updateConditionUI() {
    const trialNum = trialIndex + 1;
    const condition = trialConditions[trialIndex % trialConditions.length];
    const handText = condition.hand.charAt(0).toUpperCase() + condition.hand.slice(1);
    const total = totalTrials;
    
    // Reset all state variables
    window.handPositionCorrect = false;
    readyToStart = true;
    preStartTapCount = 0;
    lastPreStartTapTime = 0;
    
    // Initialize pre-start detection arrays
    window.preStartDistanceSignal = [];
    window.preStartTimeSignal = [];
      // Reset hand label smoothing each trial
    handLabelBuffer = [];
    currentDetectedHand = null;


    
    // Update layout based on hand
    if (condition.hand === 'left') {
        document.body.classList.add('layout-left-hand');
        document.body.classList.remove('layout-right-hand');
    } else {
        document.body.classList.add('layout-right-hand');
        document.body.classList.remove('layout-left-hand');
    }
    
    const handGuide = document.getElementById('hand-guide-overlay');
    handGuide.style.display = 'block';
    document.getElementById('hand-outline').style.display = 'block';
    
    const totalTapsDisplay = totalTapsAcrossAllTrials > 0 ? `<div style="font-size: 2.4rem; color: #22c55e; font-weight: 300; margin-bottom: 2rem; padding: 1.5rem; background: rgba(34, 197, 94, 0.08); border-radius: 16px; border: 1px solid rgba(34, 197, 94, 0.15); letter-spacing: -0.01em;">Total taps so far: <span style="font-weight: 700;">${totalTapsAcrossAllTrials}</span></div>` : '';
    const instructionHTML = `${totalTapsDisplay}Trial ${trialNum} of ${total}<br><span style="font-size: 1.8rem; margin-top: 1rem; display: block;">Use your <strong>${handText.toUpperCase()}</strong> hand</span>`;
    document.getElementById('trial-instructions-text').innerHTML = instructionHTML;
    document.getElementById('trial-instructions-overlay').style.display = 'flex';
    
    // Update begin instruction text based on device
    const beginInstruction = document.getElementById('begin-instruction');


    if (window.innerWidth <= 768 || isIPad()) {
        beginInstruction.textContent = 'Tap here to begin';
    } else {
        beginInstruction.textContent = 'Click to begin';
    }

      
    
    // Update elegant trial display
    document.getElementById('trial-number').textContent = `Trial ${trialNum} of ${total}`;
    document.getElementById('hand-instruction').textContent = `${handText} Hand`;
    
    // Reset displays
    document.getElementById('center-timer').textContent = '00:10';
    document.getElementById('taps-display').textContent = '0';
    
    const positionStatus = document.getElementById('position-status');
    positionStatus.textContent = 'Position hand in view';
    positionStatus.className = 'position-status';
  }
 function analyzeAllTrials() {
            showQuestionnaire();
}


function showFinalResults() {
    document.getElementById('finalResults').style.display = 'block';
    document.body.classList.add('results-page');
    
    let rightTrials = allTrialResults.filter(t => t.condition.hand === 'right');
    let leftTrials = allTrialResults.filter(t => t.condition.hand === 'left');

    const calculateAverage = (trials, metric) => {
        const values = trials.map(t => t.result.metrics[metric]);
        return values.reduce((a, b) => a + b, 0) / values.length;
    };
    
    const rightFastFreq = calculateAverage(rightTrials, 'avgFrequency');
    const leftFastFreq = calculateAverage(leftTrials, 'avgFrequency');
    const avgFastFreq = (rightFastFreq + leftFastFreq) / 2;

    const avgTapsPerTenSec = avgFastFreq * 10;
    const rightTapsPerRound = Math.round(calculateAverage(rightTrials, 'tapCount'));
    const leftTapsPerRound = Math.round(calculateAverage(leftTrials, 'tapCount'));
    
    // Check if participant came from Prolific
    const participantID = sessionStorage.getItem('prolificID') || '';
    const isFromProlific = participantID && !participantID.startsWith('anon_');
    const prolificCode = "CXXRL3ML";
    
    // Mobile-responsive results HTML
    const isMobile = window.innerWidth <= 768;
    
    let html = `
        <div style="max-width: 1000px; margin: 0 auto; padding: ${isMobile ? '2rem 1rem' : '3rem 3rem'}; text-align: center; font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif; min-height: 100vh; display: flex; flex-direction: column;">
            <div style="margin-bottom: ${isMobile ? '3rem' : '4rem'};">
                <p style="font-size: ${isMobile ? 'clamp(1.4rem, 4vw, 2.2rem)' : '3.4rem'}; color: #1a1a1a; line-height: ${isMobile ? '1.4' : '1.3'}; margin-bottom: ${isMobile ? '2rem' : '4rem'}; font-weight: 300; letter-spacing: -0.02em;">
                    You tapped <strong style="font-weight: 700; ${isMobile ? 'color: #22c55e; font-size: 1.1em;' : ''}">${rightTapsPerRound}</strong> times per round (10s) with your <strong style="font-weight: 700;">right hand</strong>${isMobile ? '<br>' : ' and<br>'}
                    <strong style="font-weight: 700; ${isMobile ? 'color: #22c55e; font-size: 1.1em;' : ''}">${leftTapsPerRound}</strong> times per round with your <strong style="font-weight: 700;">left hand</strong>.
                </p>
            </div>`;
    
    // Only show Prolific code if participant came from Prolific
    if (isFromProlific) {
        html += `
            <div class="${isMobile ? 'mobile-prolific-code' : ''}" style="${isMobile ? '' : 'background: rgba(34, 197, 94, 0.1); border: 2px solid #22c55e; border-radius: 16px; padding: 2rem; margin-bottom: 3rem;'}">
                <p style="font-size: ${isMobile ? '1.3rem' : '1.6rem'}; color: #1a1a1a; margin-bottom: 1rem; font-weight: 500;">Prolific Completion Code:</p>
                <p style="font-size: ${isMobile ? '2.2rem' : '2.8rem'}; color: #22c55e; font-weight: 700; letter-spacing: 0.1em; font-family: 'Courier New', monospace;">${prolificCode}</p>
                <p style="font-size: ${isMobile ? '1rem' : '1.2rem'}; color: #666666; margin-top: 1rem;">Please copy this code and paste it into Prolific to complete your participation.</p>
            </div>`;
    }
            
    html += `
                <div class="${isMobile ? 'mobile-button-container' : ''}" style="${isMobile ? '' : 'display: flex; gap: 2rem; justify-content: center;'}">
                    <button onclick="shareResults()" style="background-color: transparent; color: #000000; border: 2px solid #000000; padding: ${isMobile ? '1.25rem 2rem' : '1.5rem 3rem'}; font-size: ${isMobile ? '1.2rem' : '1.3rem'}; font-weight: 500; border-radius: ${isMobile ? '12px' : '60px'}; cursor: pointer; transition: all 0.2s ease; font-family: 'Inter', sans-serif; ${isMobile ? 'width: 100%;' : ''}">
                        Share Results
                    </button>
                </div>
            </div>
        `;
    
                    
    document.getElementById('finalResults').innerHTML = html;

    // Save final summary to database (rest of function unchanged)
    const finalParticipantID = participantID || 'anonymous';

    allTrialResults.forEach((trial, index) => {
        const trialNum = `Trial ${index + 1}`;
        const metrics = trial.result.metrics;

        db.collection("Results")
            .doc(finalParticipantID)
            .collection("Trials")
            .doc(trialNum)
            .set({
                condition: trial.condition,
                repetition: trial.repetition,
                ...metrics,
                score: trial.result.score,
                details: trial.result.details,
                timestamp: new Date().toISOString()
            });
    });

    db.collection("Results")
    .doc(finalParticipantID)
    .collection("Summary")
    .doc("FinalSummary")
    .set({
        completedAt: new Date().toISOString(),
        totalTrials: allTrialResults.length,
        prolificCompletionCode: isFromProlific ? prolificCode : null,
        isFromProlific: isFromProlific,
        finalAverages: {
            tappingFrequency: avgFastFreq,
            tapsPerTenSeconds: avgTapsPerTenSec
        },
        allTrialMetrics: allTrialResults.map((t, idx) => ({
            trialNum: idx + 1,
            condition: t.condition,
            ...t.result.metrics
        }))
    })
    .then(() => console.log("Final summary saved for", finalParticipantID))
    .catch(err => console.error("Error saving final summary:", err));
}
        // Social media share functions
        function shareResults() {
            const rightTrials = allTrialResults.filter(t => t.condition.hand === 'right');
            const leftTrials = allTrialResults.filter(t => t.condition.hand === 'left');
            const calculateAverage = (trials, metric) => {
                const values = trials.map(t => t.result.metrics[metric]);
                return values.reduce((a, b) => a + b, 0) / values.length;
            };
            
            const rightTapsPerRound = Math.round(calculateAverage(rightTrials, 'tapCount'));
            const leftTapsPerRound = Math.round(calculateAverage(leftTrials, 'tapCount'));
            const rightFastFreq = calculateAverage(rightTrials, 'avgFrequency');
            const leftFastFreq = calculateAverage(leftTrials, 'avgFrequency');
            const avgFastFreq = (rightFastFreq + leftFastFreq) / 2;
            const avgTapsPerTenSec = avgFastFreq * 10;
            
            const demographicNorms = getDemographicAdjustedNorms();
            const normMean = demographicNorms.mean;
            const normSD = demographicNorms.sd;
            const zScore = (avgTapsPerTenSec - normMean) / normSD;

            
            showShareOptions(rightTapsPerRound, leftTapsPerRound);
        }
        
        function showShareOptions(rightTaps, leftTaps) {
            const shareText = `🧠 Just completed a motor speed assessment!\n\n⚡ Right hand: ${rightTaps} taps (10s)\n⚡ Left hand: ${leftTaps} taps (10s)\n\nTry it yourself! 👆`;
            
            // Create share modal
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.8);
                z-index: 10000;
                display: flex;
                align-items: center;
                justify-content: center;
                backdrop-filter: blur(10px);
            `;
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 20px; padding: 3rem; max-width: 500px; width: 90%; text-align: center; font-family: 'Inter', sans-serif;">
                    <h3 style="font-size: 2rem; margin-bottom: 2rem; color: #1a1a1a;">Share Your Results</h3>
                    
                    <div style="display: grid; gap: 1rem; margin-bottom: 2rem;">
                        <button onclick="shareToTwitter(\`${shareText}\`)" style="background: #1da1f2; color: white; border: none; padding: 1rem 2rem; border-radius: 12px; font-size: 1.1rem; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 0.5rem;">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M23.953 4.57a10 10 0 01-2.825.775 4.958 4.958 0 002.163-2.723c-.951.555-2.005.959-3.127 1.184a4.92 4.92 0 00-8.384 4.482C7.69 8.095 4.067 6.13 1.64 3.162a4.822 4.822 0 00-.666 2.475c0 1.71.87 3.213 2.188 4.096a4.904 4.904 0 01-2.228-.616v.06a4.923 4.923 0 003.946 4.827 4.996 4.996 0 01-2.212.085 4.936 4.936 0 004.604 3.417 9.867 9.867 0 01-6.102 2.105c-.39 0-.779-.023-1.17-.067a13.995 13.995 0 007.557 2.209c9.053 0 13.998-7.496 13.998-13.985 0-.21 0-.42-.015-.63A9.935 9.935 0 0024 4.59z"/></svg>
                            Share on Twitter
                        </button>
                        
                        <button onclick="shareToFacebook(\`${shareText}\`)" style="background: #4267B2; color: white; border: none; padding: 1rem 2rem; border-radius: 12px; font-size: 1.1rem; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 0.5rem;">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M24 12.073c0-6.627-5.373-12-12-12s-12 5.373-12 12c0 5.99 4.388 10.954 10.125 11.854v-8.385H7.078v-3.47h3.047V9.43c0-3.007 1.792-4.669 4.533-4.669 1.312 0 2.686.235 2.686.235v2.953H15.83c-1.491 0-1.956.925-1.956 1.874v2.25h3.328l-.532 3.47h-2.796v8.385C19.612 23.027 24 18.062 24 12.073z"/></svg>
                            Share on Facebook
                        </button>
                        
                        <button onclick="shareToBluesky(\`${shareText}\`)" style="background: #00a8e8; color: white; border: none; padding: 1rem 2rem; border-radius: 12px; font-size: 1.1rem; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 0.5rem;">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M12 10.8c-1.087-2.114-4.046-6.053-6.798-7.995C2.566.944 1.561 1.266.902 1.565.139 1.908 0 3.08 0 3.768c0 .69.378 5.65.624 6.479.815 2.736 3.713 3.66 6.383 3.364.136-.02.27-.04.40-.056-.15.04-.297.083-.445.124-2.670.739-5.568 1.663-6.383 4.4C.378 18.944 0 23.31 0 24c0 .687.139 1.86.902 2.202.659.3 1.664.622 3.3-.237 2.752-1.944 5.711-5.883 6.798-7.995C12.087 20.084 15.046 24.023 17.798 25.965c1.636.859 2.641.537 3.3.237C21.861 25.859 22 24.687 22 24c0-.69-.378-5.65-.624-6.479-.815-2.737-3.713-3.661-6.383-3.4-.148-.041-.295-.084-.445-.124.13.016.264.036.4.056 2.67.296 5.568-.628 6.383-3.364C21.622 9.418 22 5.458 22 4.768c0-.688-.139-1.86-.902-2.203-.659-.299-1.664-.621-3.3.238-2.752 1.942-5.711 5.881-6.798 7.995z"/></svg>
                            Share on Bluesky
                        </button>
                        
                        <button onclick="shareToLinkedIn(\`${shareText}\`)" style="background: #0077b5; color: white; border: none; padding: 1rem 2rem; border-radius: 12px; font-size: 1.1rem; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 0.5rem;">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"/></svg>
                            Share on LinkedIn
                        </button>
                        
                        <button onclick="copyToClipboard(\`${shareText}\`); closeShareModal();" style="background: #6b7280; color: white; border: none; padding: 1rem 2rem; border-radius: 12px; font-size: 1.1rem; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 0.5rem;">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg>
                            Copy to Clipboard
                        </button>
                    </div>
                    
                    <button onclick="closeShareModal()" style="background: #f3f4f6; color: #374151; border: none; padding: 0.75rem 2rem; border-radius: 8px; font-size: 1rem; cursor: pointer;">
                        Cancel
                    </button>
                </div>
            `;
            
            document.body.appendChild(modal);
            window.currentShareModal = modal;
            
            // Close on outside click
            modal.addEventListener('click', (e) => {
                if (e.target === modal) closeShareModal();
            });
        }
        
        function shareToTwitter(text) {
            const targetUrl = 'https://shadowcoder1.github.io/pd-video-analyzer';
            const fullText = text + '\n\n' + targetUrl;
            const encodedText = encodeURIComponent(fullText);
            window.open(`https://twitter.com/intent/tweet?text=${encodedText}`, '_blank');
            closeShareModal();
        }
        
        function shareToFacebook(text) {
            const targetUrl = 'https://shadowcoder1.github.io/pd-video-analyzer';
            const encodedText = encodeURIComponent(text);
            const encodedUrl = encodeURIComponent(targetUrl);
            window.open(`https://www.facebook.com/sharer/sharer.php?u=${encodedUrl}&quote=${encodedText}`, '_blank');
            closeShareModal();
        }
        
        function shareToBluesky(text) {
            const targetUrl = 'https://shadowcoder1.github.io/pd-video-analyzer';
            const fullText = text + '\n\n' + targetUrl;
            const encodedText = encodeURIComponent(fullText);
            // Try the new Bluesky share format
            window.open(`https://bsky.app/intent/compose?text=${encodedText}`, '_blank');
            closeShareModal();
        }
        
        function shareToLinkedIn(text) {
            const targetUrl = 'https://shadowcoder1.github.io/pd-video-analyzer';
            const encodedText = encodeURIComponent(text);
            const encodedUrl = encodeURIComponent(targetUrl);
            const encodedTitle = encodeURIComponent('Motor Speed Assessment Results');
            // LinkedIn's sharing format includes the text in the summary
            window.open(`https://www.linkedin.com/sharing/share-offsite/?url=${encodedUrl}&title=${encodedTitle}&summary=${encodedText}`, '_blank');
            closeShareModal();
        }
        
        function copyToClipboard(text) {
            const targetUrl = 'https://shadowcoder1.github.io/pd-video-analyzer';
            const fullText = text + '\n\n' + targetUrl;
            navigator.clipboard.writeText(fullText).then(() => {
                alert('Results copied to clipboard!');
            }).catch(() => {
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = fullText;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                alert('Results copied to clipboard!');
            });
        }
                
        function closeShareModal() {
            if (window.currentShareModal) {
                document.body.removeChild(window.currentShareModal);
                window.currentShareModal = null;
            }
        }
        
        // Add erf function if not already present
        function erf(x) {
            const a1 =  0.254829592;
            const a2 = -0.284496736;
            const a3 =  1.421413741;
            const a4 = -1.453152027;
            const a5 =  1.061405429;
            const p  =  0.3275911;
            const sign = x < 0 ? -1 : 1;
            x = Math.abs(x);
            const t = 1.0 / (1.0 + p * x);
            const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);
            return sign * y;
        }
        let overlayJustDismissed = false;
        document.addEventListener('keydown', function(e) {
            if (e.code === 'Space' || e.key === ' ') {
                e.preventDefault();
                return; // Spacebar intentionally does nothing
            }
            // no other keyboard shortcuts right now
        });
        

        document.addEventListener('DOMContentLoaded', function() {
                    console.log('DOM loaded, initializing...');
                    showMobileLoading();
            
            // Show the main interface immediately
            document.getElementById('page-webcam').style.display = 'block';
            
            // Initialize MediaPipe with fallback
            try {
                initializeHands();
                initializeCamera();
            } catch (error) {
                console.error('MediaPipe initialization failed:', error);
                alert('Camera initialization failed. Please refresh the page and ensure camera permissions are granted.');
            }
            
            updateConditionUI();
            
            // Add mobile tap functionality
// Add mobile tap functionality
            // Add mobile tap functionality
            const beginInstruction = document.getElementById('begin-instruction');
            if (beginInstruction) {
                beginInstruction.addEventListener('click', function(e) {
                    e.preventDefault();
                    const overlay = document.getElementById('trial-instructions-overlay');
                    if (overlay.style.display === 'flex') {
                        overlay.style.display = 'none';
                    }
                });
            }
            
        });
        function restartTrialMobileSafe(reason) {
            // Invalidate any old callbacks and clear all timers
            activeTrialToken++; // any late timer from the previous trial becomes a no-op
            if (mainTimerInterval) { clearInterval(mainTimerInterval); mainTimerInterval = null; }
            if (inactivityInterval) { clearInterval(inactivityInterval); inactivityInterval = null; }
            if (stopTimeoutId) { clearTimeout(stopTimeoutId); stopTimeoutId = null; }
            if (countdownInterval) { clearInterval(countdownInterval); countdownInterval = null; }


            if (!recording) return;
            
            recording = false;
            clearInterval(mainTimerInterval);
            
            // Reset tracking variables
            lastHandSeenTime = 0;
            
            // Reset UI
            document.getElementById('hand-guide-overlay').style.display = 'block';
            document.getElementById('hand-outline').style.display = 'block';
            document.getElementById('tapWidthFeedback').style.display = 'none';
            document.getElementById('countdown').style.display = 'none';
            
            // FIXED: Mobile-safe restart messaging
            if (window.innerWidth <= 768) {
                // Use position status instead of overlay on mobile
                const positionStatus = document.getElementById('position-status');
                switch(reason) {
                    case 'handLoss':
                        positionStatus.textContent = 'Keep hand visible - tap to retry';
                        break;
                    case 'inactivity':
                        positionStatus.textContent = 'Keep tapping - tap to retry';
                        break;
                    case 'fewTaps':
                        positionStatus.textContent = 'Tap faster - tap to retry';
                        break;
                    default:
                        positionStatus.textContent = 'Tap to retry trial';
                }
                positionStatus.className = 'position-status warning';
                
                // Make position status clickable for retry
                positionStatus.style.cursor = 'pointer';
                positionStatus.onclick = () => {
                    positionStatus.onclick = null;
                    positionStatus.style.cursor = '';
                    startRecording();
                };
            } else {
                // Desktop behavior unchanged
                const overlay = document.getElementById('trial-instructions-overlay');
                const instructionText = document.getElementById('trial-instructions-text');
                
                switch(reason) {
                    case 'handLoss':
                        instructionText.innerHTML = `
                            <div style="color: #f59e0b; font-size: 2.8rem; margin-bottom: 1rem;">Hand Lost</div>
                            <div style="color: #1a1a1a; font-size: 1.8rem; font-weight: 400;">Keep hand visible during test</div>
                        `;
                        break;
                    case 'inactivity':
                        instructionText.innerHTML = `
                            <div style="color: #f59e0b; font-size: 2.8rem; margin-bottom: 1rem;">Trial Paused</div>
                            <div style="color: #1a1a1a; font-size: 1.8rem; font-weight: 400;">Continue tapping throughout</div>
                        `;
                        break;
                    case 'fewTaps':
                        instructionText.innerHTML = `
                            <div style="color: #f59e0b; font-size: 2.8rem; margin-bottom: 1rem;">Too Few Taps</div>
                            <div style="color: #1a1a1a; font-size: 1.8rem; font-weight: 400;">Tap more frequently</div>
                        `;
                        break;
                }
                
                overlay.style.display = 'flex';
            }
            
            // Reset displays
            document.getElementById('center-timer').textContent = '00:10';
            document.getElementById('taps-display').textContent = '0';
        }
            
    </script>
</body>
</html>
