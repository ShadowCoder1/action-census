<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PD Finger Tapping Webcam Analysis</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background-color: #0a0e27;
            color: #ffffff;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr; /* single column layout */
            width: 100%;
            gap: 20px;
            margin-bottom: 30px;
        }


        .video-container {
            background: #1a1f3a;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
            position: relative;
        }


        .video-wrapper {
            position: relative;
            width: 100%;
            height: 65vh;  /* fills most of screen */
            background: #000;
            border-radius: 10px;
            overflow: hidden;
        }
        video, canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 10px;
        }

        video#inputVideo {
            transform: scaleX(-1);
        }

        canvas#outputCanvas {
            transform: scaleX(-1);
            image-rendering: optimizeSpeed;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: optimize-contrast;
            -ms-interpolation-mode: nearest-neighbor;
        }


        .controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background: #4a5568;
            cursor: not-allowed;
            box-shadow: none;
        }

        .metrics-panel {
            background: #1a1f3a;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
        }

        .metric-card {
            background: linear-gradient(135deg, #1e2139 0%, #2a2d4a 100%);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            border: 1px solid rgba(255,255,255,0.1);
            transition: all 0.3s ease;
        }

        .metric-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .metric-label {
            font-size: 0.9em;
            opacity: 0.8;
            margin-bottom: 5px;
        }

        .metric-value {
            font-size: 2em;
            font-weight: bold;
            color: #667eea;
        }

        .metric-unit {
            font-size: 0.8em;
            opacity: 0.6;
            margin-left: 5px;
        }

        .chart-container {
            grid-column: span 2;
            background: #1a1f3a;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
        }

        .chart-wrapper {
            position: relative;
            height: 300px;
            margin-bottom: 20px;
        }

        .status-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: bold;
            animation: pulse 2s infinite;
        }

        .status-ready {
            background: #48bb78;
            color: white;
        }

        .status-recording {
            background: #ed8936;
            color: white;
        }

        .status-analyzing {
            background: #667eea;
            color: white;
        }

        .hand-outline-not-ready {
            filter: drop-shadow(0 0 40px #ff0000) drop-shadow(0 0 80px #ff0000) drop-shadow(0 0 120px #ff0000);
            opacity: 0.9 !important;
            transition: all 0.3s ease;
        }

        .hand-outline-ready {
            filter: drop-shadow(0 0 40px #00ff00) drop-shadow(0 0 80px #00ff00) drop-shadow(0 0 120px #00ff00);
            opacity: 1 !important;
            animation: readyPulse 1s infinite;
            transition: all 0.3s ease;
        }
        @keyframes readyPulse {
            0%, 100% { 
                filter: drop-shadow(0 0 40px #00ff00) drop-shadow(0 0 80px #00ff00) drop-shadow(0 0 120px #00ff00);
            }
            50% { 
                filter: drop-shadow(0 0 60px #00ff00) drop-shadow(0 0 120px #00ff00) drop-shadow(0 0 180px #00ff00);
            }
        }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        .instructions {
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .open-fingers-warning {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 221, 87, 0.95);
            color: #000;
            padding: 30px 50px;
            border-radius: 20px;
            font-size: 2.5em;
            font-weight: bold;
            z-index: 500;
            animation: flash 0.8s infinite;
            text-align: center;
            display: none;
        }

        @keyframes flash {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .instructions {
            text-align: center;
            font-size: 1.2em;   /* slightly larger text */
            line-height: 1.8;
        }
        .instructions ol {
            display: inline-block; /* keeps list nicely centered */
            text-align: left;      /* keeps numbers aligned */
        }


        .instructions h3 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .instructions ol {
            margin-left: 20px;
            line-height: 1.8;
        }

        .results-summary {
            background: linear-gradient(135deg, #1e2139 0%, #2a2d4a 100%);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            border: 2px solid #667eea;
        }

        .results-summary h3 {
            color: #667eea;
            margin-bottom: 15px;
        }

        .result-item {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .result-item:last-child {
            border-bottom: none;
        }

        .severity-indicator {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 0.9em;
            font-weight: bold;
        }

        .severity-normal { background: #48bb78; }
        .severity-slight { background: #90cdf4; }
        .severity-mild { background: #f6e05e; }
        .severity-moderate { background: #ed8936; }
        .severity-severe { background: #e53e3e; }

        .countdown {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 120px;
            font-weight: bold;
            color: #667eea;
            text-shadow: 0 0 20px rgba(102, 126, 234, 0.8);
            z-index: 10;
            animation: countdownPulse 1s ease-in-out;
        }

        @keyframes countdownPulse {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 0.8; }
        }

        @keyframes tapSuccess {
            0% {
                transform: scale(1);
                opacity: 1;
            }
            100% {
                transform: scale(1.5);
                opacity: 0;
            }
        }

        .hand-indicator {
            display: inline-block;
            padding: 6px 12px;
            border-radius: 8px;
            margin-left: 10px;
            font-size: 0.9em;
            font-weight: bold;
        }

        .hand-left { background: #4299e1; }
        .hand-right { background: #48bb78; }

        .export-section {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }

        .parameter-info {
            font-size: 0.85em;
            opacity: 0.7;
            margin-top: 5px;
            line-height: 1.4;
        }

        .algorithm-status {
            background: rgba(102, 126, 234, 0.2);
            border: 1px solid #667eea;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 15px;
            font-size: 0.9em;
        }

        .final-results {
            max-width: 1200px;
            margin: 0 auto;
            padding: 40px 20px;
        }

        .metric-explanation {
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .metric-explanation h4 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        .metric-explanation p {
            line-height: 1.6;
            margin-bottom: 10px;
        }

        .percentile-indicator {
            display: inline-block;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: bold;
            margin-left: 10px;
        }

        @media (max-width: 1024px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
            
            .chart-container {
                grid-column: span 1;
            }
        }

                /* Hand position feedback states */
        .palm-correct {
            border-color: #48bb78 !important;
            background: rgba(72, 187, 120, 0.1) !important;
        }

        .palm-correct #palm-status {
            color: #48bb78 !important;
        }

        .position-feedback {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.9);
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 1.3em;
            font-weight: bold;
            z-index: 200;
            display: none;
        }

        .feedback-good {
            border: 2px solid #48bb78;
            color: #48bb78;
        }

        .feedback-bad {
            border: 2px solid #ff4444;
            color: #ff4444;
        }
    </style>


    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore-compat.js"></script>

    <script>
    const firebaseConfig = {
        apiKey: "AIzaSyCIijYBeCcyl8Mt414nueAgIId8PfWaW5M",
        authDomain: "pdstudy-99397.firebaseapp.com",
        projectId: "pdstudy-99397",
        storageBucket: "pdstudy-99397.firebasestorage.app",
        messagingSenderId: "235927780090",
        appId: "1:235927780090:web:348a8c85c130371686a743",
        measurementId: "G-Y116J49LYT"
    };

    firebase.initializeApp(firebaseConfig);
    const db = firebase.firestore();

        // ‚úÖ Always create a consistent participant ID
    let participantID = sessionStorage.getItem('prolificID');
    if (!participantID) {
    participantID = `anon_${Date.now()}`;
    sessionStorage.setItem('prolificID', participantID);
    }

    </script>

</head>
<body>
        <!-- Instruction overlay shown before each trial -->
    <div id="trial-instructions-overlay" style="
        display: none;
        position: fixed;
        top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(10, 14, 39, 0.95);
        color: #fff;
        font-size: 2em;
        text-align: center;
        padding: 50px;
        z-index: 9999;
    ">
    <div id="trial-instructions-text" style="max-width: 80%; margin: 20% auto 40px auto; line-height: 1.6;">
        <!-- dynamically filled -->

    <div style="font-size: 3em; color: #ffdd57; margin: 30px 0; animation: pulse 1.5s infinite;">
            üëê START WITH FINGERS WIDE OPEN! üëê
    </div>
    </div>
    <p style="font-size: 1.2em; opacity: 0.8;">Press SPACEBAR to confirm you understand</p>
    </div>


    <!-- PAGE 2: Webcam Test -->
    <div id="page-webcam" style="display:none;">
    
    <div class="container">
        
        <div class="header">
            <h1>Fast Fingers Challenge: How Quick Are You?</h1>
        </div>
        <div class="instructions" style="text-align:center; font-size:1.3em;">
            Tap your thumb and index finger together as QUICKLY as you can for each trial.
        </div>
        
        

        <div class="main-grid">
            <div class="video-container">
                <div class="status-indicator status-ready" id="status">Ready</div>
                <div id="conditionInfo" style="
                    margin-top: 20px;
                    font-weight: bold;
                    font-size: 2em;           /* much larger */
                    color: #ffdd57;           /* bright yellow */
                    text-align: center;
                    text-transform: uppercase; /* emphasizes RIGHT / LEFT */
                    letter-spacing: 1px;
                    padding: 10px;
                    background: rgba(255, 221, 87, 0.1);
                    border: 2px solid #ffdd57;
                    border-radius: 10px;
                ">
                    Trial Info: ‚Äî
                </div>

                  <div id="conditionDescription" style="
                    margin-top: 15px;
                    margin-bottom: 20px;
                    font-size: 1.4em;        /* larger font */
                    color: #90cdf4;
                    text-align: center;
                    line-height: 1.6;
                ">
                    <!-- Pace instruction -->
                </div>

              
                <div class="video-wrapper">
                    <video id="inputVideo" autoplay playsinline></video>
                    <canvas id="outputCanvas"></canvas>
                    <!-- Transparent Hand Outline Overlay -->
                    <img id="hand-outline" src="download.png" alt="Hand Outline Guide" 
                    style="
                        position:absolute;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        width: 300px; /* adjust size */
                        height: auto;
                        opacity: 0.4; /* semi-transparent for better visibility */
                        pointer-events: none;
                        z-index: 80;
                    ">


                    <!-- Within .video-wrapper, right before video tag -->
                <!-- Hand Position Guide -->
                <!-- Hand Position Guide -->
<!-- Simple Hand Position Guide -->
                <!-- Hand Position Guide -->
                    <!-- Simple Hand Position Guide -->
                <div id="hand-guide-overlay" style="
                    position:absolute;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    pointer-events:none;
                    width: 350px;
                    height: 300px;
                    z-index: 100;">
                                    
                    <!-- Simple target box -->
                    <div id="palm-zone" style="
                    position: relative;
                    width: 100%;
                    height: 100%;
                    border-radius: 15px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    transition: border-color 0.3s ease;
                ">
<!-- Moved lower and to the right -->
<div id="position-status" style="
    position: absolute;
    top: 65%;        
    left: 56%;       
    transform: translate(-50%, -50%);
    font-size: 1.2em; 
    font-weight: bold; 
    color: #ffdd57;
    text-align: center;
">
    Put palm here
</div>

                </div>
                
                </div>

<!-- Simple instructions at top-right -->
<!-- Simple instructions at top-right -->
<div id="tap-instructions" style="
    position: absolute;
    top: 20px;
    right: 20px;
    background: rgba(0,0,0,0.9);
    padding: 25px 30px;
    border-radius: 15px;
    text-align: left;
    z-index: 100;
    border: 3px solid #ffdd57;
    box-shadow: 0 0 30px rgba(255, 221, 87, 0.5);
">
    <div style="font-size: 1.8em; color: #ffdd57; margin-bottom: 10px; font-weight: bold;">
        ‚ö†Ô∏è IMPORTANT: Start Position!
    </div>
    <div style="font-size: 1.5em; line-height: 1.8;">
        Fingers WIDE OPEN<br>
        Palm facing camera<br>
        Then tap BIG and FAST
    </div>
    <div style="font-size: 1.3em; color: #ff4444; margin-top: 10px; font-weight: bold;">
        DO NOT START WITH FINGERS CLOSED!
    </div>
</div>

                    
                    <!-- ‚úÖ NEW: Visual guide overlay -->
           
                    <!-- ‚úÖ NEW: Hand position feedback -->
                    <div id="handPositionMessage" style="
                        position: absolute;
                        bottom: 20px; left: 50%;
                        transform: translateX(-50%);
                        font-size: 1.2em;
                        color: #ff4444;
                        background: rgba(0,0,0,0.6);
                        padding: 10px 20px;
                        border-radius: 10px;
                        display: none;
                        z-index: 99;
                    ">
                        Move your hand into the circle!
                    </div>
                    
                                    
                    <!-- Recording status overlay -->
                    <div id="statusOverlay" style="
                        position: absolute;
                        top: 15px;
                        left: 15px;
                        background: rgba(0, 0, 0, 0.6);
                        padding: 12px 20px;
                        border-radius: 10px;
                        font-size: 2.6em;
                        font-weight: bold;
                        color: #fff;
                        line-height: 1.4;
                        z-index: 50;
                        display: none;
                    ">
                        <div id="overlayTime">Time Remaining: 20s</div>
                        <div id="overlayTaps">Taps: 0</div>
                    </div>

                    <!-- Tap width feedback -->
                    <div id="tapWidthFeedback" style="
                        position: absolute;
                        bottom: 50px;
                        left: 50%;
                        transform: translateX(-50%);
                        background: rgba(0, 0, 0, 0.8);
                        padding: 15px 30px;
                        border-radius: 10px;
                        font-size: 1.8em;
                        font-weight: bold;
                        text-align: center;
                        z-index: 100;
                        display: none;
                    ">
                        <div id="tapWidthMessage" style="color: #ffdd57;">TAP BIGGER!</div>
                    </div>
                    <div id="countdown" class="countdown" style="display: none;"></div>
                </div>

                <!-- Position feedback message -->
                <div id="position-feedback" class="position-feedback"></div>
                
                <div class="controls" style="display:none;">
                    <button id="startBtn" onclick="startRecording()">Hidden Start</button>
                </div>
                  
                <div class="algorithm-status" id="algorithmStatus">
                    Press SPACEBAR to begin the test
                </div>
            </div>

    <!-- Real-time metrics removed -->

        </div>

    </div>
        <!-- Add this right after the countdown div -->
    <div id="openFingersWarning" class="open-fingers-warning">
        OPEN YOUR FINGERS FIRST!
    </div>

    <div id="finalResults" class="final-results" style="display: none;">
        <!-- Final comprehensive results will be inserted here -->
    </div>

    <script>
        // Global variables
        let camera, hands, canvasCtx, recording = false;
        let startTime, handDetected = false;
        let distanceChart, velocityChart;
        let recordingDuration = 20000; // 20 seconds
        let countdownInterval;
        let frameCount = 0;
        let mainTimerInterval;

        // Signal processing variables
        let distanceSignal = [];
        let timeSignal = [];
        let smoothedSignal = [];
        let velocitySignal = [];
        let peakIndices = [];
        let landmarkSeries = []; // stores full landmark history per frame
        let frameData = [];

                // Reset position checking state
        window.handPositionCorrect = false;
                // Reset frame counter so position checking works
        frameCount = 0;
        window.tapFeedbackTimer = 0;



        let currentDetectedHand = null; // will store "Right", "Left", or null

        // ‚úÖ Helper: check if the correct hand for this trial is visible
        function isCorrectHandDetectedForCurrentTrial() {
            const requiredHand = trialConditions[trialIndex % trialConditions.length].hand.toLowerCase(); // 'right' or 'left'
            if (!currentDetectedHand) return false; // no hand detected
            return currentDetectedHand.toLowerCase() === requiredHand;
        }




        let tapEvents = [];
        let lastPeakTime = 0;
        
        // Parameters for signal processing
        const SAMPLE_RATE = 30; // Assumed 30 FPS
        

        const trialConditions = [
            { hand: 'right' },
            { hand: 'left' },
            { hand: 'right' },
            { hand: 'left' },
            { hand: 'right' },
            { hand: 'left' }
        ];

        let trialIndex = 0;
        let totalTrials = trialConditions.length; // now 6 trials total (3 per hand)


        let allTrialResults = []


        const SMOOTHING_WINDOW = 3; // Moving average window
        const MIN_PEAK_PROMINENCE = 0.3; // Minimum prominence for peak detection
        const MIN_PEAK_DISTANCE = 100; // Minimum ms between peaks
        const CLOSED_THRESHOLD_PCT      = 30;  // below this = fingers counted "closed"
        const OPEN_THRESHOLD_PCT        = 35;  // must reopen past this before next tap
        const HAND_TOO_FAR_THRESHOLD = 0.2;  // Adjust this value - smaller = more sensitive
        const HAND_TOO_CLOSE_THRESHOLD = 0.6; // For reference
        const VELOCITY_THRESHOLD_PERCENTILE = 70; // Percentile for adaptive threshold

        // Hand landmarks indices
        const WRIST = 0;
        const THUMB_TIP = 4;
        const INDEX_TIP = 8;
        const MIDDLE_MCP = 9;

        // Population norms (from literature approximations)
        const POPULATION_NORMS = {
            frequency: {
                healthy: {
                    mean: 5.0,
                    std: 0.6,
                    ranges: [
                    { min: 6.5,  max: 8.0, percentile: 95 },   // very fast, top healthy range
                    { min: 5.5,  max: 6.5, percentile: 75 },   // above average
                    { min: 4.5,  max: 5.5, percentile: 50 },   // average (most people)
                    { min: 3.5,  max: 4.5, percentile: 25 },   // below average
                    { min: 0,    max: 3.5, percentile: 5 }     // significantly slow
                    ]
                },
                pd: {
                    mean: 3.5,
                    std: 0.8
                }
            },
            amplitude: {
                healthy: { mean: 50, std: 8, ranges: [
                    { min: 60, max: 80, percentile: 95 },   // very wide, elite
                    { min: 50, max: 60, percentile: 75 },   // typical healthy
                    { min: 40, max: 50, percentile: 50 },   // mild reduction
                    { min: 30, max: 40, percentile: 25 },   // moderate PD range
                    { min: 0,  max: 30, percentile: 5 }     // severe hypometria
                ]}
            },

            rhythmCV: {
                healthy: { mean: 12, std: 3, ranges: [
                    { min: 0, max: 8, percentile: 95 },    // very steady rhythm
                    { min: 8, max: 15, percentile: 75 },   // typical healthy
                    { min: 15, max: 20, percentile: 50 },  // slightly irregular
                    { min: 20, max: 30, percentile: 25 },  // moderate irregularity (PD)
                    { min: 30, max: 50, percentile: 5 }    // severe irregularity
                ]}
            },

            amplitudeDecrement: {
                healthy: { mean: 8, std: 4, ranges: [
                    { min: 0, max: 10, percentile: 95 },   // minimal fatigue
                    { min: 10, max: 20, percentile: 75 },  // mild
                    { min: 20, max: 30, percentile: 50 },  // moderate PD range
                    { min: 30, max: 50, percentile: 25 },  // severe decrement
                    { min: 50, max: 80, percentile: 5 }    // extreme hypometria
                ]}
            }

        };
        
        // Initialize MediaPipe Hands
        function initializeHands() {
            hands = new Hands({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                }
            });

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.7
            });

            hands.onResults(onHandsResults);
        }

        // Initialize camera
        function initializeCamera() {
            const videoElement = document.getElementById('inputVideo');
            const canvasElement = document.getElementById('outputCanvas');
            canvasCtx = canvasElement.getContext('2d');

            // ‚úÖ Request the best available resolution
            navigator.mediaDevices.getUserMedia({
                video: {
                width: { ideal: 1920 },  // Prefer 1080p
                height: { ideal: 1080 },
                facingMode: "user"
                }
            }).then(stream => {
                videoElement.srcObject = stream;

                // Wait until the video actually starts playing
                videoElement.onloadedmetadata = () => {
                // Match canvas resolution to actual camera resolution
                canvasElement.width = videoElement.videoWidth;
                canvasElement.height = videoElement.videoHeight;

                let lastFrameTime = Date.now();  // track last successful frame
                let freezeWatchdog = null;       // watchdog timer to restart if needed

                const processFrame = async () => {
                    try {
                        await hands.send({ image: videoElement });
                        lastFrameTime = Date.now(); // update whenever processing succeeds
                    } catch (err) {
                        console.warn("‚ö†Ô∏è MediaPipe processing error:", err);
                    }
                    requestAnimationFrame(processFrame);
                };

                // ‚úÖ Watchdog: restart MediaPipe if no frame processed for >2 seconds
                freezeWatchdog = setInterval(() => {
                    const now = Date.now();
                    if (now - lastFrameTime > 2000) {
                        console.warn("Hand tracking seems frozen. Restarting MediaPipe Hands...");
                        hands.close();       // stop the old instance
                        initializeHands();   // re-init the model
                    }
                }, 1000);

                // ‚úÖ Start the processing loop
                requestAnimationFrame(processFrame);

                };
            }).catch(err => {
                console.error("Camera access error:", err);
            });
            }


        // Moving average filter
        function movingAverage(data, windowSize) {
            const result = [];
            for (let i = 0; i < data.length; i++) {
                let start = Math.max(0, i - Math.floor(windowSize / 2));
                let end = Math.min(data.length, i + Math.floor(windowSize / 2) + 1);
                let sum = 0;
                for (let j = start; j < end; j++) {
                    sum += data[j];
                }
                result.push(sum / (end - start));
            }
            return result;
        }

        // Calculate numerical derivative
        function calculateDerivative(data, timeData) {
            const derivative = [];
            for (let i = 1; i < data.length; i++) {
                const dt = (timeData[i] - timeData[i-1]) / 1000; // Convert to seconds
                const dy = data[i] - data[i-1];
                derivative.push(dy / dt);
            }
            return derivative;
        }

        // Find peaks in signal using adaptive thresholding
        function findPeaks(signal, prominence = MIN_PEAK_PROMINENCE) {
            const peaks = [];
            
            // Calculate signal statistics for adaptive thresholding
            const mean = signal.reduce((a, b) => a + b, 0) / signal.length;
            const variance = signal.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / signal.length;
            const std = Math.sqrt(variance);
            
            // Adaptive threshold based on signal statistics
            const threshold = mean + prominence * std;
            
            // Find local maxima above threshold
            for (let i = 1; i < signal.length - 1; i++) {
                if (signal[i] > signal[i-1] && signal[i] > signal[i+1] && signal[i] > threshold) {
                    // Check minimum distance from last peak
                    if (peaks.length === 0 || (timeSignal[i] - timeSignal[peaks[peaks.length - 1]]) > MIN_PEAK_DISTANCE) {
                        peaks.push(i);
                    }
                }
            }
            
            return peaks;
        }

        function detectTapsFromVelocity(velocitySignal, distanceSignal) {
            const taps = [];
            let state = 'open'; // can be 'open', 'closed', or 'must_open'
            let lastTapTime = -Infinity;

            for (let i = 1; i < velocitySignal.length - 1; i++) {
                const t = timeSignal[i];
                const dist = distanceSignal[i];
                const velPrev = velocitySignal[i - 1];
                const velCurr = velocitySignal[i];

                switch (state) {
                    case 'open':
                        if (dist < 30 && velPrev < 0 && velCurr >= 0) {
                            // Fingers just closed ‚Äî register a tap
                            if ((t - lastTapTime) > MIN_PEAK_DISTANCE) {
                                taps.push({
                                    index: i,
                                    time: t,
                                    amplitude: dist
                                });
                                lastTapTime = t;
                                state = 'must_open';
                            }
                        }
                        break;

                    case 'must_open':
                        if (dist > 35) {
                            state = 'open';
                        }
                        break;

                    default:
                        // fallback in case of unexpected state
                        state = 'open';
                }
            }

            return taps;
        }



        // Process hand detection results
   // Process hand detection results
        function onHandsResults(results) {
            const canvasElement = document.getElementById('outputCanvas');
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            
            // Draw the image
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                // ‚úÖ Check hand alignment with outline
            const outlineEl = document.getElementById('hand-outline');
            if (outlineEl) {
                const landmarks = results.multiHandLandmarks[0];
                const thumbTip = landmarks[THUMB_TIP];
                const indexTip = landmarks[INDEX_TIP];
                const wrist = landmarks[WRIST];
                
                // Get median hand position (approx center)
                const centerX = (thumbTip.x + indexTip.x + wrist.x) / 3;
                const centerY = (thumbTip.y + indexTip.y + wrist.y) / 3;

                // Target center for outline (roughly normalized middle)
                const targetX = 0.5;  
                const targetY = 0.55;

                // Distance between hand center and outline center
                const dx = Math.abs(centerX - targetX);
                const dy = Math.abs(centerY - targetY);

                // Allowable tolerance (normalized)
                const tolerance = 0.08; // ~8% of frame

                // Hand spread check (ensures fingers open)
                const fingerSpread = Math.sqrt(
                    Math.pow(thumbTip.x - indexTip.x, 2) +
                    Math.pow(thumbTip.y - indexTip.y, 2)
                );

                const isCentered = dx < tolerance && dy < tolerance;
                const isSpreadEnough = fingerSpread > 0.08;

                // Final condition for alignment
                window.handAlignedWithOutline = isCentered && isSpreadEnough;

                // Give visual feedback by changing outline opacity
                outlineEl.style.opacity = window.handAlignedWithOutline ? "0.8" : "0.4";
            }

                handDetected = true;
                const landmarks = results.multiHandLandmarks[0];
                frameCount++;
                
                // Check hand position and provide feedback

                // Simple hand position check - only update every 10 frames to prevent glitching
// Check hand position - only update every 10 frames to prevent glitching
            // Simple distance check - only update every 10 frames

            // Simple distance check - check immediately for first few frames, then every 10
            if (!recording && (frameCount < 10 || frameCount % 10 === 0)) {
                const wrist = landmarks[WRIST];
                const thumbTip = landmarks[THUMB_TIP];
                const indexTip = landmarks[INDEX_TIP];
                const middleMcp = landmarks[MIDDLE_MCP];
                const guideOverlay = document.getElementById('hand-guide-overlay');
                
                if (guideOverlay && guideOverlay.style.display !== 'none') {
                    // Calculate hand size as distance check
                    const handSize = Math.sqrt(
                        Math.pow((wrist.x - middleMcp.x), 2) +
                        Math.pow((wrist.y - middleMcp.y), 2)
                    );
                    
                    const goodDistance = handSize > 0.2 && handSize < 0.3; 
                    
                    
                    
                    // Check finger spread
                    const fingerDistance = Math.sqrt(
                        Math.pow((thumbTip.x - indexTip.x), 2) +
                        Math.pow((thumbTip.y - indexTip.y), 2)
                    );
                    const fingersOpen = fingerDistance > 0.12; // relative to screen
                    
                    const palmZone = document.getElementById('palm-zone');
                    const statusText = document.getElementById('position-status');
                    
                    // Store position status globally
                    window.handPositionCorrect = goodDistance && fingersOpen;
                    
                    // Get the hand outline image
                    const handOutline = document.getElementById('hand-outline');

  // Check wrong hand FIRST - if wrong hand, show only that message
                if (!isCorrectHandDetectedForCurrentTrial()) {
                    const requiredHand = trialConditions[trialIndex % trialConditions.length].hand.toUpperCase();
                    palmZone.style.borderColor = '#ff4444';
                    statusText.textContent = `Wrong hand! Use your ${requiredHand} hand`;
                    statusText.style.fontSize = '1.4em';
                    statusText.style.color = '#ff4444';
                    handOutline.classList.remove('hand-outline-ready');
                    handOutline.classList.add('hand-outline-not-ready');
                } else if (goodDistance && fingersOpen) {
                    palmZone.style.borderColor = '#48bb78';
                    statusText.textContent = '‚úì Ready! Press SPACE';
                    statusText.style.color = '#0d5a0d';
                    handOutline.classList.remove('hand-outline-not-ready');
                    handOutline.classList.add('hand-outline-ready');
                } else {
                    // RED GLOW for any problem
                    handOutline.classList.remove('hand-outline-ready');
                    handOutline.classList.add('hand-outline-not-ready');
                    
                    if (!goodDistance) {
                        palmZone.style.borderColor = '#ff4444';
                        if (handSize < 0.15) {
                            statusText.textContent = 'Hand too far - Move closer!';
                            statusText.style.fontSize = '1.4em';
                        } else if (handSize > 0.3) {
                            statusText.textContent = 'Hand too close - Move back!';
                            statusText.style.fontSize = '1.4em';
                        } else {
                            statusText.textContent = 'Move hand closer to the screen';
                            statusText.style.fontSize = '1.2em';
                        }
                        statusText.style.color = '#ff4444';
                    } else if (!fingersOpen) {
                        palmZone.style.borderColor = '#ffdd57';
                        statusText.textContent = 'Start with fingers OPEN';
                        statusText.style.color = '#ffdd57';
                    }
                }
                }
            }
                if (results.multiHandedness && results.multiHandedness.length > 0) {
                    let rawLabel = results.multiHandedness[0].label;
                    currentDetectedHand = (rawLabel === "Right") ? "Left" : "Right";
       

            } else {
                currentDetectedHand = null;
            }

                
                // Update status to show hand detected
                if (!recording && document.getElementById('status').textContent === 'Ready') {
                    document.getElementById('algorithmStatus').textContent = 'Hand detected! Press SPACEBAR to begin';
                }

                const requiredHand = trialConditions[trialIndex % trialConditions.length].hand.toLowerCase();

                // ‚úÖ Use the mirrored label, NOT the raw label
                if (!currentDetectedHand || currentDetectedHand.toLowerCase() !== requiredHand) {
                    document.getElementById('algorithmStatus').textContent =
                        `‚ùå Wrong hand detected! Please use your ${requiredHand.toUpperCase()} hand.`;
                    return; // Skip processing for wrong hand
                }

                                
                // REMOVED: Draw hand skeleton - we only want thumb and index visualization

                // Process finger tap data if recording
                if (recording) {
                    processFingerTapAdvanced(landmarks, results.image.width, results.image.height);
                }
                // Get thumb and index fingertips
                const thumbTip = landmarks[THUMB_TIP];
                const indexTip = landmarks[INDEX_TIP];
                // Calculate distance for color determination
                const distance = Math.sqrt(
                    Math.pow((thumbTip.x - indexTip.x) * canvasElement.width, 2) +
                    Math.pow((thumbTip.y - indexTip.y) * canvasElement.height, 2)
                );
                
                // Determine if fingers are currently tapping (close together)
                const isTapping = recording && distance < 30; // Threshold for "tapped" state
                
                // Check if we just detected a new tap
                let justTapped = false;
                if (recording && tapEvents.length > 0) {
                    const currentTime = Date.now() - startTime;
                    const lastTap = tapEvents[tapEvents.length - 1];
                    // If the last tap was within 150ms, show green feedback
                    justTapped = (currentTime - lastTap.time) < 150;
                }
                
                // Set colors based on state
                // Set colors based on state - ENHANCED VISIBILITY
                let dotColor = '#9ca3af'; // Brighter grey
                let lineColor = 'rgba(156, 163, 175, 0.8)'; // More visible grey
                let dotSize = 14; // Larger default size
                let borderColor = '#ffffff'; // White border for visibility
                
                if (justTapped) {
                    // Just completed a tap - bright green with larger size
                    dotColor = '#10f981'; // Brighter emerald green
                    lineColor = 'rgba(16, 249, 129, 1)'; // Full opacity bright green
                    dotSize = 20; // Even larger for emphasis
                    borderColor = '#ffffff'; // Keep white border
                    
                    // Add glow effect
                    canvasCtx.shadowBlur = 20;
                    canvasCtx.shadowColor = '#10b981';
                } else if (isTapping) {
                    // Currently tapping (fingers close) - lighter green
                    dotColor = '#34d399';
                    lineColor = 'rgba(52, 211, 153, 0.6)';
                    dotSize = 12;
                }
                
                // Draw line between thumb and index with color
                canvasCtx.strokeStyle = lineColor;
                canvasCtx.lineWidth = 3;
                canvasCtx.beginPath();
                canvasCtx.moveTo(thumbTip.x * canvasElement.width, thumbTip.y * canvasElement.height);
                canvasCtx.lineTo(indexTip.x * canvasElement.width, indexTip.y * canvasElement.height);
                canvasCtx.stroke();
                
                // Draw larger circles for thumb with color and potential glow
// Draw larger circles for thumb with white border for visibility
                // First draw white border
                canvasCtx.fillStyle = borderColor;
                canvasCtx.beginPath();
                canvasCtx.arc(thumbTip.x * canvasElement.width, thumbTip.y * canvasElement.height, dotSize + 2, 0, 2 * Math.PI);
                canvasCtx.fill();

                // Then draw colored dot
                canvasCtx.fillStyle = dotColor;
                canvasCtx.beginPath();
                canvasCtx.arc(thumbTip.x * canvasElement.width, thumbTip.y * canvasElement.height, dotSize, 0, 2 * Math.PI);
                canvasCtx.fill();
                
                // Draw index finger dot
                // Draw index finger dot with white border
                // First draw white border
                canvasCtx.fillStyle = borderColor;
                canvasCtx.beginPath();
                canvasCtx.arc(indexTip.x * canvasElement.width, indexTip.y * canvasElement.height, dotSize + 2, 0, 2 * Math.PI);
                canvasCtx.fill();

                // Then draw colored dot
                canvasCtx.fillStyle = dotColor;
                canvasCtx.beginPath();
                canvasCtx.arc(indexTip.x * canvasElement.width, indexTip.y * canvasElement.height, dotSize, 0, 2 * Math.PI);
                canvasCtx.fill();
                
                // Reset shadow for next frame
                canvasCtx.shadowBlur = 0;
                
                // Add tap success indicator (floating +1 effect)
                if (justTapped && tapEvents.length > 0) {
                    const midX = (thumbTip.x + indexTip.x) / 2 * canvasElement.width;
                    const midY = (thumbTip.y + indexTip.y) / 2 * canvasElement.height;
                    
                    // Draw success text
                    canvasCtx.font = 'bold 24px Arial';
                    canvasCtx.fillStyle = '#10b981';
                    canvasCtx.textAlign = 'center';
                    canvasCtx.shadowBlur = 10;
                    canvasCtx.shadowColor = '#10b981';
                    
                    // Calculate fade based on time since tap
                    const timeSinceTap = (Date.now() - startTime) - tapEvents[tapEvents.length - 1].time;
                    const fadeOpacity = Math.max(0, 1 - (timeSinceTap / 150));
                    canvasCtx.globalAlpha = fadeOpacity;
                    
                    canvasCtx.fillText('‚úì', midX, midY - 20);
                    canvasCtx.globalAlpha = 1; // Reset opacity
                    canvasCtx.shadowBlur = 0;
                }
                
                // Remove the old peak detection visualization since we have the new feedback
                
            } else {
            handDetected = false;
            currentDetectedHand = null;
            
            // RESET VISUAL STATES WHEN NO HAND
            const handOutline = document.getElementById('hand-outline');
            const palmZone = document.getElementById('palm-zone');
            const statusText = document.getElementById('position-status');
            const guideOverlay = document.getElementById('hand-guide-overlay');
            
            if (guideOverlay && guideOverlay.style.display !== 'none' && !recording) {
                // Remove any glow classes
                handOutline.classList.remove('hand-outline-ready');
                handOutline.classList.remove('hand-outline-not-ready');
                handOutline.style.opacity = "0.4"; // dim when no hand
                
                // Reset palm zone
                palmZone.style.borderColor = '#666666';
                statusText.textContent = 'No hand detected';
                statusText.style.color = '#999999';
                
                // Reset the global position state
                window.handPositionCorrect = false;
            }
            
            // Update status when hand not detected
            if (!recording && document.getElementById('status').textContent === 'Ready') {
                document.getElementById('algorithmStatus').textContent = 'Position your hand in view, then press SPACEBAR';
            }
        }

            canvasCtx.restore();
        }

        // MediaPipe hand connections
        const HAND_CONNECTIONS = [
            [0, 1], [1, 2], [2, 3], [3, 4],
            [0, 5], [5, 6], [6, 7], [7, 8],
            [5, 9], [9, 10], [10, 11], [11, 12],
            [9, 13], [13, 14], [14, 15], [15, 16],
            [13, 17], [17, 18], [18, 19], [19, 20],
            [0, 17]
        ];

        // Helper functions for drawing
        function drawConnectors(ctx, landmarks, connections, style) {
            ctx.strokeStyle = style.color;
            ctx.lineWidth = style.lineWidth;
            
            connections.forEach(([start, end]) => {
                const startLandmark = landmarks[start];
                const endLandmark = landmarks[end];
                
                ctx.beginPath();
                ctx.moveTo(startLandmark.x * ctx.canvas.width, startLandmark.y * ctx.canvas.height);
                ctx.lineTo(endLandmark.x * ctx.canvas.width, endLandmark.y * ctx.canvas.height);
                ctx.stroke();
            });
        }

        function drawLandmarks(ctx, landmarks, style) {
            ctx.fillStyle = style.color;
            
            landmarks.forEach(landmark => {
                ctx.beginPath();
                ctx.arc(landmark.x * ctx.canvas.width, landmark.y * ctx.canvas.height, 
                       style.radius, 0, 2 * Math.PI);
                ctx.fill();
            });
        }

        // Advanced finger tap processing with signal analysis
        function processFingerTapAdvanced(landmarks, imageWidth, imageHeight) {
            const currentTime = Date.now() - startTime;
            // Only increment during recording
           
            
            // Calculate 3D distance between thumb and index tips
            const thumbTip = landmarks[THUMB_TIP];
            const indexTip = landmarks[INDEX_TIP];
            const wrist = landmarks[WRIST];
            const middleMcp = landmarks[MIDDLE_MCP];
            
            // Calculate hand size for normalization
            const handSize = Math.sqrt(
                Math.pow((wrist.x - middleMcp.x) * imageWidth, 2) +
                Math.pow((wrist.y - middleMcp.y) * imageHeight, 2)
            );
            
            // Calculate normalized distance
            const distance = Math.sqrt(
                Math.pow((thumbTip.x - indexTip.x) * imageWidth, 2) +
                Math.pow((thumbTip.y - indexTip.y) * imageHeight, 2) +
                Math.pow((thumbTip.z - indexTip.z) * imageWidth * 0.5, 2) // Z depth with reduced weight
            );
            
            const normalizedDistance = (distance / handSize) * 100;
            
            // Add to signal arrays
            distanceSignal.push(normalizedDistance);
            timeSignal.push(currentTime);

            // Check tap width and provide feedback during recording
            // Check tap width and provide feedback during recording
            if (recording) {
                const tapWidthFeedback = document.getElementById('tapWidthFeedback');
                const tapWidthMessage = document.getElementById('tapWidthMessage');
                
                // Get maximum amplitude from recent samples (last ~1 second)
                const recentSamples = distanceSignal.slice(-30);
                const maxRecentAmplitude = Math.max(...recentSamples);
                
                // Initialize or update feedback timer
                if (!window.tapFeedbackTimer) {
                    window.tapFeedbackTimer = 0;
                }
                
                if (maxRecentAmplitude < 45) {
                    tapWidthFeedback.style.display = 'block';
                    tapWidthMessage.textContent = 'Open fingers wider';
                    tapWidthMessage.style.color = '#ffdd57';
                    window.tapFeedbackTimer = 45; // Show for 1.5 seconds
                } else if (window.tapFeedbackTimer > 0) {
                    // Keep showing message for a bit after improvement
                    window.tapFeedbackTimer--;
                } else {
                    tapWidthFeedback.style.display = 'none';
                }
            }
                        
            // Apply signal processing every few frames
            if (frameCount % 2 === 0 && distanceSignal.length > SMOOTHING_WINDOW) {
                // Smooth the signal
                smoothedSignal = movingAverage(distanceSignal, SMOOTHING_WINDOW);
                
                // Calculate velocity
                if (smoothedSignal.length > 1) {
                    velocitySignal = calculateDerivative(smoothedSignal, timeSignal);
                    
                    // Detect taps using multiple methods
                    detectTapsMultiMethod();
                }
                
                // Update real-time metrics
                //updateRealtimeMetrics();
                
                // Update charts
                //updateCharts();
            }

            if (!frameData) frameData = [];  // ‚úÖ guarantee array exists
            frameData.push({
                timestamp: currentTime,
                normalizedDistance: normalizedDistance,
                // Angle between thumb and index for extra detail
                thumbIndexAngle: Math.atan2(
                    (indexTip.y - thumbTip.y),
                    (indexTip.x - thumbTip.x)
                ) * 180 / Math.PI,
                handSize: handSize,
                // Save all key landmarks
                thumbTip: { x: thumbTip.x, y: thumbTip.y, z: thumbTip.z },
                indexTip: { x: indexTip.x, y: indexTip.y, z: indexTip.z },
                wrist: { x: wrist.x, y: wrist.y, z: wrist.z },
                middleMcp: { x: middleMcp.x, y: middleMcp.y, z: middleMcp.z },
                rawLandmarks: landmarks.map(lm => ({ x: lm.x, y: lm.y, z: lm.z }))
            });

        }

        // Multi-method tap detection for robustness
        function detectTapsMultiMethod() {
            const rawEvents = [];            // collect all raw detections here
            const added     = new Set();     // prevent duplicate indices

            /* --------- 1. Velocity zero-crossings (most reliable) --------- */
            detectTapsFromVelocity(velocitySignal, smoothedSignal).forEach(ev => {
                if (!added.has(ev.index)) { rawEvents.push(ev); added.add(ev.index); }
            });

            /* --------- 2. Distance-based peaks at full closure --------- */
            const inverted = smoothedSignal.map(d => 100 - d);
            findPeaks(inverted, 0.5).forEach(idx => {
                if (smoothedSignal[idx] < CLOSED_THRESHOLD_PCT && !added.has(idx)) {
                    rawEvents.push({ index: idx, time: timeSignal[idx], amplitude: smoothedSignal[idx] });
                    added.add(idx);
                }
            });

            /* --------- ‚ûä sort by time, ‚ûã enforce reopen gate --------- */
            rawEvents.sort((a, b) => a.time - b.time);
            tapEvents = [];

            for (const ev of rawEvents) {
                if (tapEvents.length === 0) {          // always accept the first tap
                    tapEvents.push(ev);
                    continue;
                }

                const last = tapEvents[tapEvents.length - 1];

                // (a) honour MIN_PEAK_DISTANCE
                if (ev.time - last.time < MIN_PEAK_DISTANCE) continue;

                // (b) NEW ‚Äî require signal to reopen past OPEN_THRESHOLD_PCT
                let reopened = false;
                for (let i = last.index + 1; i < ev.index; i++) {
                    if (smoothedSignal[i] > OPEN_THRESHOLD_PCT) { reopened = true; break; }
                }
                if (!reopened) continue;              // still the same closed dwell

                tapEvents.push(ev);
                // Update tap counter display
                if (recording) {
                    document.getElementById('overlayTaps').textContent = `Taps: ${tapEvents.length}`;

                }
            }
        }

        // Find local minima in signal
        function findMinima(signal) {
            const minima = [];
            for (let i = 1; i < signal.length - 1; i++) {
                if (signal[i] < signal[i-1] && signal[i] < signal[i+1]) {
                    minima.push(i);
                }
            }
            return minima;
        }

        // Update real-time metrics display
        function updateRealtimeMetrics() {
            if (tapEvents.length === 0) return;
            
            // Tap count
            document.getElementById('tapCount').textContent = tapEvents.length;
            
            // Calculate inter-tap intervals and metrics
            if (tapEvents.length > 1) {
                const intervals = [];
                const amplitudes = [];
                
                for (let i = 1; i < tapEvents.length; i++) {
                    intervals.push(tapEvents[i].time - tapEvents[i-1].time);
                }
                
                // Get peak amplitudes (maximum distance between taps)
                for (let i = 0; i < tapEvents.length - 1; i++) {
                    const startIdx = tapEvents[i].index;
                    const endIdx = tapEvents[i+1].index;
                    let maxAmp = 0;
                    for (let j = startIdx; j < endIdx && j < smoothedSignal.length; j++) {
                        maxAmp = Math.max(maxAmp, smoothedSignal[j]);
                    }
                    amplitudes.push(maxAmp);
                }
                
                // Average frequency
                const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
                const frequency = 1000 / avgInterval;
                document.getElementById('avgFrequency').innerHTML = frequency.toFixed(2) + '<span class="metric-unit">Hz</span>';
                
                // Average amplitude
                if (amplitudes.length > 0) {
                    const avgAmplitude = amplitudes.reduce((a, b) => a + b, 0) / amplitudes.length;
                    document.getElementById('avgAmplitude').innerHTML = avgAmplitude.toFixed(1) + '<span class="metric-unit">%</span>';
                    
                    // Amplitude decrement
                    if (amplitudes.length >= 3) {
                        const firstThird = amplitudes.slice(0, Math.floor(amplitudes.length / 3));
                        const lastThird = amplitudes.slice(-Math.floor(amplitudes.length / 3));
                        const firstAvg = firstThird.reduce((a, b) => a + b, 0) / firstThird.length;
                        const lastAvg = lastThird.reduce((a, b) => a + b, 0) / lastThird.length;
                        const decrement = ((firstAvg - lastAvg) / firstAvg) * 100;
                        document.getElementById('ampDecrement').innerHTML = decrement.toFixed(1) + '<span class="metric-unit">%</span>';
                    }
                }
                
                // Rhythm variability
                const mean = intervals.reduce((a, b) => a + b, 0) / intervals.length;
                const variance = intervals.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / intervals.length;
                const std = Math.sqrt(variance);
                const cv = (std / mean) * 100;
                document.getElementById('rhythmCV').innerHTML = cv.toFixed(1) + '<span class="metric-unit">%</span>';
                
                // Hesitations
                const hesitations = intervals.filter(i => i > 500).length;
                document.getElementById('hesitations').textContent = hesitations;
            }
        }

        // Initialize charts
        function initializeCharts() {
            const chartOptions = {
                responsive: true,
                maintainAspectRatio: false,
                animation: {
                    duration: 0
                },
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Time (seconds)',
                            color: '#ffffff'
                        },
                        ticks: { color: '#ffffff' },
                        grid: { color: 'rgba(255, 255, 255, 0.1)' }
                    },
                    y: {
                        ticks: { color: '#ffffff' },
                        grid: { color: 'rgba(255, 255, 255, 0.1)' }
                    }
                },
                plugins: {
                    legend: {
                        labels: { color: '#ffffff' }
                    }
                }
            };

            // Distance chart
            const distCtx = document.getElementById('distanceChart').getContext('2d');
            distanceChart = new Chart(distCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Finger Distance',
                        data: [],
                        borderColor: '#667eea',
                        backgroundColor: 'rgba(102, 126, 234, 0.1)',
                        tension: 0.1,
                        pointRadius: 0
                    }, {
                        label: 'Smoothed',
                        data: [],
                        borderColor: '#48bb78',
                        backgroundColor: 'rgba(72, 187, 120, 0.1)',
                        tension: 0.1,
                        pointRadius: 0
                    }, {
                        label: 'Detected Taps',
                        data: [],
                        borderColor: '#e53e3e',
                        backgroundColor: '#e53e3e',
                        showLine: false,
                        pointRadius: 8,
                        pointStyle: 'triangle'
                    }]
                },
                options: {
                    ...chartOptions,
                    scales: {
                        ...chartOptions.scales,
                        y: {
                            ...chartOptions.scales.y,
                            title: {
                                display: true,
                                text: 'Distance (% hand size)',
                                color: '#ffffff'
                            }
                        }
                    }
                }
            });

            // Velocity chart
            const velCtx = document.getElementById('velocityChart').getContext('2d');
            velocityChart = new Chart(velCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Velocity',
                        data: [],
                        borderColor: '#ed8936',
                        backgroundColor: 'rgba(237, 137, 54, 0.1)',
                        tension: 0.1,
                        pointRadius: 0
                    }, {
                        label: 'Zero Line',
                        data: [],
                        borderColor: 'rgba(255, 255, 255, 0.3)',
                        borderDash: [5, 5],
                        pointRadius: 0
                    }]
                },
                options: {
                    ...chartOptions,
                    scales: {
                        ...chartOptions.scales,
                        y: {
                            ...chartOptions.scales.y,
                            title: {
                                display: true,
                                text: 'Velocity (% hand size/s)',
                                color: '#ffffff'
                            }
                        }
                    }
                }
            });
        }

        // Update charts with new data
        function updateCharts() {
            if (distanceSignal.length < 2) return;

            // Prepare time labels
            const timeLabels = timeSignal.map(t => (t / 1000).toFixed(2));
            
            // Update distance chart
            distanceChart.data.labels = timeLabels;
            distanceChart.data.datasets[0].data = distanceSignal;
            distanceChart.data.datasets[1].data = smoothedSignal;
            
            // Add tap markers
            const tapData = new Array(distanceSignal.length).fill(null);
            tapEvents.forEach(tap => {
                if (tap.index < tapData.length) {
                    tapData[tap.index] = smoothedSignal[tap.index];
                }
            });
            distanceChart.data.datasets[2].data = tapData;
            
            distanceChart.update('none');

            // Update velocity chart
            if (velocitySignal.length > 0) {
                const velTimeLabels = timeSignal.slice(1).map(t => (t / 1000).toFixed(2));
                velocityChart.data.labels = velTimeLabels;
                velocityChart.data.datasets[0].data = velocitySignal;
                velocityChart.data.datasets[1].data = new Array(velocitySignal.length).fill(0);
                velocityChart.update('none');
            }
        }

        // Start recording with countdown and condition tracking
        function startRecording() {
    // ‚úÖ First ensure a hand is visible
            // Check hand is visible and in correct position
            if (!handDetected) {
                alert('Please position your hand in view of the camera before starting.');
                return;
            }

            // Check hand position is correct (using global variable set in position check)
            if (!window.handPositionCorrect) {
                alert('Please position your hand correctly in the green box with fingers open before starting.');
                return;
            }

            // ‚úÖ NEW: ensure the detected hand matches the required hand
            if (!isCorrectHandDetectedForCurrentTrial()) {
                const required = trialConditions[trialIndex % trialConditions.length].hand.toUpperCase();
                alert(`Please show your ${required} hand before starting.`);
                return;
            }

    // Check if all trials are done

            // Check if all trials are done
            if (trialIndex >= totalTrials) {
                alert('All trials complete!');
                return;
            }


            // Reset all data
            distanceSignal = [];
            timeSignal = [];
            smoothedSignal = [];
            velocitySignal = [];
            tapEvents = [];
            frameCount = 0;
            frameData = []; // Reset before trial

            // Start countdown
            let countdown = 3;
            const countdownEl = document.getElementById('countdown');
            countdownEl.style.display = 'block';
            countdownEl.textContent = countdown;

            countdownInterval = setInterval(() => {
                // CHECK HAND DURING COUNTDOWN
                if (!handDetected || !isCorrectHandDetectedForCurrentTrial()) {
                    // CANCEL COUNTDOWN IF HAND REMOVED
                    clearInterval(countdownInterval);
                    countdownEl.style.display = 'none';
                    
                    // Reset UI to "no hand" state
                    document.getElementById('status').textContent = 'Ready';
                    document.getElementById('status').className = 'status-indicator status-ready';
                    document.getElementById('algorithmStatus').textContent = 'Hand removed! Position your hand in view, then press SPACEBAR';
                    
                    // Show hand guide again
                    document.getElementById('hand-guide-overlay').style.display = 'block';
                    document.getElementById('tap-instructions').style.display = 'block';
                    
                    // Reset position states
                    window.handPositionCorrect = false;
                    
                    return; // Exit the function
                }
                
                countdown--;
                if (countdown > 0) {
                    countdownEl.textContent = countdown;
                    countdownEl.style.animation = 'none';
                    setTimeout(() => {
                        countdownEl.style.animation = 'countdownPulse 1s ease-in-out';
                    }, 10);
                } else {
                    clearInterval(countdownInterval);
                    countdownEl.style.display = 'none';
                    startActualRecording();
                }
            }, 1000);
        }


        // Start actual recording
        function startActualRecording() {
            document.getElementById('hand-guide-overlay').style.display = 'none';
            document.getElementById('tap-instructions').style.display = 'none';
            document.getElementById('hand-outline').style.display = 'none'; 
            
            recording = true; 
            startTime = Date.now();
            distanceSignal = [];
            timeSignal = [];
            smoothedSignal = [];
            velocitySignal = [];
            tapEvents = [];
            frameCount = 0;
            document.getElementById('status').textContent = 'Recording';
            document.getElementById('status').className = 'status-indicator status-recording';
            document.getElementById('algorithmStatus').textContent = 'Algorithm: Recording signal data...';

            // Show new combined overlay
            const overlay = document.getElementById('statusOverlay');
            overlay.style.display = 'block';
            document.getElementById('overlayTime').textContent = `Time Remaining: 30s`;
            document.getElementById('overlayTaps').textContent = `Taps: 0`;

            
            // Update timer every 100ms for smooth display
            mainTimerInterval = setInterval(() => {
                const elapsed = Date.now() - startTime;
                const remaining = Math.max(0, Math.ceil((recordingDuration - elapsed) / 1000));
                document.getElementById('overlayTime').textContent = `Time Remaining: ${remaining}s`;

                
                                // Change color to red in the last 3 seconds
                if (remaining <= 3 && remaining > 0) {
                    document.getElementById('overlayTime').style.color = 'red';
                } else {
                    document.getElementById('overlayTime').style.color = '#fff'; // default white
                }

            }, 100);

            // Auto-stop after 30 seconds
            setTimeout(() => {
                if (recording) {
                    stopRecording();
                }
            }, recordingDuration);
        }

        function stopRecording() {
            recording = false;
            
            // Clear timer
            clearInterval(mainTimerInterval);
            document.getElementById('statusOverlay').style.display = 'none';
            document.getElementById('tapWidthFeedback').style.display = 'none';

            // Reset tap feedback timer
            window.tapFeedbackTimer = 0;
            
            // Reset hand position state
            window.handPositionCorrect = false;
            // Reset hand position state
            window.handPositionCorrect = false;
          

            document.getElementById('countdown').style.display = 'none';
            
            document.getElementById('status').textContent = 'Analyzing';
            document.getElementById('status').className = 'status-indicator status-analyzing';
            document.getElementById('algorithmStatus').textContent = 'Algorithm: Processing signal and detecting peaks...';

            // Perform final analysis
            setTimeout(() => {
                // Calculate and store results
                const result = calculateClinicalAssessment();

                // Get subject name (Prolific ID) from sessionStorage
                const subjectName = sessionStorage.getItem('prolificID') || 'anonymous';

                // Prepare trial document name
                // Prepare trial document name
                const trialDocName = `trial_${trialIndex + 1}`;
                if (trialIndex === 0) { 
                    console.log("‚úÖ DEBUG: FIRST TRIAL HAND DATA");
                    console.log("Detected Hand Label:", currentDetectedHand);
                    console.log("Trial Condition Hand:", trialConditions[trialIndex % trialConditions.length].hand);
                    console.log("Raw Frame Data Sample:", frameData.slice(0, 10)); // only first 10 frames for brevity
                    console.log("Tap Events:", tapEvents);
                }


                // ‚úÖ Create a lightweight raw frame dataset for future analysis
                const rawFrames = frameData.slice(0, 500).map(f => ({
                t: f.timestamp,               // ms since trial start
                normDist: f.normalizedDistance, // normalized thumb-index distance (% hand size)
                angle: f.thumbIndexAngle,       // angle between thumb & index
                handSize: f.handSize,           // scale reference
                thumb: f.thumbTip,              // {x,y,z}
                index: f.indexTip,              // {x,y,z}
                wrist: f.wrist,                 // {x,y,z}
                allLandmarks: f.rawLandmarks    // All 21 hand landmarks {x,y,z}
                }));

                // ‚úÖ Save ONLY raw hand kinematic data in Participants collection
                db.collection("Participants")
                .doc(participantID)
                .collection("Trials")
                .doc(trialDocName)
                .set({
                    trialNumber: trialIndex + 1,
                    condition: trialConditions[trialIndex % trialConditions.length],
                    timestamp: new Date().toISOString(),
                    rawFrames: rawFrames
                })
                .then(() => console.log(`‚úÖ Raw hand data saved for ${participantID} / ${trialDocName}`))
                .catch(err => console.error("‚ùå Error saving raw hand data:", err));

                allTrialResults.push({
                    condition: trialConditions[trialIndex % trialConditions.length],
                    repetition: Math.floor(trialIndex / trialConditions.length) + 1,
                    result: result
                });

                // Skip showing intermediate trial UI (we removed metrics)
                trialIndex++;

                if (trialIndex < totalTrials) {
                    // Setup for next trial
                    document.getElementById('status').textContent = 'Ready for Next Trial';
                    document.getElementById('status').className = 'status-indicator status-ready';
                    document.getElementById('algorithmStatus').textContent = 'Click "Start Next Trial" to continue.';

                        // Add instruction to press spacebar for next trial
                    document.getElementById('algorithmStatus').textContent = 'Press SPACEBAR to start the next trial.';
                    // Update condition info for next trial
                    updateConditionUI();

                } else {
                    // All trials complete - show comprehensive results
                    analyzeAllTrials();
                }


            }, 500);
        }

        // Display brief trial complete message
        function displayTrialComplete(assessment) {
            const resultsDiv = document.getElementById('resultsDiv');
            const assessmentResults = document.getElementById('assessmentResults');
            
            resultsDiv.style.display = 'block';
            
            let html = `
                <div class="result-item">
                    <span>Taps Detected:</span>
                    <span>${assessment.metrics.tapCount}</span>
                </div>
                <div class="result-item">
                    <span>Average Frequency:</span>
                    <span>${assessment.metrics.avgFrequency.toFixed(2)} Hz</span>
                </div>
                <div class="result-item">
                    <span>Trial Duration:</span>
                    <span>${assessment.metrics.testDuration.toFixed(1)} seconds</span>
                </div>
                <div class="result-item">
                    <span>Trials Remaining:</span>
                    <span>${totalTrials - trialIndex}</span>
                </div>
            `;
            
            assessmentResults.innerHTML = html;
        }

        // Calculate clinical assessment based on MDS-UPDRS criteria
        function calculateClinicalAssessment() {
            const tapCount = tapEvents.length;
            const intervals = [];
            const amplitudes = [];
            
            // Calculate intervals and amplitudes
            for (let i = 1; i < tapEvents.length; i++) {
                intervals.push(tapEvents[i].time - tapEvents[i-1].time);
            }
            
            // Get peak amplitudes between taps
            for (let i = 0; i < tapEvents.length - 1; i++) {
                const startIdx = tapEvents[i].index;
                const endIdx = tapEvents[i+1].index;
                let maxAmp = 0;
                for (let j = startIdx; j < endIdx && j < smoothedSignal.length; j++) {
                    maxAmp = Math.max(maxAmp, smoothedSignal[j]);
                }
                amplitudes.push(maxAmp);
            }
            
            // Calculate metrics
            const avgFrequency = intervals.length > 0 ? 1000 / (intervals.reduce((a, b) => a + b, 0) / intervals.length) : 0;
            const avgAmplitude = amplitudes.length > 0 ? amplitudes.reduce((a, b) => a + b, 0) / amplitudes.length : 0;
            
            // Amplitude decrement
            let amplitudeDecrement = 0;
            if (amplitudes.length >= 3) {
                const firstThird = amplitudes.slice(0, Math.floor(amplitudes.length / 3));
                const lastThird = amplitudes.slice(-Math.floor(amplitudes.length / 3));
                const firstAvg = firstThird.reduce((a, b) => a + b, 0) / firstThird.length;
                const lastAvg = lastThird.reduce((a, b) => a + b, 0) / lastThird.length;
                amplitudeDecrement = ((firstAvg - lastAvg) / firstAvg) * 100;
            }
            
            // Rhythm variability
            let rhythmCV = 0;
            if (intervals.length > 0) {
                const mean = intervals.reduce((a, b) => a + b, 0) / intervals.length;
                const variance = intervals.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / intervals.length;
                rhythmCV = (Math.sqrt(variance) / mean) * 100;
            }
            
            // Hesitations and freezing
            const hesitations = intervals.filter(i => i > 500 && i < 1000).length;
            const freezing = intervals.filter(i => i >= 1000).length;
            
            // Speed-amplitude index (novel composite measure)
            const speedAmplitudeIndex = avgFrequency * (avgAmplitude / 100);
            
            // Clinical scoring based on MDS-UPDRS criteria
            let score = 0;
            let details = [];
            
            if (avgFrequency < 1.25) {
                score = Math.max(score, 3);
                details.push("Severe slowing (<1.25‚ÄØHz)");
            } else if (avgFrequency < 2.0) {
                score = Math.max(score, 2);
                details.push("Moderate slowing (1.25‚Äì2.0‚ÄØHz)");
            } else if (avgFrequency < 2.5) {
                score = Math.max(score, 1);
                details.push("Slight slowing (2.0‚Äì2.5‚ÄØHz)");
            } // ‚â•2.5 Hz = normal (score 0)

            
            // Amplitude assessment
            if (avgAmplitude < 20) {
                score = Math.max(score, 2);
                details.push("Small amplitude movements");
            }
            
            // Amplitude decrement assessment
            if (amplitudeDecrement > 50) {
                score = Math.max(score, 3);
                details.push("Severe amplitude decrement");
            } else if (amplitudeDecrement > 30) {
                score = Math.max(score, 2);
                details.push("Amplitude decrements midway");
            } else if (amplitudeDecrement > 15) {
                score = Math.max(score, 1);
                details.push("Amplitude decrements near the end");
            }
            

            
            // Hesitations/interruptions
            if (freezing > 0) {
                score = Math.max(score, 3);
                details.push(`${freezing} freezing episode(s)`);
            } else if (hesitations >= 5) {
                score = Math.max(score, 3);
                details.push("More than 5 interruptions");
            } else if (hesitations >= 3) {
                score = Math.max(score, 2);
                details.push("3-5 interruptions");
            } else if (hesitations >= 1) {
                score = Math.max(score, 1);
                details.push("1-2 interruptions");
            }
            
            // Rhythm irregularity
            if (rhythmCV > 40) {
                score = Math.max(score, 2);
                details.push("Significant rhythm irregularity");
            } else if (rhythmCV > 25) {
                score = Math.max(score, 1);
                details.push("Mild rhythm irregularity");
            }
            
            return {
                score: score,
                details: details,
                metrics: {
                    tapCount: tapCount,
                    avgFrequency: avgFrequency,
                    avgAmplitude: avgAmplitude,
                    amplitudeDecrement: amplitudeDecrement,
                    rhythmCV: rhythmCV,
                    hesitations: hesitations,
                    freezing: freezing,
                    speedAmplitudeIndex: speedAmplitudeIndex,
                    testDuration: (timeSignal[timeSignal.length - 1] || 0) / 1000,
                    signalQuality: {
                        framesProcessed: frameCount,
                        samplingRate: frameCount / ((timeSignal[timeSignal.length - 1] || 1) / 1000),
                        detectionsConfidence: tapEvents.length / (frameCount / 30)
                    }
                }
            };
        }

        function updateConditionUI() {
            const trialNum = trialIndex + 1;
            const condition = trialConditions[trialIndex % trialConditions.length];
            const handText = condition.hand.toUpperCase() + " HAND";
            const total = totalTrials;
            // Reset hand position state for new trial
            window.handPositionCorrect = false;
            // Show and reset the hand guide
            const handGuide = document.getElementById('hand-guide-overlay');
            handGuide.style.display = 'block';
            document.getElementById('hand-outline').style.display = 'block'; // Make sure hand outline is visible between trials
            // Flip hand outline for left hand trials
// Flip hand outline for left hand trials
// Position and flip hand outline based on hand
// Position and flip hand outline based on hand
// Position and flip hand outline based on hand
            const handOutline = document.getElementById('hand-outline');
            const handGuideOverlay = document.getElementById('hand-guide-overlay');
            const tapInstructions = document.getElementById('tap-instructions');
            if (condition.hand === 'left') {
                // Move to left side and flip
                handOutline.style.left = '25%';
                handOutline.style.transform = 'translate(-50%, -50%) scaleX(-1)';
                handGuideOverlay.style.left = '25%'; // Move guide to left side
                document.getElementById('position-status').style.left = '45%';
                // Move instructions to right when hand is on left
                tapInstructions.style.right = '20px';
                tapInstructions.style.left = 'auto';
            } else {
                // Move to right side, normal orientation  
                handOutline.style.left = '75%';
                handOutline.style.transform = 'translate(-50%, -50%) scaleX(1)';
                handGuideOverlay.style.left = '75%'; // Move guide to right side
                document.getElementById('position-status').style.left = '56%';
                // Move instructions to left when hand is on right
                tapInstructions.style.left = '20px';
                tapInstructions.style.right = 'auto';
            }
                                                
            // Reset palm zone to initial state
            const palmZone = document.getElementById('palm-zone');
            palmZone.style.borderColor = '#ffdd57';
            
            const statusText = document.getElementById('position-status');
            statusText.textContent = 'Put palm here';
            statusText.style.color = '#ffdd57';
            
            // Also show tap instructions again
            document.getElementById('tap-instructions').style.display = 'block';

            const instructionHTML = `
                <h1>Trial ${trialNum} of ${total}</h1>
                <p style="margin-top:20px;">
                    Tap your <span style="color:#ffdd57; font-weight:bold;">${handText}</span> as quickly as you can for <strong>20 seconds</strong>.
                </p>
                <p style="margin-top:15px; font-size:0.8em; opacity:0.9;">
                    Keep your thumb and index finger in the camera view.
                </p>
            `;

            // Show overlay with this text
            document.getElementById('trial-instructions-text').innerHTML = instructionHTML;
            document.getElementById('trial-instructions-overlay').style.display = 'block';

            // Update the small UI text below video for when they are in trial
            const handColor = (condition.hand === 'right') ? '#48bb78' : '#4299e1';
            const conditionEl = document.getElementById('conditionInfo');
            conditionEl.innerHTML =
                `Trial ${trialNum} of ${total} ‚Äî Tap your <span style="color:${handColor}; font-size:1.4em;">${handText}</span> as quickly as you can for 20 seconds`;

            updateConditionDescription();
        }

        
        function updateConditionDescription() {


            document.getElementById('conditionDescription').textContent = msg;
        }

        function getPercentile(value, metric) {
            const ranges = POPULATION_NORMS[metric]?.healthy?.ranges;
            if (!ranges) return null;
            
            for (let range of ranges) {
                if (value >= range.min && value <= range.max) {
                    return range.percentile;
                }
            }
            return 50; // default
        }

        function calculatePercentileFromNorm(value, metric) {
            const ranges = POPULATION_NORMS[metric]?.healthy?.ranges;
            if (!ranges) {
                // Fallback to z-score calculation if no ranges
                const norm = POPULATION_NORMS[metric]?.healthy;
                if (!norm) return 50;
                const zScore = (value - norm.mean) / norm.std;
                const percentile = 50 + (zScore * 16);
                return Math.max(1, Math.min(99, Math.round(percentile)));
            }
            
            // Use actual ranges for accurate percentiles
            for (let range of ranges) {
                if (value >= range.min && value <= range.max) {
                    // Interpolate within the range
                    const rangeSize = range.max - range.min;
                    const position = (value - range.min) / rangeSize;
                    
                    // Find the next percentile bracket
                    let nextPercentile = range.percentile;
                    let prevPercentile = range.percentile;
                    
                    if (range.percentile === 95) {
                        prevPercentile = 75;
                    } else if (range.percentile === 75) {
                        nextPercentile = 95;
                        prevPercentile = 50;
                    } else if (range.percentile === 50) {
                        nextPercentile = 75;
                        prevPercentile = 25;
                    } else if (range.percentile === 25) {
                        nextPercentile = 50;
                        prevPercentile = 5;
                    } else if (range.percentile === 5) {
                        nextPercentile = 25;
                    }
                    
                    // Interpolate
                    const percentileDiff = nextPercentile - prevPercentile;
                    const interpolated = prevPercentile + (position * percentileDiff);
                    
                    return Math.max(1, Math.min(99, Math.round(interpolated)));
                }
            }
            
            // If value is outside all ranges
            if (value > ranges[0].max) return 99;
            if (value < ranges[ranges.length - 1].min) return 1;
            return 50;
        }

        function analyzeAllTrials() {
            // Hide the main interface
            document.querySelector('.container').style.display = 'none';
            document.getElementById('finalResults').style.display = 'block';
            
                        // Separate by hand
            let rightTrials = allTrialResults.filter(t => t.condition.hand === 'right');
            let leftTrials = allTrialResults.filter(t => t.condition.hand === 'left');

            // Calculate averages for each condition
            const calculateAverage = (trials, metric) => {
                const values = trials.map(t => t.result.metrics[metric]);
                return values.reduce((a, b) => a + b, 0) / values.length;
            };
            
          
    // Calculate metrics
            const rightFastFreq = calculateAverage(rightTrials, 'avgFrequency');
            const leftFastFreq = calculateAverage(leftTrials, 'avgFrequency');
            const avgFastFreq = (rightFastFreq + leftFastFreq) / 2;

            const avgDecrement = (
                calculateAverage(rightTrials, 'amplitudeDecrement') +
                calculateAverage(leftTrials, 'amplitudeDecrement')
            ) / 2;

            const avgRhythmCV = (
                calculateAverage(rightTrials, 'rhythmCV') +
                calculateAverage(leftTrials, 'rhythmCV')
            ) / 2;

            const avgSpeedAmpIndex = (
                calculateAverage(rightTrials, 'speedAmplitudeIndex') +
                calculateAverage(leftTrials, 'speedAmplitudeIndex')
            ) / 2;

            const asymmetry = Math.abs(rightFastFreq - leftFastFreq) / Math.max(rightFastFreq, leftFastFreq) * 100;
            // ‚úÖ Aggregate hesitations/freezing for all trials
            let totalHesitations = 0;
            let totalFreezing = 0;
            allTrialResults.forEach(trial => {
                totalHesitations += trial.result.metrics.hesitations || 0;
                totalFreezing += trial.result.metrics.freezing || 0;
            });
            const hesitations = Math.round(totalHesitations / allTrialResults.length);
            const freezing = Math.round(totalFreezing / allTrialResults.length);

            // Calculate hesitations and freezing across all trials
    
            // Create fun report
            let html = `
                <div class="header" style="margin-bottom: 40px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
                    <h1 style="font-size: 3em; margin-bottom: 20px;">üéØ Your Finger Speed Results!</h1>
                    <p style="font-size: 1.5em;">How fast can your brain control your fingers?</p>
                </div>
                
                <div style="text-align: center; margin-bottom: 40px; padding: 30px; background: rgba(255,255,255,0.05); border-radius: 20px;">
                    <h2 style="color: #667eea; font-size: 2.5em; margin-bottom: 20px;">Your Speed Score</h2>
                    <div style="font-size: 5em; font-weight: bold; color: #ffdd57; text-shadow: 0 0 20px rgba(255, 221, 87, 0.5);">
                        ${avgFastFreq.toFixed(1)} Hz
                    </div>
                    <p style="font-size: 1.3em; margin-top: 20px; color: #90cdf4;">
                        You tap ${(avgFastFreq * 20).toFixed(0)} times in 20 seconds!<br>
                        Most people tap at 4.5-5.5 Hz (90-110 taps in 20 seconds)
                    </p>
                </div>
            `;
            // Add detailed metric explanations with percentiles
            const metrics = [
                {
                    name: '‚ö° Speed',
                    value: avgFastFreq,
                    unit: 'Hz',
                    explanation: 'How fast you can tap! Like a video game, higher is better. Most adults tap at 2-3 times per second.',
                    icon: 'üèÉ‚Äç‚ôÇÔ∏è',
                    percentile: calculatePercentileFromNorm(avgFastFreq, 'frequency')
                },
                {
                    name: 'üìè Finger Spread',
                    value: calculateAverage([...rightTrials, ...leftTrials], 'avgAmplitude'),
                    unit: '%',
                    explanation: 'How wide you open your fingers. Bigger movements show confident control!',
                    icon: 'üëê',
                    percentile: calculatePercentileFromNorm(calculateAverage([...rightTrials, ...leftTrials], 'avgAmplitude'), 'amplitude')
                },
                {
                    name: 'üîã Stamina',
                    value: Math.max(0, 100 - avgDecrement),
                    unit: '%',
                    explanation: 'How well you maintain your speed. Higher percentage means your brain keeps going strong!',
                    icon: 'üí™',
                    percentile: calculatePercentileFromNorm(100 - avgDecrement, 'amplitudeDecrement')

                },
                {
                    name: 'üéµ Rhythm',
                    value: Math.max(0, 100 - avgRhythmCV),
                    unit: '%',
                    explanation: 'How steady your beat is. Musicians often score high here!',
                    icon: 'ü•Å',
                    percentile: calculatePercentileFromNorm(avgRhythmCV, 'rhythmCV') // Don't invert here, the ranges handle it
                },
                {
                    name: '‚öñÔ∏è Balance',
                    value: Math.max(0, 100 - asymmetry),
                    unit: '%',
                    explanation: 'How similar your hands perform. Most people have a slightly dominant hand.',
                    icon: 'ü§ù',
                    percentile: asymmetry < 10 ? 85 : asymmetry < 20 ? 50 : 15
                },
                {
                    name: 'üí´ Fluidity',
                    value: Math.max(0, 100 - (hesitations * 10) - (freezing * 25)),
                    unit: '%',
                    explanation: 'How smoothly you tap without pauses. Like water flowing - no interruptions!',
                    icon: 'üåä',
                    percentile: hesitations === 0 && freezing === 0 ? 90 : hesitations <= 2 ? 70 : hesitations <= 5 ? 40 : 20
                }
            ];

            // Display metrics in a responsive grid
            html += '<h2 style="text-align: center; color: #667eea; margin-bottom: 30px; font-size: 2em;">Your Performance Breakdown</h2>';
            html += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 25px; margin-bottom: 40px; max-width: 1400px; margin-left: auto; margin-right: auto;">';

                metrics.forEach(metric => {
                    // Determine performance color based on percentile
                    let performanceColor = '#48bb78'; // green
                    if (metric.percentile < 25) performanceColor = '#e53e3e'; // red
                    else if (metric.percentile < 50) performanceColor = '#ed8936'; // orange
                    else if (metric.percentile < 75) performanceColor = '#f6e05e'; // yellow
                    
                    // Add source citation for well-supported metrics
                    let sourceInfo = '';
                    let percentileText = `Better than ${metric.percentile}% of people`;
                    
                    if (metric.name === '‚ö° Speed') {
                        sourceInfo = `
                            <div style="margin-top: 10px; font-size: 0.85em; opacity: 0.8; cursor: pointer;" 
                                onclick="window.open('https://pubmed.ncbi.nlm.nih.gov/8337069/', '_blank')">
                                üìÑ Based on clinical research ‚Ä¢ Click to view source
                            </div>`;
                    } else if (metric.name === 'üéµ Rhythm') {
                        sourceInfo = `
                            <div style="margin-top: 10px; font-size: 0.85em; opacity: 0.8;">
                                üìÑ Based on motor research studies
                            </div>`;
                    } else {
                        percentileText = `Estimated performance level*`;
                        sourceInfo = `
                            <div style="margin-top: 10px; font-size: 0.85em; opacity: 0.7; font-style: italic;">
                                *Estimates based on clinical patterns
                            </div>`;
                    }
                    
                    html += `
                        <div style="background: linear-gradient(135deg, #1e2139 0%, #2a2d4a 100%); 
                                    border-radius: 20px; padding: 30px; text-align: center;
                                    transition: all 0.3s ease; cursor: pointer;
                                    border: 2px solid rgba(102, 126, 234, 0.3);
                                    box-shadow: 0 10px 30px rgba(0,0,0,0.3);"
                            onmouseover="this.style.transform='translateY(-5px)'; this.style.boxShadow='0 15px 40px rgba(102,126,234,0.4)'"
                            onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 10px 30px rgba(0,0,0,0.3)'">
                            <div style="font-size: 3.5em; margin-bottom: 15px; filter: drop-shadow(0 0 10px rgba(255,255,255,0.3));">${metric.icon}</div>
                            <h4 style="color: #90cdf4; font-size: 1.2em; margin-bottom: 15px; text-transform: uppercase; letter-spacing: 1px;">${metric.name}</h4>
                            <div style="font-size: 3em; font-weight: bold; color: #ffdd57; margin-bottom: 10px; text-shadow: 0 0 15px rgba(255, 221, 87, 0.5);">
                                ${metric.value.toFixed(0)}${metric.unit}
                            </div>
                            <div style="background: ${performanceColor}; color: white; padding: 8px 16px; border-radius: 20px; 
                                        font-weight: bold; margin: 15px auto; display: inline-block; font-size: 1.1em;">
                                ${percentileText}
                            </div>
                            <p style="font-size: 0.95em; opacity: 0.9; line-height: 1.5; margin-top: 15px;">${metric.explanation}</p>
                            ${sourceInfo}
                        </div>
                    `;
                });

            html += '</div>';
            
            // Add condition-specific results
            html += `
                <div class="results-summary" style="margin-top: 40px;">
                    <h3>Detailed Results by Condition</h3>
                    <table style="width: 100%; color: white; border-collapse: collapse;">
                        <thead>
                            <tr style="border-bottom: 2px solid #667eea;">
                                <th style="padding: 10px; text-align: left;">Condition</th>
                                <th style="padding: 10px;">Avg Frequency (Hz)</th>
                                <th style="padding: 10px;">Avg Amplitude (%)</th>
                                <th style="padding: 10px;">Rhythm CV (%)</th>
                                <th style="padding: 10px;">Tap Count</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
   

            const conditions = [
                { name: 'Right Hand', data: rightTrials },
                { name: 'Left Hand', data: leftTrials }
            ];

            
            conditions.forEach(cond => {
                const freq = calculateAverage(cond.data, 'avgFrequency');
                const amp = calculateAverage(cond.data, 'avgAmplitude');
                const cv = calculateAverage(cond.data, 'rhythmCV');
                const taps = cond.data.map(t => t.result.metrics.tapCount).reduce((a,b) => a+b, 0) / cond.data.length;
                
                html += `
                    <tr style="border-bottom: 1px solid rgba(255,255,255,0.1);">
                        <td style="padding: 10px;">${cond.name}</td>
                        <td style="padding: 10px; text-align: center;">${freq.toFixed(2)}</td>
                        <td style="padding: 10px; text-align: center;">${amp.toFixed(1)}</td>
                        <td style="padding: 10px; text-align: center;">${cv.toFixed(1)}</td>
                        <td style="padding: 10px; text-align: center;">${taps.toFixed(0)}</td>
                    </tr>
                `;
            });
            
            html += `
                        </tbody>
                    </table>
                </div>
                
                <div style="text-align: center; margin-top: 40px; padding: 30px; 
                            background: linear-gradient(135deg, rgba(102, 126, 234, 0.2) 0%, rgba(118, 75, 162, 0.2) 100%);
                            border-radius: 20px; border: 2px solid #667eea;">
                    <div style="font-size: 0.9em; opacity: 0.7; margin-bottom: 20px; padding: 15px; background: rgba(0,0,0,0.2); border-radius: 10px;">
                        <strong>Research Note:</strong> Speed comparisons are based on peer-reviewed studies. Other performance estimates use clinical research patterns and may vary between individuals and populations.
                    </div>
                    <h3 style="color: #ffdd57; font-size: 2em; margin-bottom: 20px;">üß† Fun Brain Facts!</h3>
                    <p style="font-size: 1.2em; line-height: 1.8; margin-bottom: 20px;">
                        Your finger tapping speed is controlled by multiple brain regions working together like an orchestra!
                        Professional gamers often score high on speed, while musicians excel at rhythm.
                    </p>
                    <div style="font-size: 1.5em; color: #90cdf4; margin-top: 30px;">
                        Challenge your friends and see who has the fastest fingers! üèÜ
                    </div>
                </div>
                
                <div class="export-section" style="margin-top: 40px; text-align: center;">
                    <button onclick="location.reload()" style="font-size: 1.3em; padding: 15px 40px; 
                            background: linear-gradient(135deg, #10b981 0%, #34d399 100%);">
                        üéÆ Play Again!
                    </button>
                    <button onclick="shareResults()" style="margin-left: 20px; font-size: 1.3em; padding: 15px 40px;">
                        üì§ Share Results
                    </button>
                </div>
            `;
            
            document.getElementById('finalResults').innerHTML = html;

            const participantID = sessionStorage.getItem('prolificID') || 'anonymous';

            // Initialize summary trackers
            let totalFreq = 0, totalAmp = 0, totalCV = 0, totalDec = 0;
            let rightHand = [], leftHand = [];
            let conditionBreakdown = {};

            allTrialResults.forEach((trial, index) => {
            const trialNum = `Trial ${index + 1}`;
            const metrics = trial.result.metrics;

            // Save individual trial under participant document
            db.collection("Results")
                .doc(participantID)
                .collection("Trials")
                .doc(trialNum)
                .set({
                condition: trial.condition,
                repetition: trial.repetition,
                ...metrics,
                score: trial.result.score,
                details: trial.result.details,
                timestamp: new Date().toISOString()
                });

            // Aggregate for summary
            totalFreq += metrics.avgFrequency;
            totalAmp += metrics.avgAmplitude;
            totalCV += metrics.rhythmCV;
            totalDec += metrics.amplitudeDecrement;

            if (trial.condition.hand === "right") rightHand.push(metrics.avgAmplitude);
            if (trial.condition.hand === "left") leftHand.push(metrics.avgAmplitude);

            const condKey = `${trial.condition.hand} - ${trial.condition.pace}`;
            conditionBreakdown[condKey] = {
                avgFrequency: metrics.avgFrequency,
                avgAmplitude: metrics.avgAmplitude,
                rhythmCV: metrics.rhythmCV,
                tapCount: metrics.tapEvents?.length || 0
            };
            });

            // Now calculate and store Final Prognosis
            const avgFreq = totalFreq / 8;
            const avgAmp = totalAmp / 8;
            const avgCV = totalCV / 8;
            const avgDec = totalDec / 8;

            const mean = arr => arr.reduce((a, b) => a + b, 0) / arr.length;
            const rightAvg = mean(rightHand);
            const leftAvg = mean(leftHand);
            const finalAsymmetry = Math.abs(rightAvg - leftAvg) / Math.max(rightAvg, leftAvg) * 100;
            db.collection("Results")
            .doc(participantID)
            .collection("Summary")
            .doc("FinalSummary")
            .set({
                completedAt: new Date().toISOString(),
                totalTrials: allTrialResults.length,
                finalAverages: {
                tappingFrequency: avgFastFreq,
                movementAmplitude: calculateAverage([...rightTrials, ...leftTrials], 'avgAmplitude'),
                amplitudeDecrement: avgDecrement,
                rhythmConsistency: avgRhythmCV,
                handAsymmetry: asymmetry
                },
                hesitations: hesitations,
                freezing: freezing,
                allTrialMetrics: allTrialResults.map((t, idx) => ({
                trialNum: idx + 1,
                condition: t.condition,
                ...t.result.metrics
                }))
            })
            .then(() => console.log("‚úÖ Final summary saved for", participantID))
            .catch(err => console.error("‚ùå Error saving final summary:", err));



        }

        function shareResults() {
            // Calculate the average frequency from the stored results
            const rightTrials = allTrialResults.filter(t => t.condition.hand === 'right');
            const leftTrials = allTrialResults.filter(t => t.condition.hand === 'left');
            
            const calculateAverage = (trials, metric) => {
                const values = trials.map(t => t.result.metrics[metric]);
                return values.reduce((a, b) => a + b, 0) / values.length;
            };
            
            const rightFreq = calculateAverage(rightTrials, 'avgFrequency');
            const leftFreq = calculateAverage(leftTrials, 'avgFrequency');
            const avgFreq = (rightFreq + leftFreq) / 2;
            
            const text = `üéÆ I just tested my finger speed!\n\n‚ö° My tapping speed: ${avgFreq.toFixed(1)} Hz (${(avgFreq * 20).toFixed(0)} taps in 20 seconds)\n\nüèÜ Think you can tap faster? Try it yourself:\n${window.location.origin}`;
            
            if (navigator.share) {
                navigator.share({
                    title: 'My Finger Speed Challenge Results',
                    text: text
                }).catch(err => {
                    // Fallback to clipboard if share fails
                    navigator.clipboard.writeText(text).then(() => {
                        alert('Results copied to clipboard! üìã');
                    });
                });
            } else {
                // Fallback - copy to clipboard
                navigator.clipboard.writeText(text).then(() => {
                    alert('Results copied to clipboard! üìã');
                }).catch(err => {
                    // Final fallback
                    alert('Could not copy results. Your average speed was ' + avgFreq.toFixed(1) + ' Hz');
                });
            }
        }
        // Export all results
        function exportAllResults() {
            const exportData = {
                testDate: new Date().toISOString(),
                summary: {
                    totalTrials: allTrialResults.length,
                    conditions: trialConditions,
                    overallAssessment: document.querySelector('.severity-indicator').textContent
                },
                detailedResults: allTrialResults,
                populationComparisons: POPULATION_NORMS,
                processingParameters: {
                    smoothingWindow: SMOOTHING_WINDOW,
                    minPeakProminence: MIN_PEAK_PROMINENCE,
                    minPeakDistance: MIN_PEAK_DISTANCE
                }
            };

            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `motor_function_analysis_${new Date().toISOString().slice(0, 10)}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // Print results
        function printResults() {
            window.print();
        }

        // Export results as JSON
        function exportResults() {
            if (tapEvents.length === 0) {
                alert('No data to export. Please complete a recording first.');
                return;
            }

            const assessment = calculateClinicalAssessment();
            const exportData = {
                testDate: new Date().toISOString(),
                hand: document.getElementById('handSelect').value,
                assessment: assessment,
                signalData: {
                    raw: distanceSignal,
                    smoothed: smoothedSignal,
                    velocity: velocitySignal,
                    time: timeSignal
                },
                tapEvents: tapEvents,
                processingParameters: {
                    smoothingWindow: SMOOTHING_WINDOW,
                    minPeakProminence: MIN_PEAK_PROMINENCE,
                    minPeakDistance: MIN_PEAK_DISTANCE
                }
            };

            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `pd_finger_tap_advanced_${new Date().toISOString().slice(0, 10)}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // Export data as CSV
        function exportCSV() {
            if (distanceSignal.length === 0) {
                alert('No data to export. Please complete a recording first.');
                return;
            }

            let csv = 'Time (s),Raw Distance,Smoothed Distance,Velocity,Tap Event\n';
            
            for (let i = 0; i < distanceSignal.length; i++) {
                const time = (timeSignal[i] / 1000).toFixed(3);
                const raw = distanceSignal[i].toFixed(2);
                const smooth = i < smoothedSignal.length ? smoothedSignal[i].toFixed(2) : '';
                const vel = i > 0 && i <= velocitySignal.length ? velocitySignal[i-1].toFixed(2) : '';
                const isTap = tapEvents.some(tap => tap.index === i) ? '1' : '0';
                
                csv += `${time},${raw},${smooth},${vel},${isTap}\n`;
            }

            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `pd_finger_tap_signal_${new Date().toISOString().slice(0, 10)}.csv`;
            a.click();
            URL.revokeObjectURL(url);
        }

    
        function showInfoForm() {
                document.getElementById('container-consent').style.display = 'none';
                document.getElementById('container-info').style.display = 'block';
            }

            function startExperiment() {
                // Optionally validate form fields
                const pid = document.getElementById('prolificID').value;
                const age = document.getElementById('age').value;

                            // ‚úÖ Save participant ID so all trials match
                sessionStorage.setItem('prolificID', pid);
                participantID = pid;  // overwrite the anon one


                if (!pid || !age) {
                    alert('Please fill in all required fields.');
                    return;
                }

                document.getElementById('consent-section').style.display = 'none';
                document.querySelector('.container').style.display = 'block';
            }

            let overlayJustDismissed = false; // tracks whether we just closed overlay

            document.addEventListener('keydown', function(e) {
                if (e.code === 'Space' || e.key === ' ') {
                    e.preventDefault(); // prevent page scroll

                    const overlay = document.getElementById('trial-instructions-overlay');
                    const countdownEl = document.getElementById('countdown');
                    const isCountdownActive = countdownEl && countdownEl.style.display === 'block';

                    // CASE 1: If overlay is visible ‚Üí dismiss it and mark flag
// CASE 1: If overlay is visible ‚Üí dismiss it and mark flag
                    if (overlay.style.display === 'block') {
                        overlay.style.display = 'none';
                        document.getElementById('hand-outline').style.display = 'block'; // Show hand outline when overlay is dismissed
                        overlayJustDismissed = true; // next SPACE triggers trial
                        return;
                    }

                    // CASE 2: If we *just* dismissed overlay ‚Üí next SPACE actually starts trial
                    if (overlayJustDismissed) {
                        overlayJustDismissed = false; // reset
                        // Do NOT re-show overlay here
                        if (!handDetected) {
                            alert('Please position your hand in view of the camera before starting.');
                            return;
                        }
                        if (trialIndex >= totalTrials) {
                            alert('All trials complete!');
                            return;
                        }
                        startRecording();
                        return;
                    }

                    // CASE 3: Already in trial or countdown, ignore SPACE
                    if (recording || isCountdownActive) return;

                    // CASE 4: Between trials ‚Üí show overlay for next trial
                    if (trialIndex < totalTrials) {
                        updateConditionUI(); // will show overlay for the *next* trial
                    }
                }
            });


      
        window.onload = function() {
            // ‚úÖ No instructions here, go straight to webcam
            document.getElementById('page-webcam').style.display = 'block';
            initializeHands();
            initializeCamera();
            updateConditionUI();
        };



    </script>
</body>

    <script>

    </script>


</html>
