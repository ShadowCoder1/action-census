<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PD Finger Tapping Webcam Analysis</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background-color: #0a0e27;
            color: #ffffff;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr; /* single column layout */
            width: 100%;
            gap: 20px;
            margin-bottom: 30px;
        }


        .video-container {
            background: #1a1f3a;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
            position: relative;
        }


        .video-wrapper {
            position: relative;
            width: 100%;
            height: 80vh;  /* fills most of screen */
            background: #000;
            border-radius: 10px;
            overflow: hidden;
        }
        video, canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 10px;
        }

        video#inputVideo {
            transform: scaleX(-1);
        }

        canvas#outputCanvas {
            transform: scaleX(-1);
            image-rendering: optimizeSpeed;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: optimize-contrast;
            -ms-interpolation-mode: nearest-neighbor;
        }


        .controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background: #4a5568;
            cursor: not-allowed;
            box-shadow: none;
        }

        .metrics-panel {
            background: #1a1f3a;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
        }

        .metric-card {
            background: linear-gradient(135deg, #1e2139 0%, #2a2d4a 100%);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            border: 1px solid rgba(255,255,255,0.1);
            transition: all 0.3s ease;
        }

        .metric-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .metric-label {
            font-size: 0.9em;
            opacity: 0.8;
            margin-bottom: 5px;
        }

        .metric-value {
            font-size: 2em;
            font-weight: bold;
            color: #667eea;
        }

        .metric-unit {
            font-size: 0.8em;
            opacity: 0.6;
            margin-left: 5px;
        }

        .chart-container {
            grid-column: span 2;
            background: #1a1f3a;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
        }

        .chart-wrapper {
            position: relative;
            height: 300px;
            margin-bottom: 20px;
        }

        .status-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: bold;
            animation: pulse 2s infinite;
        }

        .status-ready {
            background: #48bb78;
            color: white;
        }

        .status-recording {
            background: #ed8936;
            color: white;
        }

        .status-analyzing {
            background: #667eea;
            color: white;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        .instructions {
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .instructions {
            text-align: center;
            font-size: 1.2em;   /* slightly larger text */
            line-height: 1.8;
        }
        .instructions ol {
            display: inline-block; /* keeps list nicely centered */
            text-align: left;      /* keeps numbers aligned */
        }


        .instructions h3 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .instructions ol {
            margin-left: 20px;
            line-height: 1.8;
        }

        .results-summary {
            background: linear-gradient(135deg, #1e2139 0%, #2a2d4a 100%);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            border: 2px solid #667eea;
        }

        .results-summary h3 {
            color: #667eea;
            margin-bottom: 15px;
        }

        .result-item {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .result-item:last-child {
            border-bottom: none;
        }

        .severity-indicator {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 0.9em;
            font-weight: bold;
        }

        .severity-normal { background: #48bb78; }
        .severity-slight { background: #90cdf4; }
        .severity-mild { background: #f6e05e; }
        .severity-moderate { background: #ed8936; }
        .severity-severe { background: #e53e3e; }

        .countdown {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 120px;
            font-weight: bold;
            color: #667eea;
            text-shadow: 0 0 20px rgba(102, 126, 234, 0.8);
            z-index: 10;
            animation: countdownPulse 1s ease-in-out;
        }

        @keyframes countdownPulse {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 0.8; }
        }

        @keyframes tapSuccess {
            0% {
                transform: scale(1);
                opacity: 1;
            }
            100% {
                transform: scale(1.5);
                opacity: 0;
            }
        }

        .hand-indicator {
            display: inline-block;
            padding: 6px 12px;
            border-radius: 8px;
            margin-left: 10px;
            font-size: 0.9em;
            font-weight: bold;
        }

        .hand-left { background: #4299e1; }
        .hand-right { background: #48bb78; }

        .export-section {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }

        .parameter-info {
            font-size: 0.85em;
            opacity: 0.7;
            margin-top: 5px;
            line-height: 1.4;
        }

        .algorithm-status {
            background: rgba(102, 126, 234, 0.2);
            border: 1px solid #667eea;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 15px;
            font-size: 0.9em;
        }

        .final-results {
            max-width: 1200px;
            margin: 0 auto;
            padding: 40px 20px;
        }

        .metric-explanation {
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .metric-explanation h4 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        .metric-explanation p {
            line-height: 1.6;
            margin-bottom: 10px;
        }

        .percentile-indicator {
            display: inline-block;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: bold;
            margin-left: 10px;
        }

        @media (max-width: 1024px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
            
            .chart-container {
                grid-column: span 1;
            }
        }
    </style>


    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore-compat.js"></script>

    <script>
    const firebaseConfig = {
        apiKey: "AIzaSyCIijYBeCcyl8Mt414nueAgIId8PfWaW5M",
        authDomain: "pdstudy-99397.firebaseapp.com",
        projectId: "pdstudy-99397",
        storageBucket: "pdstudy-99397.firebasestorage.app",
        messagingSenderId: "235927780090",
        appId: "1:235927780090:web:348a8c85c130371686a743",
        measurementId: "G-Y116J49LYT"
    };

    firebase.initializeApp(firebaseConfig);
    const db = firebase.firestore();

        // ✅ Always create a consistent participant ID
    let participantID = sessionStorage.getItem('prolificID');
    if (!participantID) {
    participantID = `anon_${Date.now()}`;
    sessionStorage.setItem('prolificID', participantID);
    }

    </script>

</head>
<body>

    <!-- PAGE 2: Webcam Test -->
    <div id="page-webcam" style="display:none;">
    
    <div class="container">
        
        <div class="header">
            <h1>Fast Fingers Challenge: How Quick Are You?</h1>
        </div>
        <div class="instructions" style="text-align:center; font-size:1.3em;">
            Tap your thumb and index finger together as QUICKLY as you can for each trial.
        </div>
        
        

        <div class="main-grid">
            <div class="video-container">
                <div class="status-indicator status-ready" id="status">Ready</div>
                <div id="conditionInfo" style="
                    margin-top: 20px;
                    font-weight: bold;
                    font-size: 2em;           /* much larger */
                    color: #ffdd57;           /* bright yellow */
                    text-align: center;
                    text-transform: uppercase; /* emphasizes RIGHT / LEFT */
                    letter-spacing: 1px;
                    padding: 10px;
                    background: rgba(255, 221, 87, 0.1);
                    border: 2px solid #ffdd57;
                    border-radius: 10px;
                ">
                    Trial Info: —
                </div>

                  <div id="conditionDescription" style="
                    margin-top: 15px;
                    margin-bottom: 20px;
                    font-size: 1.4em;        /* larger font */
                    color: #90cdf4;
                    text-align: center;
                    line-height: 1.6;
                ">
                    <!-- Pace instruction -->
                </div>

              
                <div class="video-wrapper">
                    <video id="inputVideo" autoplay playsinline></video>
                    <canvas id="outputCanvas"></canvas>
                
                    <!-- ✅ NEW overlay for time + taps -->
                    <div id="statusOverlay" style="
                        position: absolute;
                        top: 15px;
                        left: 15px;
                        background: rgba(0, 0, 0, 0.6);
                        padding: 12px 20px;
                        border-radius: 10px;
                        font-size: 2.6em;
                        font-weight: bold;
                        color: #fff;
                        line-height: 1.4;
                        z-index: 50;
                        display: none; /* hidden until recording starts */
                    ">
                        <div id="overlayTime">Time Remaining: 30s</div>
                        <div id="overlayTaps">Taps: 0</div>
                    </div>
                
                    <div id="countdown" class="countdown" style="display: none;"></div>
                </div>
                
                <div class="controls" style="display:none;">
                    <button id="startBtn" onclick="startRecording()">Hidden Start</button>
                </div>
                  
                <div class="algorithm-status" id="algorithmStatus">
                    Press SPACEBAR to begin the test
                </div>
            </div>

    <!-- Real-time metrics removed -->

        </div>

    </div>

    <div id="finalResults" class="final-results" style="display: none;">
        <!-- Final comprehensive results will be inserted here -->
    </div>

    <script>
        // Global variables
        let camera, hands, canvasCtx, recording = false;
        let startTime, handDetected = false;
        let distanceChart, velocityChart;
        let recordingDuration = 20000; // 20 seconds
        let countdownInterval;
        let frameCount = 0;
        let mainTimerInterval;

        // Signal processing variables
        let distanceSignal = [];
        let timeSignal = [];
        let smoothedSignal = [];
        let velocitySignal = [];
        let peakIndices = [];
        let landmarkSeries = []; // stores full landmark history per frame
        let frameData = [];


        let tapEvents = [];
        let lastPeakTime = 0;
        
        // Parameters for signal processing
        const SAMPLE_RATE = 30; // Assumed 30 FPS
        

        const trialConditions = [
            { hand: 'right' },
            { hand: 'right' },
            { hand: 'right' },
            { hand: 'left' },
            { hand: 'left' },
            { hand: 'left' }
        ];


        let trialIndex = 0;
        let totalTrials = trialConditions.length; // now 6 trials total (3 per hand)


        let allTrialResults = []


        const SMOOTHING_WINDOW = 3; // Moving average window
        const MIN_PEAK_PROMINENCE = 0.3; // Minimum prominence for peak detection
        const MIN_PEAK_DISTANCE = 100; // Minimum ms between peaks
        const CLOSED_THRESHOLD_PCT      = 30;  // below this = fingers counted "closed"
        const OPEN_THRESHOLD_PCT        = 35;  // must reopen past this before next tap
        const VELOCITY_THRESHOLD_PERCENTILE = 70; // Percentile for adaptive threshold

        // Hand landmarks indices
        const WRIST = 0;
        const THUMB_TIP = 4;
        const INDEX_TIP = 8;
        const MIDDLE_MCP = 9;

        // Population norms (from literature approximations)
        const POPULATION_NORMS = {
            frequency: {
                healthy: {
                    mean: 2.0,
                    std: 0.5,
                    ranges: [
                    { min: 2.5,  max: 4.0, percentile: 95 },   // very fast, top healthy range
                    { min: 2.0,  max: 2.5, percentile: 75 },   // typical healthy adult
                    { min: 1.5,  max: 2.0, percentile: 50 },   // mild slowing
                    { min: 1.25, max: 1.5, percentile: 25 },   // moderate slowing
                    { min: 0,    max: 1.25, percentile: 5 }    // severe slowing
                    ]
                },
                pd: {
                    mean: 1.4,
                    std: 0.3
                }
            },
            amplitude: {
                healthy: { mean: 50, std: 8, ranges: [
                    { min: 60, max: 80, percentile: 95 },   // very wide, elite
                    { min: 50, max: 60, percentile: 75 },   // typical healthy
                    { min: 40, max: 50, percentile: 50 },   // mild reduction
                    { min: 30, max: 40, percentile: 25 },   // moderate PD range
                    { min: 0,  max: 30, percentile: 5 }     // severe hypometria
                ]}
            },

            rhythmCV: {
                healthy: { mean: 12, std: 3, ranges: [
                    { min: 0, max: 8, percentile: 95 },    // very steady rhythm
                    { min: 8, max: 15, percentile: 75 },   // typical healthy
                    { min: 15, max: 20, percentile: 50 },  // slightly irregular
                    { min: 20, max: 30, percentile: 25 },  // moderate irregularity (PD)
                    { min: 30, max: 50, percentile: 5 }    // severe irregularity
                ]}
            },

            amplitudeDecrement: {
                healthy: { mean: 8, std: 4, ranges: [
                    { min: 0, max: 10, percentile: 95 },   // minimal fatigue
                    { min: 10, max: 20, percentile: 75 },  // mild
                    { min: 20, max: 30, percentile: 50 },  // moderate PD range
                    { min: 30, max: 50, percentile: 25 },  // severe decrement
                    { min: 50, max: 80, percentile: 5 }    // extreme hypometria
                ]}
            }

        };
        
        // Initialize MediaPipe Hands
        function initializeHands() {
            hands = new Hands({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                }
            });

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.7
            });

            hands.onResults(onHandsResults);
        }

        // Initialize camera
        function initializeCamera() {
            const videoElement = document.getElementById('inputVideo');
            const canvasElement = document.getElementById('outputCanvas');
            canvasCtx = canvasElement.getContext('2d');

            // ✅ Request the best available resolution
            navigator.mediaDevices.getUserMedia({
                video: {
                width: { ideal: 1920 },  // Prefer 1080p
                height: { ideal: 1080 },
                facingMode: "user"
                }
            }).then(stream => {
                videoElement.srcObject = stream;

                // Wait until the video actually starts playing
                videoElement.onloadedmetadata = () => {
                // Match canvas resolution to actual camera resolution
                canvasElement.width = videoElement.videoWidth;
                canvasElement.height = videoElement.videoHeight;

                // Start a render loop to process frames manually
                const processFrame = async () => {
                    await hands.send({ image: videoElement });
                    requestAnimationFrame(processFrame);
                };
                requestAnimationFrame(processFrame);
                };
            }).catch(err => {
                console.error("Camera access error:", err);
            });
            }


        // Moving average filter
        function movingAverage(data, windowSize) {
            const result = [];
            for (let i = 0; i < data.length; i++) {
                let start = Math.max(0, i - Math.floor(windowSize / 2));
                let end = Math.min(data.length, i + Math.floor(windowSize / 2) + 1);
                let sum = 0;
                for (let j = start; j < end; j++) {
                    sum += data[j];
                }
                result.push(sum / (end - start));
            }
            return result;
        }

        // Calculate numerical derivative
        function calculateDerivative(data, timeData) {
            const derivative = [];
            for (let i = 1; i < data.length; i++) {
                const dt = (timeData[i] - timeData[i-1]) / 1000; // Convert to seconds
                const dy = data[i] - data[i-1];
                derivative.push(dy / dt);
            }
            return derivative;
        }

        // Find peaks in signal using adaptive thresholding
        function findPeaks(signal, prominence = MIN_PEAK_PROMINENCE) {
            const peaks = [];
            
            // Calculate signal statistics for adaptive thresholding
            const mean = signal.reduce((a, b) => a + b, 0) / signal.length;
            const variance = signal.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / signal.length;
            const std = Math.sqrt(variance);
            
            // Adaptive threshold based on signal statistics
            const threshold = mean + prominence * std;
            
            // Find local maxima above threshold
            for (let i = 1; i < signal.length - 1; i++) {
                if (signal[i] > signal[i-1] && signal[i] > signal[i+1] && signal[i] > threshold) {
                    // Check minimum distance from last peak
                    if (peaks.length === 0 || (timeSignal[i] - timeSignal[peaks[peaks.length - 1]]) > MIN_PEAK_DISTANCE) {
                        peaks.push(i);
                    }
                }
            }
            
            return peaks;
        }

        function detectTapsFromVelocity(velocitySignal, distanceSignal) {
            const taps = [];
            let state = 'open'; // can be 'open', 'closed', or 'must_open'
            let lastTapTime = -Infinity;

            for (let i = 1; i < velocitySignal.length - 1; i++) {
                const t = timeSignal[i];
                const dist = distanceSignal[i];
                const velPrev = velocitySignal[i - 1];
                const velCurr = velocitySignal[i];

                switch (state) {
                    case 'open':
                        if (dist < 30 && velPrev < 0 && velCurr >= 0) {
                            // Fingers just closed — register a tap
                            if ((t - lastTapTime) > MIN_PEAK_DISTANCE) {
                                taps.push({
                                    index: i,
                                    time: t,
                                    amplitude: dist
                                });
                                lastTapTime = t;
                                state = 'must_open';
                            }
                        }
                        break;

                    case 'must_open':
                        if (dist > 35) {
                            state = 'open';
                        }
                        break;

                    default:
                        // fallback in case of unexpected state
                        state = 'open';
                }
            }

            return taps;
        }



        // Process hand detection results
   // Process hand detection results
        function onHandsResults(results) {
            const canvasElement = document.getElementById('outputCanvas');
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            
            // Draw the image
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                handDetected = true;
                
                // Update status to show hand detected
                if (!recording && document.getElementById('status').textContent === 'Ready') {
                    document.getElementById('algorithmStatus').textContent = 'Hand detected! Press SPACEBAR to begin';
                }
                const landmarks = results.multiHandLandmarks[0];

                const handedness = results.multiHandedness?.[0]?.label || "Unknown";
                if ((trialConditions[trialIndex % trialConditions.length].hand === "Right" && handedness !== "Right") ||
                    (trialConditions[trialIndex % trialConditions.length].hand === "Left" && handedness !== "Left")) {
                    return; // Skip frames with wrong hand
                }
                
                // REMOVED: Draw hand skeleton - we only want thumb and index visualization

                // Process finger tap data if recording
                if (recording) {
                    processFingerTapAdvanced(landmarks, results.image.width, results.image.height);
                }

                // Get thumb and index fingertips
                const thumbTip = landmarks[THUMB_TIP];
                const indexTip = landmarks[INDEX_TIP];
                
                // Calculate distance for color determination
                const distance = Math.sqrt(
                    Math.pow((thumbTip.x - indexTip.x) * canvasElement.width, 2) +
                    Math.pow((thumbTip.y - indexTip.y) * canvasElement.height, 2)
                );
                
                // Determine if fingers are currently tapping (close together)
                const isTapping = recording && distance < 30; // Threshold for "tapped" state
                
                // Check if we just detected a new tap
                let justTapped = false;
                if (recording && tapEvents.length > 0) {
                    const currentTime = Date.now() - startTime;
                    const lastTap = tapEvents[tapEvents.length - 1];
                    // If the last tap was within 150ms, show green feedback
                    justTapped = (currentTime - lastTap.time) < 150;
                }
                
                // Set colors based on state
                // Set colors based on state - ENHANCED VISIBILITY
                let dotColor = '#9ca3af'; // Brighter grey
                let lineColor = 'rgba(156, 163, 175, 0.8)'; // More visible grey
                let dotSize = 14; // Larger default size
                let borderColor = '#ffffff'; // White border for visibility
                
                if (justTapped) {
                    // Just completed a tap - bright green with larger size
                    dotColor = '#10f981'; // Brighter emerald green
                    lineColor = 'rgba(16, 249, 129, 1)'; // Full opacity bright green
                    dotSize = 20; // Even larger for emphasis
                    borderColor = '#ffffff'; // Keep white border
                    
                    // Add glow effect
                    canvasCtx.shadowBlur = 20;
                    canvasCtx.shadowColor = '#10b981';
                } else if (isTapping) {
                    // Currently tapping (fingers close) - lighter green
                    dotColor = '#34d399';
                    lineColor = 'rgba(52, 211, 153, 0.6)';
                    dotSize = 12;
                }
                
                // Draw line between thumb and index with color
                canvasCtx.strokeStyle = lineColor;
                canvasCtx.lineWidth = 3;
                canvasCtx.beginPath();
                canvasCtx.moveTo(thumbTip.x * canvasElement.width, thumbTip.y * canvasElement.height);
                canvasCtx.lineTo(indexTip.x * canvasElement.width, indexTip.y * canvasElement.height);
                canvasCtx.stroke();
                
                // Draw larger circles for thumb with color and potential glow
// Draw larger circles for thumb with white border for visibility
                // First draw white border
                canvasCtx.fillStyle = borderColor;
                canvasCtx.beginPath();
                canvasCtx.arc(thumbTip.x * canvasElement.width, thumbTip.y * canvasElement.height, dotSize + 2, 0, 2 * Math.PI);
                canvasCtx.fill();

                // Then draw colored dot
                canvasCtx.fillStyle = dotColor;
                canvasCtx.beginPath();
                canvasCtx.arc(thumbTip.x * canvasElement.width, thumbTip.y * canvasElement.height, dotSize, 0, 2 * Math.PI);
                canvasCtx.fill();
                
                // Draw index finger dot
                // Draw index finger dot with white border
                // First draw white border
                canvasCtx.fillStyle = borderColor;
                canvasCtx.beginPath();
                canvasCtx.arc(indexTip.x * canvasElement.width, indexTip.y * canvasElement.height, dotSize + 2, 0, 2 * Math.PI);
                canvasCtx.fill();

                // Then draw colored dot
                canvasCtx.fillStyle = dotColor;
                canvasCtx.beginPath();
                canvasCtx.arc(indexTip.x * canvasElement.width, indexTip.y * canvasElement.height, dotSize, 0, 2 * Math.PI);
                canvasCtx.fill();
                
                // Reset shadow for next frame
                canvasCtx.shadowBlur = 0;
                
                // Add tap success indicator (floating +1 effect)
                if (justTapped && tapEvents.length > 0) {
                    const midX = (thumbTip.x + indexTip.x) / 2 * canvasElement.width;
                    const midY = (thumbTip.y + indexTip.y) / 2 * canvasElement.height;
                    
                    // Draw success text
                    canvasCtx.font = 'bold 24px Arial';
                    canvasCtx.fillStyle = '#10b981';
                    canvasCtx.textAlign = 'center';
                    canvasCtx.shadowBlur = 10;
                    canvasCtx.shadowColor = '#10b981';
                    
                    // Calculate fade based on time since tap
                    const timeSinceTap = (Date.now() - startTime) - tapEvents[tapEvents.length - 1].time;
                    const fadeOpacity = Math.max(0, 1 - (timeSinceTap / 150));
                    canvasCtx.globalAlpha = fadeOpacity;
                    
                    canvasCtx.fillText('✓', midX, midY - 20);
                    canvasCtx.globalAlpha = 1; // Reset opacity
                    canvasCtx.shadowBlur = 0;
                }
                
                // Remove the old peak detection visualization since we have the new feedback
                
            } else {
                handDetected = false;
                // Update status when hand not detected
                if (!recording && document.getElementById('status').textContent === 'Ready') {
                    document.getElementById('algorithmStatus').textContent = 'Position your hand in view, then press SPACEBAR';
                }
            }

            canvasCtx.restore();
        }

        // MediaPipe hand connections
        const HAND_CONNECTIONS = [
            [0, 1], [1, 2], [2, 3], [3, 4],
            [0, 5], [5, 6], [6, 7], [7, 8],
            [5, 9], [9, 10], [10, 11], [11, 12],
            [9, 13], [13, 14], [14, 15], [15, 16],
            [13, 17], [17, 18], [18, 19], [19, 20],
            [0, 17]
        ];

        // Helper functions for drawing
        function drawConnectors(ctx, landmarks, connections, style) {
            ctx.strokeStyle = style.color;
            ctx.lineWidth = style.lineWidth;
            
            connections.forEach(([start, end]) => {
                const startLandmark = landmarks[start];
                const endLandmark = landmarks[end];
                
                ctx.beginPath();
                ctx.moveTo(startLandmark.x * ctx.canvas.width, startLandmark.y * ctx.canvas.height);
                ctx.lineTo(endLandmark.x * ctx.canvas.width, endLandmark.y * ctx.canvas.height);
                ctx.stroke();
            });
        }

        function drawLandmarks(ctx, landmarks, style) {
            ctx.fillStyle = style.color;
            
            landmarks.forEach(landmark => {
                ctx.beginPath();
                ctx.arc(landmark.x * ctx.canvas.width, landmark.y * ctx.canvas.height, 
                       style.radius, 0, 2 * Math.PI);
                ctx.fill();
            });
        }

        // Advanced finger tap processing with signal analysis
        function processFingerTapAdvanced(landmarks, imageWidth, imageHeight) {
            const currentTime = Date.now() - startTime;
            frameCount++;
            
            // Calculate 3D distance between thumb and index tips
            const thumbTip = landmarks[THUMB_TIP];
            const indexTip = landmarks[INDEX_TIP];
            const wrist = landmarks[WRIST];
            const middleMcp = landmarks[MIDDLE_MCP];
            
            // Calculate hand size for normalization
            const handSize = Math.sqrt(
                Math.pow((wrist.x - middleMcp.x) * imageWidth, 2) +
                Math.pow((wrist.y - middleMcp.y) * imageHeight, 2)
            );
            
            // Calculate normalized distance
            const distance = Math.sqrt(
                Math.pow((thumbTip.x - indexTip.x) * imageWidth, 2) +
                Math.pow((thumbTip.y - indexTip.y) * imageHeight, 2) +
                Math.pow((thumbTip.z - indexTip.z) * imageWidth * 0.5, 2) // Z depth with reduced weight
            );
            
            const normalizedDistance = (distance / handSize) * 100;
            
            // Add to signal arrays
            distanceSignal.push(normalizedDistance);
            timeSignal.push(currentTime);
            
            // Apply signal processing every few frames
            if (frameCount % 2 === 0 && distanceSignal.length > SMOOTHING_WINDOW) {
                // Smooth the signal
                smoothedSignal = movingAverage(distanceSignal, SMOOTHING_WINDOW);
                
                // Calculate velocity
                if (smoothedSignal.length > 1) {
                    velocitySignal = calculateDerivative(smoothedSignal, timeSignal);
                    
                    // Detect taps using multiple methods
                    detectTapsMultiMethod();
                }
                
                // Update real-time metrics
                //updateRealtimeMetrics();
                
                // Update charts
                //updateCharts();
            }

            if (!frameData) frameData = [];  // ✅ guarantee array exists
            frameData.push({
                timestamp: currentTime,
                normalizedDistance: normalizedDistance,
                // Angle between thumb and index for extra detail
                thumbIndexAngle: Math.atan2(
                    (indexTip.y - thumbTip.y),
                    (indexTip.x - thumbTip.x)
                ) * 180 / Math.PI,
                handSize: handSize,
                // Save all key landmarks
                thumbTip: { x: thumbTip.x, y: thumbTip.y, z: thumbTip.z },
                indexTip: { x: indexTip.x, y: indexTip.y, z: indexTip.z },
                wrist: { x: wrist.x, y: wrist.y, z: wrist.z },
                middleMcp: { x: middleMcp.x, y: middleMcp.y, z: middleMcp.z },
                rawLandmarks: landmarks.map(lm => ({ x: lm.x, y: lm.y, z: lm.z }))
            });

        }

        // Multi-method tap detection for robustness
        function detectTapsMultiMethod() {
            const rawEvents = [];            // collect all raw detections here
            const added     = new Set();     // prevent duplicate indices

            /* --------- 1. Velocity zero-crossings (most reliable) --------- */
            detectTapsFromVelocity(velocitySignal, smoothedSignal).forEach(ev => {
                if (!added.has(ev.index)) { rawEvents.push(ev); added.add(ev.index); }
            });

            /* --------- 2. Distance-based peaks at full closure --------- */
            const inverted = smoothedSignal.map(d => 100 - d);
            findPeaks(inverted, 0.5).forEach(idx => {
                if (smoothedSignal[idx] < CLOSED_THRESHOLD_PCT && !added.has(idx)) {
                    rawEvents.push({ index: idx, time: timeSignal[idx], amplitude: smoothedSignal[idx] });
                    added.add(idx);
                }
            });

            /* --------- ➊ sort by time, ➋ enforce reopen gate --------- */
            rawEvents.sort((a, b) => a.time - b.time);
            tapEvents = [];

            for (const ev of rawEvents) {
                if (tapEvents.length === 0) {          // always accept the first tap
                    tapEvents.push(ev);
                    continue;
                }

                const last = tapEvents[tapEvents.length - 1];

                // (a) honour MIN_PEAK_DISTANCE
                if (ev.time - last.time < MIN_PEAK_DISTANCE) continue;

                // (b) NEW — require signal to reopen past OPEN_THRESHOLD_PCT
                let reopened = false;
                for (let i = last.index + 1; i < ev.index; i++) {
                    if (smoothedSignal[i] > OPEN_THRESHOLD_PCT) { reopened = true; break; }
                }
                if (!reopened) continue;              // still the same closed dwell

                tapEvents.push(ev);
                // Update tap counter display
                if (recording) {
                    document.getElementById('overlayTaps').textContent = `Taps: ${tapEvents.length}`;

                }
            }
        }

        // Find local minima in signal
        function findMinima(signal) {
            const minima = [];
            for (let i = 1; i < signal.length - 1; i++) {
                if (signal[i] < signal[i-1] && signal[i] < signal[i+1]) {
                    minima.push(i);
                }
            }
            return minima;
        }

        // Update real-time metrics display
        function updateRealtimeMetrics() {
            if (tapEvents.length === 0) return;
            
            // Tap count
            document.getElementById('tapCount').textContent = tapEvents.length;
            
            // Calculate inter-tap intervals and metrics
            if (tapEvents.length > 1) {
                const intervals = [];
                const amplitudes = [];
                
                for (let i = 1; i < tapEvents.length; i++) {
                    intervals.push(tapEvents[i].time - tapEvents[i-1].time);
                }
                
                // Get peak amplitudes (maximum distance between taps)
                for (let i = 0; i < tapEvents.length - 1; i++) {
                    const startIdx = tapEvents[i].index;
                    const endIdx = tapEvents[i+1].index;
                    let maxAmp = 0;
                    for (let j = startIdx; j < endIdx && j < smoothedSignal.length; j++) {
                        maxAmp = Math.max(maxAmp, smoothedSignal[j]);
                    }
                    amplitudes.push(maxAmp);
                }
                
                // Average frequency
                const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
                const frequency = 1000 / avgInterval;
                document.getElementById('avgFrequency').innerHTML = frequency.toFixed(2) + '<span class="metric-unit">Hz</span>';
                
                // Average amplitude
                if (amplitudes.length > 0) {
                    const avgAmplitude = amplitudes.reduce((a, b) => a + b, 0) / amplitudes.length;
                    document.getElementById('avgAmplitude').innerHTML = avgAmplitude.toFixed(1) + '<span class="metric-unit">%</span>';
                    
                    // Amplitude decrement
                    if (amplitudes.length >= 3) {
                        const firstThird = amplitudes.slice(0, Math.floor(amplitudes.length / 3));
                        const lastThird = amplitudes.slice(-Math.floor(amplitudes.length / 3));
                        const firstAvg = firstThird.reduce((a, b) => a + b, 0) / firstThird.length;
                        const lastAvg = lastThird.reduce((a, b) => a + b, 0) / lastThird.length;
                        const decrement = ((firstAvg - lastAvg) / firstAvg) * 100;
                        document.getElementById('ampDecrement').innerHTML = decrement.toFixed(1) + '<span class="metric-unit">%</span>';
                    }
                }
                
                // Rhythm variability
                const mean = intervals.reduce((a, b) => a + b, 0) / intervals.length;
                const variance = intervals.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / intervals.length;
                const std = Math.sqrt(variance);
                const cv = (std / mean) * 100;
                document.getElementById('rhythmCV').innerHTML = cv.toFixed(1) + '<span class="metric-unit">%</span>';
                
                // Hesitations
                const hesitations = intervals.filter(i => i > 500).length;
                document.getElementById('hesitations').textContent = hesitations;
            }
        }

        // Initialize charts
        function initializeCharts() {
            const chartOptions = {
                responsive: true,
                maintainAspectRatio: false,
                animation: {
                    duration: 0
                },
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Time (seconds)',
                            color: '#ffffff'
                        },
                        ticks: { color: '#ffffff' },
                        grid: { color: 'rgba(255, 255, 255, 0.1)' }
                    },
                    y: {
                        ticks: { color: '#ffffff' },
                        grid: { color: 'rgba(255, 255, 255, 0.1)' }
                    }
                },
                plugins: {
                    legend: {
                        labels: { color: '#ffffff' }
                    }
                }
            };

            // Distance chart
            const distCtx = document.getElementById('distanceChart').getContext('2d');
            distanceChart = new Chart(distCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Finger Distance',
                        data: [],
                        borderColor: '#667eea',
                        backgroundColor: 'rgba(102, 126, 234, 0.1)',
                        tension: 0.1,
                        pointRadius: 0
                    }, {
                        label: 'Smoothed',
                        data: [],
                        borderColor: '#48bb78',
                        backgroundColor: 'rgba(72, 187, 120, 0.1)',
                        tension: 0.1,
                        pointRadius: 0
                    }, {
                        label: 'Detected Taps',
                        data: [],
                        borderColor: '#e53e3e',
                        backgroundColor: '#e53e3e',
                        showLine: false,
                        pointRadius: 8,
                        pointStyle: 'triangle'
                    }]
                },
                options: {
                    ...chartOptions,
                    scales: {
                        ...chartOptions.scales,
                        y: {
                            ...chartOptions.scales.y,
                            title: {
                                display: true,
                                text: 'Distance (% hand size)',
                                color: '#ffffff'
                            }
                        }
                    }
                }
            });

            // Velocity chart
            const velCtx = document.getElementById('velocityChart').getContext('2d');
            velocityChart = new Chart(velCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Velocity',
                        data: [],
                        borderColor: '#ed8936',
                        backgroundColor: 'rgba(237, 137, 54, 0.1)',
                        tension: 0.1,
                        pointRadius: 0
                    }, {
                        label: 'Zero Line',
                        data: [],
                        borderColor: 'rgba(255, 255, 255, 0.3)',
                        borderDash: [5, 5],
                        pointRadius: 0
                    }]
                },
                options: {
                    ...chartOptions,
                    scales: {
                        ...chartOptions.scales,
                        y: {
                            ...chartOptions.scales.y,
                            title: {
                                display: true,
                                text: 'Velocity (% hand size/s)',
                                color: '#ffffff'
                            }
                        }
                    }
                }
            });
        }

        // Update charts with new data
        function updateCharts() {
            if (distanceSignal.length < 2) return;

            // Prepare time labels
            const timeLabels = timeSignal.map(t => (t / 1000).toFixed(2));
            
            // Update distance chart
            distanceChart.data.labels = timeLabels;
            distanceChart.data.datasets[0].data = distanceSignal;
            distanceChart.data.datasets[1].data = smoothedSignal;
            
            // Add tap markers
            const tapData = new Array(distanceSignal.length).fill(null);
            tapEvents.forEach(tap => {
                if (tap.index < tapData.length) {
                    tapData[tap.index] = smoothedSignal[tap.index];
                }
            });
            distanceChart.data.datasets[2].data = tapData;
            
            distanceChart.update('none');

            // Update velocity chart
            if (velocitySignal.length > 0) {
                const velTimeLabels = timeSignal.slice(1).map(t => (t / 1000).toFixed(2));
                velocityChart.data.labels = velTimeLabels;
                velocityChart.data.datasets[0].data = velocitySignal;
                velocityChart.data.datasets[1].data = new Array(velocitySignal.length).fill(0);
                velocityChart.update('none');
            }
        }

        // Start recording with countdown and condition tracking
        function startRecording() {
            if (!handDetected) {
                alert('Please position your hand in view of the camera before starting.');
                return;
            }

            // Check if all trials are done
            if (trialIndex >= totalTrials) {
                alert('All trials complete!');
                return;
            }

            // Update condition UI and hand selector
            updateConditionUI();

            // Reset all data
            distanceSignal = [];
            timeSignal = [];
            smoothedSignal = [];
            velocitySignal = [];
            tapEvents = [];
            frameCount = 0;
            frameData = []; // Reset before trial


            // Start countdown
            let countdown = 3;
            const countdownEl = document.getElementById('countdown');
            countdownEl.style.display = 'block';
            countdownEl.textContent = countdown;



            countdownInterval = setInterval(() => {
                countdown--;
                if (countdown > 0) {
                    countdownEl.textContent = countdown;
                    countdownEl.style.animation = 'none';
                    setTimeout(() => {
                        countdownEl.style.animation = 'countdownPulse 1s ease-in-out';
                    }, 10);
                } else {
                    clearInterval(countdownInterval);
                    countdownEl.style.display = 'none';
                    startActualRecording();
                }
            }, 1000);
        }

        // Start actual recording
        function startActualRecording() {
            recording = true;
            startTime = Date.now();
            distanceSignal = [];
            timeSignal = [];
            smoothedSignal = [];
            velocitySignal = [];
            tapEvents = [];
            frameCount = 0;
            document.getElementById('status').textContent = 'Recording';
            document.getElementById('status').className = 'status-indicator status-recording';
            document.getElementById('algorithmStatus').textContent = 'Algorithm: Recording signal data...';

            // Show new combined overlay
            const overlay = document.getElementById('statusOverlay');
            overlay.style.display = 'block';
            document.getElementById('overlayTime').textContent = `Time Remaining: 30s`;
            document.getElementById('overlayTaps').textContent = `Taps: 0`;

            
            // Update timer every 100ms for smooth display
            mainTimerInterval = setInterval(() => {
                const elapsed = Date.now() - startTime;
                const remaining = Math.max(0, Math.ceil((recordingDuration - elapsed) / 1000));
                document.getElementById('overlayTime').textContent = `Time Remaining: ${remaining}s`;

                
                                // Change color to red in the last 3 seconds
                if (remaining <= 3 && remaining > 0) {
                    document.getElementById('overlayTime').style.color = 'red';
                } else {
                    document.getElementById('overlayTime').style.color = '#fff'; // default white
                }

            }, 100);

            // Auto-stop after 30 seconds
            setTimeout(() => {
                if (recording) {
                    stopRecording();
                }
            }, recordingDuration);
        }

        function stopRecording() {
            recording = false;
            
            // Clear timer
            clearInterval(mainTimerInterval);
            document.getElementById('statusOverlay').style.display = 'none';

            document.getElementById('countdown').style.display = 'none';
            
            document.getElementById('status').textContent = 'Analyzing';
            document.getElementById('status').className = 'status-indicator status-analyzing';
            document.getElementById('algorithmStatus').textContent = 'Algorithm: Processing signal and detecting peaks...';

            // Perform final analysis
            setTimeout(() => {
                // Calculate and store results
                const result = calculateClinicalAssessment();

                // Get subject name (Prolific ID) from sessionStorage
                const subjectName = sessionStorage.getItem('prolificID') || 'anonymous';

                // Prepare trial document name
// ✅ Unified write: summary + raw frame data in one place
                const trialDocName = `trial_${trialIndex + 1}`;
// ✅ Save full trial metrics & raw signals in one document
                const trialData = {
                trialNumber: trialIndex + 1,
                condition: trialConditions[trialIndex % trialConditions.length],
                timestamp: new Date().toISOString(),

                // same metrics shown on UI
                metrics: result.metrics,
                score: result.score,
                details: result.details,

                // full signal arrays
                signals: {
                    time: timeSignal,
                    rawDistance: distanceSignal,
                    smoothedDistance: smoothedSignal,
                    velocity: velocitySignal,
                    taps: tapEvents
                },

                // ✅ save only first 500 frames to avoid hitting Firestore size limit
                frameData: frameData.slice(0, 500)
                };

                db.collection("Participants")
                .doc(participantID)
                .collection("Trials")
                .doc(trialDocName)
                .set(trialData)
                .then(() => console.log(`✅ Trial ${trialDocName} saved for ${participantID}`))
                .catch(err => console.error("❌ Error saving trial data:", err));

                allTrialResults.push({
                    condition: trialConditions[trialIndex % trialConditions.length],
                    repetition: Math.floor(trialIndex / trialConditions.length) + 1,
                    result: result
                });

                // Skip showing intermediate trial UI (we removed metrics)
                trialIndex++;

                if (trialIndex < totalTrials) {
                    // Setup for next trial
                    document.getElementById('status').textContent = 'Ready for Next Trial';
                    document.getElementById('status').className = 'status-indicator status-ready';
                    document.getElementById('algorithmStatus').textContent = 'Click "Start Next Trial" to continue.';

                        // Add instruction to press spacebar for next trial
                    document.getElementById('algorithmStatus').textContent = 'Press SPACEBAR to start the next trial.';
                    // Update condition info for next trial
                    updateConditionUI();

                } else {
                    // All trials complete - show comprehensive results
                    analyzeAllTrials();
                }


            }, 500);
        }

        // Display brief trial complete message
        function displayTrialComplete(assessment) {
            const resultsDiv = document.getElementById('resultsDiv');
            const assessmentResults = document.getElementById('assessmentResults');
            
            resultsDiv.style.display = 'block';
            
            let html = `
                <div class="result-item">
                    <span>Taps Detected:</span>
                    <span>${assessment.metrics.tapCount}</span>
                </div>
                <div class="result-item">
                    <span>Average Frequency:</span>
                    <span>${assessment.metrics.avgFrequency.toFixed(2)} Hz</span>
                </div>
                <div class="result-item">
                    <span>Trial Duration:</span>
                    <span>${assessment.metrics.testDuration.toFixed(1)} seconds</span>
                </div>
                <div class="result-item">
                    <span>Trials Remaining:</span>
                    <span>${totalTrials - trialIndex}</span>
                </div>
            `;
            
            assessmentResults.innerHTML = html;
        }

        // Calculate clinical assessment based on MDS-UPDRS criteria
        function calculateClinicalAssessment() {
            const tapCount = tapEvents.length;
            const intervals = [];
            const amplitudes = [];
            
            // Calculate intervals and amplitudes
            for (let i = 1; i < tapEvents.length; i++) {
                intervals.push(tapEvents[i].time - tapEvents[i-1].time);
            }
            
            // Get peak amplitudes between taps
            for (let i = 0; i < tapEvents.length - 1; i++) {
                const startIdx = tapEvents[i].index;
                const endIdx = tapEvents[i+1].index;
                let maxAmp = 0;
                for (let j = startIdx; j < endIdx && j < smoothedSignal.length; j++) {
                    maxAmp = Math.max(maxAmp, smoothedSignal[j]);
                }
                amplitudes.push(maxAmp);
            }
            
            // Calculate metrics
            const avgFrequency = intervals.length > 0 ? 1000 / (intervals.reduce((a, b) => a + b, 0) / intervals.length) : 0;
            const avgAmplitude = amplitudes.length > 0 ? amplitudes.reduce((a, b) => a + b, 0) / amplitudes.length : 0;
            
            // Amplitude decrement
            let amplitudeDecrement = 0;
            if (amplitudes.length >= 3) {
                const firstThird = amplitudes.slice(0, Math.floor(amplitudes.length / 3));
                const lastThird = amplitudes.slice(-Math.floor(amplitudes.length / 3));
                const firstAvg = firstThird.reduce((a, b) => a + b, 0) / firstThird.length;
                const lastAvg = lastThird.reduce((a, b) => a + b, 0) / lastThird.length;
                amplitudeDecrement = ((firstAvg - lastAvg) / firstAvg) * 100;
            }
            
            // Rhythm variability
            let rhythmCV = 0;
            if (intervals.length > 0) {
                const mean = intervals.reduce((a, b) => a + b, 0) / intervals.length;
                const variance = intervals.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / intervals.length;
                rhythmCV = (Math.sqrt(variance) / mean) * 100;
            }
            
            // Hesitations and freezing
            const hesitations = intervals.filter(i => i > 500 && i < 1000).length;
            const freezing = intervals.filter(i => i >= 1000).length;
            
            // Speed-amplitude index (novel composite measure)
            const speedAmplitudeIndex = avgFrequency * (avgAmplitude / 100);
            
            // Clinical scoring based on MDS-UPDRS criteria
            let score = 0;
            let details = [];
            
            if (avgFrequency < 1.25) {
                score = Math.max(score, 3);
                details.push("Severe slowing (<1.25 Hz)");
            } else if (avgFrequency < 2.0) {
                score = Math.max(score, 2);
                details.push("Moderate slowing (1.25–2.0 Hz)");
            } else if (avgFrequency < 2.5) {
                score = Math.max(score, 1);
                details.push("Slight slowing (2.0–2.5 Hz)");
            } // ≥2.5 Hz = normal (score 0)

            
            // Amplitude assessment
            if (avgAmplitude < 20) {
                score = Math.max(score, 2);
                details.push("Small amplitude movements");
            }
            
            // Amplitude decrement assessment
            if (amplitudeDecrement > 50) {
                score = Math.max(score, 3);
                details.push("Severe amplitude decrement");
            } else if (amplitudeDecrement > 30) {
                score = Math.max(score, 2);
                details.push("Amplitude decrements midway");
            } else if (amplitudeDecrement > 15) {
                score = Math.max(score, 1);
                details.push("Amplitude decrements near the end");
            }
            
            // Hesitations/interruptions
            if (freezing > 0) {
                score = Math.max(score, 3);
                details.push(`${freezing} freezing episode(s)`);
            } else if (hesitations >= 5) {
                score = Math.max(score, 3);
                details.push("More than 5 interruptions");
            } else if (hesitations >= 3) {
                score = Math.max(score, 2);
                details.push("3-5 interruptions");
            } else if (hesitations >= 1) {
                score = Math.max(score, 1);
                details.push("1-2 interruptions");
            }
            
            // Rhythm irregularity
            if (rhythmCV > 40) {
                score = Math.max(score, 2);
                details.push("Significant rhythm irregularity");
            } else if (rhythmCV > 25) {
                score = Math.max(score, 1);
                details.push("Mild rhythm irregularity");
            }
            
            return {
                score: score,
                details: details,
                metrics: {
                    tapCount: tapCount,
                    avgFrequency: avgFrequency,
                    avgAmplitude: avgAmplitude,
                    amplitudeDecrement: amplitudeDecrement,
                    rhythmCV: rhythmCV,
                    hesitations: hesitations,
                    freezing: freezing,
                    speedAmplitudeIndex: speedAmplitudeIndex,
                    testDuration: (timeSignal[timeSignal.length - 1] || 0) / 1000,
                    signalQuality: {
                        framesProcessed: frameCount,
                        samplingRate: frameCount / ((timeSignal[timeSignal.length - 1] || 1) / 1000),
                        detectionsConfidence: tapEvents.length / (frameCount / 30)
                    }
                }
            };
        }

        function updateConditionUI() {
            const trialNum = trialIndex + 1;
            const condition = trialConditions[trialIndex % trialConditions.length];

            // Pick a color dynamically based on hand
            let handColor = (condition.hand === 'right') ? '#48bb78' : '#4299e1'; 
            
            const conditionEl = document.getElementById('conditionInfo');
            conditionEl.innerHTML =
                `Trial ${trialNum} of ${totalTrials} — Tap your <span style="color:${handColor}; font-size:1.4em;">${condition.hand.toUpperCase()} HAND</span> as quickly as you can for 20 seconds`

            updateConditionDescription();
        }
        
        function updateConditionDescription() {
            const msg = "Tap your thumb and index finger together as QUICKLY as you can for 20 seconds.";

            document.getElementById('conditionDescription').textContent = msg;
        }

        function getPercentile(value, metric) {
            const ranges = POPULATION_NORMS[metric]?.healthy?.ranges;
            if (!ranges) return null;
            
            for (let range of ranges) {
                if (value >= range.min && value <= range.max) {
                    return range.percentile;
                }
            }
            return 50; // default
        }

        function calculatePercentileFromNorm(value, metric) {
            const ranges = POPULATION_NORMS[metric]?.healthy?.ranges;
            if (!ranges) {
                // Fallback to z-score calculation if no ranges
                const norm = POPULATION_NORMS[metric]?.healthy;
                if (!norm) return 50;
                const zScore = (value - norm.mean) / norm.std;
                const percentile = 50 + (zScore * 16);
                return Math.max(1, Math.min(99, Math.round(percentile)));
            }
            
            // Use actual ranges for accurate percentiles
            for (let range of ranges) {
                if (value >= range.min && value <= range.max) {
                    // Interpolate within the range
                    const rangeSize = range.max - range.min;
                    const position = (value - range.min) / rangeSize;
                    
                    // Find the next percentile bracket
                    let nextPercentile = range.percentile;
                    let prevPercentile = range.percentile;
                    
                    if (range.percentile === 95) {
                        prevPercentile = 75;
                    } else if (range.percentile === 75) {
                        nextPercentile = 95;
                        prevPercentile = 50;
                    } else if (range.percentile === 50) {
                        nextPercentile = 75;
                        prevPercentile = 25;
                    } else if (range.percentile === 25) {
                        nextPercentile = 50;
                        prevPercentile = 5;
                    } else if (range.percentile === 5) {
                        nextPercentile = 25;
                    }
                    
                    // Interpolate
                    const percentileDiff = nextPercentile - prevPercentile;
                    const interpolated = prevPercentile + (position * percentileDiff);
                    
                    return Math.max(1, Math.min(99, Math.round(interpolated)));
                }
            }
            
            // If value is outside all ranges
            if (value > ranges[0].max) return 99;
            if (value < ranges[ranges.length - 1].min) return 1;
            return 50;
        }

        function analyzeAllTrials() {
            // Hide the main interface
            document.querySelector('.container').style.display = 'none';
            document.getElementById('finalResults').style.display = 'block';
            
                        // Separate by hand
            let rightTrials = allTrialResults.filter(t => t.condition.hand === 'right');
            let leftTrials = allTrialResults.filter(t => t.condition.hand === 'left');

            // Calculate averages for each condition
            const calculateAverage = (trials, metric) => {
                const values = trials.map(t => t.result.metrics[metric]);
                return values.reduce((a, b) => a + b, 0) / values.length;
            };
            
          
    // Calculate metrics
            const rightFastFreq = calculateAverage(rightTrials, 'avgFrequency');
            const leftFastFreq = calculateAverage(leftTrials, 'avgFrequency');
            const avgFastFreq = (rightFastFreq + leftFastFreq) / 2;

            const avgDecrement = (
                calculateAverage(rightTrials, 'amplitudeDecrement') +
                calculateAverage(leftTrials, 'amplitudeDecrement')
            ) / 2;

            const avgRhythmCV = (
                calculateAverage(rightTrials, 'rhythmCV') +
                calculateAverage(leftTrials, 'rhythmCV')
            ) / 2;

            const avgSpeedAmpIndex = (
                calculateAverage(rightTrials, 'speedAmplitudeIndex') +
                calculateAverage(leftTrials, 'speedAmplitudeIndex')
            ) / 2;

            const asymmetry = Math.abs(rightFastFreq - leftFastFreq) / Math.max(rightFastFreq, leftFastFreq) * 100;
            // ✅ Aggregate hesitations/freezing for all trials
            let totalHesitations = 0;
            let totalFreezing = 0;
            allTrialResults.forEach(trial => {
                totalHesitations += trial.result.metrics.hesitations || 0;
                totalFreezing += trial.result.metrics.freezing || 0;
            });
            const hesitations = Math.round(totalHesitations / allTrialResults.length);
            const freezing = Math.round(totalFreezing / allTrialResults.length);

            // Calculate hesitations and freezing across all trials
    
            // Create fun report
            let html = `
                <div class="header" style="margin-bottom: 40px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
                    <h1 style="font-size: 3em; margin-bottom: 20px;">🎯 Your Finger Speed Results!</h1>
                    <p style="font-size: 1.5em;">How fast can your brain control your fingers?</p>
                </div>
                
                <div style="text-align: center; margin-bottom: 40px; padding: 30px; background: rgba(255,255,255,0.05); border-radius: 20px;">
                    <h2 style="color: #667eea; font-size: 2.5em; margin-bottom: 20px;">Your Speed Score</h2>
                    <div style="font-size: 5em; font-weight: bold; color: #ffdd57; text-shadow: 0 0 20px rgba(255, 221, 87, 0.5);">
                        ${avgFastFreq.toFixed(1)} Hz
                    </div>
                    <p style="font-size: 1.3em; margin-top: 20px; color: #90cdf4;">
                        You tap ${(avgFastFreq * 20).toFixed(0)} times in 20 seconds!<br>
                        Most people tap at 2-3 Hz (40-60 taps)
                    </p>
                </div>
            `;
            // Add detailed metric explanations with percentiles
            const metrics = [
                {
                    name: '⚡ Speed',
                    value: avgFastFreq,
                    unit: 'Hz',
                    explanation: 'How fast you can tap! Like a video game, higher is better. Most adults tap at 2-3 times per second.',
                    icon: '🏃‍♂️',
                    percentile: calculatePercentileFromNorm(avgFastFreq, 'frequency')
                },
                {
                    name: '📏 Finger Spread',
                    value: calculateAverage([...rightTrials, ...leftTrials], 'avgAmplitude'),
                    unit: '%',
                    explanation: 'How wide you open your fingers. Bigger movements show confident control!',
                    icon: '👐',
                    percentile: calculatePercentileFromNorm(calculateAverage([...rightTrials, ...leftTrials], 'avgAmplitude'), 'amplitude')
                },
                {
                    name: '🔋 Stamina',
                    value: Math.max(0, 100 - avgDecrement),
                    unit: '%',
                    explanation: 'How well you maintain your speed. Higher percentage means your brain keeps going strong!',
                    icon: '💪',
                    percentile: calculatePercentileFromNorm(100 - avgDecrement, 'amplitudeDecrement')

                },
                {
                    name: '🎵 Rhythm',
                    value: Math.max(0, 100 - avgRhythmCV),
                    unit: '%',
                    explanation: 'How steady your beat is. Musicians often score high here!',
                    icon: '🥁',
                    percentile: calculatePercentileFromNorm(avgRhythmCV, 'rhythmCV') // Don't invert here, the ranges handle it
                },
                {
                    name: '⚖️ Balance',
                    value: Math.max(0, 100 - asymmetry),
                    unit: '%',
                    explanation: 'How similar your hands perform. Most people have a slightly dominant hand.',
                    icon: '🤝',
                    percentile: asymmetry < 10 ? 85 : asymmetry < 20 ? 50 : 15
                },
                {
                    name: '💫 Fluidity',
                    value: Math.max(0, 100 - (hesitations * 10) - (freezing * 25)),
                    unit: '%',
                    explanation: 'How smoothly you tap without pauses. Like water flowing - no interruptions!',
                    icon: '🌊',
                    percentile: hesitations === 0 && freezing === 0 ? 90 : hesitations <= 2 ? 70 : hesitations <= 5 ? 40 : 20
                }
            ];

            // Display metrics in a responsive grid
            html += '<h2 style="text-align: center; color: #667eea; margin-bottom: 30px; font-size: 2em;">Your Performance Breakdown</h2>';
            html += '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 25px; margin-bottom: 40px; max-width: 1400px; margin-left: auto; margin-right: auto;">';

            metrics.forEach(metric => {
                // Determine performance color based on percentile
                let performanceColor = '#48bb78'; // green
                if (metric.percentile < 25) performanceColor = '#e53e3e'; // red
                else if (metric.percentile < 50) performanceColor = '#ed8936'; // orange
                else if (metric.percentile < 75) performanceColor = '#f6e05e'; // yellow
                
                html += `
                    <div style="background: linear-gradient(135deg, #1e2139 0%, #2a2d4a 100%); 
                                border-radius: 20px; padding: 30px; text-align: center;
                                transition: all 0.3s ease; cursor: pointer;
                                border: 2px solid rgba(102, 126, 234, 0.3);
                                box-shadow: 0 10px 30px rgba(0,0,0,0.3);"
                        onmouseover="this.style.transform='translateY(-5px)'; this.style.boxShadow='0 15px 40px rgba(102,126,234,0.4)'"
                        onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 10px 30px rgba(0,0,0,0.3)'">
                        <div style="font-size: 3.5em; margin-bottom: 15px; filter: drop-shadow(0 0 10px rgba(255,255,255,0.3));">${metric.icon}</div>
                        <h4 style="color: #90cdf4; font-size: 1.2em; margin-bottom: 15px; text-transform: uppercase; letter-spacing: 1px;">${metric.name}</h4>
                        <div style="font-size: 3em; font-weight: bold; color: #ffdd57; margin-bottom: 10px; text-shadow: 0 0 15px rgba(255, 221, 87, 0.5);">
                            ${metric.value.toFixed(0)}${metric.unit}
                        </div>
                        <div style="background: ${performanceColor}; color: white; padding: 8px 16px; border-radius: 20px; 
                                    font-weight: bold; margin: 15px auto; display: inline-block; font-size: 1.1em;">
                            Better than ${metric.percentile}% of people
                        </div>
                        <p style="font-size: 0.95em; opacity: 0.9; line-height: 1.5; margin-top: 15px;">${metric.explanation}</p>
                    </div>
                `;
            });
            html += '</div>';
            
            // Add condition-specific results
            html += `
                <div class="results-summary" style="margin-top: 40px;">
                    <h3>Detailed Results by Condition</h3>
                    <table style="width: 100%; color: white; border-collapse: collapse;">
                        <thead>
                            <tr style="border-bottom: 2px solid #667eea;">
                                <th style="padding: 10px; text-align: left;">Condition</th>
                                <th style="padding: 10px;">Avg Frequency (Hz)</th>
                                <th style="padding: 10px;">Avg Amplitude (%)</th>
                                <th style="padding: 10px;">Rhythm CV (%)</th>
                                <th style="padding: 10px;">Tap Count</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
   

            const conditions = [
                { name: 'Right Hand', data: rightTrials },
                { name: 'Left Hand', data: leftTrials }
            ];

            
            conditions.forEach(cond => {
                const freq = calculateAverage(cond.data, 'avgFrequency');
                const amp = calculateAverage(cond.data, 'avgAmplitude');
                const cv = calculateAverage(cond.data, 'rhythmCV');
                const taps = cond.data.map(t => t.result.metrics.tapCount).reduce((a,b) => a+b, 0) / cond.data.length;
                
                html += `
                    <tr style="border-bottom: 1px solid rgba(255,255,255,0.1);">
                        <td style="padding: 10px;">${cond.name}</td>
                        <td style="padding: 10px; text-align: center;">${freq.toFixed(2)}</td>
                        <td style="padding: 10px; text-align: center;">${amp.toFixed(1)}</td>
                        <td style="padding: 10px; text-align: center;">${cv.toFixed(1)}</td>
                        <td style="padding: 10px; text-align: center;">${taps.toFixed(0)}</td>
                    </tr>
                `;
            });
            
            html += `
                        </tbody>
                    </table>
                </div>
                
                <div style="text-align: center; margin-top: 40px; padding: 30px; 
                            background: linear-gradient(135deg, rgba(102, 126, 234, 0.2) 0%, rgba(118, 75, 162, 0.2) 100%);
                            border-radius: 20px; border: 2px solid #667eea;">
                    <h3 style="color: #ffdd57; font-size: 2em; margin-bottom: 20px;">🧠 Fun Brain Facts!</h3>
                    <p style="font-size: 1.2em; line-height: 1.8; margin-bottom: 20px;">
                        Your finger tapping speed is controlled by multiple brain regions working together like an orchestra!
                        Professional gamers often score high on speed, while musicians excel at rhythm.
                    </p>
                    <div style="font-size: 1.5em; color: #90cdf4; margin-top: 30px;">
                        Challenge your friends and see who has the fastest fingers! 🏆
                    </div>
                </div>
                
                <div class="export-section" style="margin-top: 40px; text-align: center;">
                    <button onclick="location.reload()" style="font-size: 1.3em; padding: 15px 40px; 
                            background: linear-gradient(135deg, #10b981 0%, #34d399 100%);">
                        🎮 Play Again!
                    </button>
                    <button onclick="shareResults()" style="margin-left: 20px; font-size: 1.3em; padding: 15px 40px;">
                        📤 Share Results
                    </button>
                </div>
            `;
            
            document.getElementById('finalResults').innerHTML = html;

            const participantID = sessionStorage.getItem('prolificID') || 'anonymous';

            // Initialize summary trackers
            let totalFreq = 0, totalAmp = 0, totalCV = 0, totalDec = 0;
            let rightHand = [], leftHand = [];
            let conditionBreakdown = {};

            allTrialResults.forEach((trial, index) => {
            const trialNum = `Trial ${index + 1}`;
            const metrics = trial.result.metrics;

            // Save individual trial under participant document
            db.collection("Results")
                .doc(participantID)
                .collection("Trials")
                .doc(trialNum)
                .set({
                condition: trial.condition,
                repetition: trial.repetition,
                ...metrics,
                score: trial.result.score,
                details: trial.result.details,
                timestamp: new Date().toISOString()
                });

            // Aggregate for summary
            totalFreq += metrics.avgFrequency;
            totalAmp += metrics.avgAmplitude;
            totalCV += metrics.rhythmCV;
            totalDec += metrics.amplitudeDecrement;

            if (trial.condition.hand === "right") rightHand.push(metrics.avgAmplitude);
            if (trial.condition.hand === "left") leftHand.push(metrics.avgAmplitude);

            const condKey = `${trial.condition.hand} - ${trial.condition.pace}`;
            conditionBreakdown[condKey] = {
                avgFrequency: metrics.avgFrequency,
                avgAmplitude: metrics.avgAmplitude,
                rhythmCV: metrics.rhythmCV,
                tapCount: metrics.tapEvents?.length || 0
            };
            });

            // Now calculate and store Final Prognosis
            const avgFreq = totalFreq / 8;
            const avgAmp = totalAmp / 8;
            const avgCV = totalCV / 8;
            const avgDec = totalDec / 8;

            const mean = arr => arr.reduce((a, b) => a + b, 0) / arr.length;
            const rightAvg = mean(rightHand);
            const leftAvg = mean(leftHand);
            const finalAsymmetry = Math.abs(rightAvg - leftAvg) / Math.max(rightAvg, leftAvg) * 100;
            db.collection("Results")
            .doc(participantID)
            .collection("Summary")
            .doc("FinalSummary")
            .set({
                completedAt: new Date().toISOString(),
                totalTrials: allTrialResults.length,
                finalAverages: {
                tappingFrequency: avgFastFreq,
                movementAmplitude: calculateAverage([...rightTrials, ...leftTrials], 'avgAmplitude'),
                amplitudeDecrement: avgDecrement,
                rhythmConsistency: avgRhythmCV,
                handAsymmetry: asymmetry
                },
                hesitations: hesitations,
                freezing: freezing,
                allTrialMetrics: allTrialResults.map((t, idx) => ({
                trialNum: idx + 1,
                condition: t.condition,
                ...t.result.metrics
                }))
            })
            .then(() => console.log("✅ Final summary saved for", participantID))
            .catch(err => console.error("❌ Error saving final summary:", err));



        }

        function shareResults() {
            // Calculate the average frequency from the stored results
            const rightTrials = allTrialResults.filter(t => t.condition.hand === 'right');
            const leftTrials = allTrialResults.filter(t => t.condition.hand === 'left');
            
            const calculateAverage = (trials, metric) => {
                const values = trials.map(t => t.result.metrics[metric]);
                return values.reduce((a, b) => a + b, 0) / values.length;
            };
            
            const rightFreq = calculateAverage(rightTrials, 'avgFrequency');
            const leftFreq = calculateAverage(leftTrials, 'avgFrequency');
            const avgFreq = (rightFreq + leftFreq) / 2;
            
            const text = `🎮 I just tested my finger speed!\n\n⚡ My tapping speed: ${avgFreq.toFixed(1)} Hz (${(avgFreq * 20).toFixed(0)} taps in 20 seconds)\n\n🏆 Think you can tap faster? Try it yourself:\n${window.location.origin}`;
            
            if (navigator.share) {
                navigator.share({
                    title: 'My Finger Speed Challenge Results',
                    text: text
                }).catch(err => {
                    // Fallback to clipboard if share fails
                    navigator.clipboard.writeText(text).then(() => {
                        alert('Results copied to clipboard! 📋');
                    });
                });
            } else {
                // Fallback - copy to clipboard
                navigator.clipboard.writeText(text).then(() => {
                    alert('Results copied to clipboard! 📋');
                }).catch(err => {
                    // Final fallback
                    alert('Could not copy results. Your average speed was ' + avgFreq.toFixed(1) + ' Hz');
                });
            }
        }
        // Export all results
        function exportAllResults() {
            const exportData = {
                testDate: new Date().toISOString(),
                summary: {
                    totalTrials: allTrialResults.length,
                    conditions: trialConditions,
                    overallAssessment: document.querySelector('.severity-indicator').textContent
                },
                detailedResults: allTrialResults,
                populationComparisons: POPULATION_NORMS,
                processingParameters: {
                    smoothingWindow: SMOOTHING_WINDOW,
                    minPeakProminence: MIN_PEAK_PROMINENCE,
                    minPeakDistance: MIN_PEAK_DISTANCE
                }
            };

            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `motor_function_analysis_${new Date().toISOString().slice(0, 10)}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // Print results
        function printResults() {
            window.print();
        }

        // Export results as JSON
        function exportResults() {
            if (tapEvents.length === 0) {
                alert('No data to export. Please complete a recording first.');
                return;
            }

            const assessment = calculateClinicalAssessment();
            const exportData = {
                testDate: new Date().toISOString(),
                hand: document.getElementById('handSelect').value,
                assessment: assessment,
                signalData: {
                    raw: distanceSignal,
                    smoothed: smoothedSignal,
                    velocity: velocitySignal,
                    time: timeSignal
                },
                tapEvents: tapEvents,
                processingParameters: {
                    smoothingWindow: SMOOTHING_WINDOW,
                    minPeakProminence: MIN_PEAK_PROMINENCE,
                    minPeakDistance: MIN_PEAK_DISTANCE
                }
            };

            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `pd_finger_tap_advanced_${new Date().toISOString().slice(0, 10)}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // Export data as CSV
        function exportCSV() {
            if (distanceSignal.length === 0) {
                alert('No data to export. Please complete a recording first.');
                return;
            }

            let csv = 'Time (s),Raw Distance,Smoothed Distance,Velocity,Tap Event\n';
            
            for (let i = 0; i < distanceSignal.length; i++) {
                const time = (timeSignal[i] / 1000).toFixed(3);
                const raw = distanceSignal[i].toFixed(2);
                const smooth = i < smoothedSignal.length ? smoothedSignal[i].toFixed(2) : '';
                const vel = i > 0 && i <= velocitySignal.length ? velocitySignal[i-1].toFixed(2) : '';
                const isTap = tapEvents.some(tap => tap.index === i) ? '1' : '0';
                
                csv += `${time},${raw},${smooth},${vel},${isTap}\n`;
            }

            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `pd_finger_tap_signal_${new Date().toISOString().slice(0, 10)}.csv`;
            a.click();
            URL.revokeObjectURL(url);
        }

    
        function showInfoForm() {
                document.getElementById('container-consent').style.display = 'none';
                document.getElementById('container-info').style.display = 'block';
            }

            function startExperiment() {
                // Optionally validate form fields
                const pid = document.getElementById('prolificID').value;
                const age = document.getElementById('age').value;

                            // ✅ Save participant ID so all trials match
                sessionStorage.setItem('prolificID', pid);
                participantID = pid;  // overwrite the anon one


                if (!pid || !age) {
                    alert('Please fill in all required fields.');
                    return;
                }

                document.getElementById('consent-section').style.display = 'none';
                document.querySelector('.container').style.display = 'block';
            }


            document.addEventListener('keydown', function(e) {
                if (e.code === 'Space' || e.key === ' ') {
                    e.preventDefault(); // Prevent page scroll
                    
                    // Check if countdown is already showing
                    const countdownEl = document.getElementById('countdown');
                    const isCountdownActive = countdownEl && countdownEl.style.display === 'block';
                    
                    // Only allow spacebar when ready and not already recording
                    if (!recording && !isCountdownActive) {
                        // Check if hand is detected
                        if (!handDetected) {
                            alert('Please position your hand in view of the camera before starting.');
                            return;
                        }
                        
                        // Check if all trials are done
                        if (trialIndex >= totalTrials) {
                            alert('All trials complete!');
                            return;
                        }
                        
                        startRecording();
                    }
                }
            });

      
        window.onload = function() {
            // ✅ No instructions here, go straight to webcam
            document.getElementById('page-webcam').style.display = 'block';
            initializeHands();
            initializeCamera();
            updateConditionUI();
        };



    </script>
</body>

    <script>

    </script>


</html>
